




  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="For every action…">
    <meta name="author" content="Nathan Bean">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Physics :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="For every action…">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/06-physics/">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Physics :: K-State CIS 580 Textbook">
    <meta property="og:description" content="For every action…">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Physics :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="For every action…">
    <meta itemprop="datePublished" content="2018-08-24T10:53:05-05:00">
    <meta itemprop="dateModified" content="2023-08-11T11:18:05-05:00">
    <meta itemprop="wordCount" content="3">
    <title>Physics :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/06-physics/" rel="canonical" type="text/html" title="Physics :: K-State CIS 580 Textbook">
    <link href="/cis580/06-physics/index.xml" rel="alternate" type="application/rss+xml" title="Physics :: K-State CIS 580 Textbook">
    <link href="/cis580/06-physics/tele.html" rel="alternate" type="text/html" title="Physics :: K-State CIS 580 Textbook">
    <link href="/cis580/06-physics/embed.html" rel="alternate" type="text/html" title="Physics :: K-State CIS 580 Textbook">
    <link href="/cis580/css/fontawesome-all.min.css?1723670679" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/fontawesome-all.min.css?1723670679" rel="stylesheet"></noscript>
    <link href="/cis580/css/nucleus.css?1723670679" rel="stylesheet">
    <link href="/cis580/css/auto-complete.css?1723670679" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/auto-complete.css?1723670679" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar.min.css?1723670679" rel="stylesheet">
    <link href="/cis580/css/fonts.css?1723670679" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/fonts.css?1723670679" rel="stylesheet"></noscript>
    <link href="/cis580/css/theme.css?1723670679" rel="stylesheet">
    <link href="/cis580/css/theme-auto.css?1723670679" rel="stylesheet" id="R-variant-style">
    <link href="/cis580/css/chroma-auto.css?1723670679" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cis580/css/variant.css?1723670679" rel="stylesheet">
    <link href="/cis580/css/print.css?1723670679" rel="stylesheet" media="print">
    <link href="/cis580/css/format-print.css?1723670679" rel="stylesheet">
    <script src="/cis580/js/variant.js?1723670679"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.index_js_url="/cis580/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cis580/css/custom.css?1723670679" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cis580/06-physics/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Physics</span><meta itemprop="position" content="1"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/05-audio/04-music/" title="Music (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/06-physics/01-introduction/" title="Introduction (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="physics">Physics</h1>

<p>For every action&hellip;</p>
<img src="https://media.giphy.com/media/o65WgXSDBVY1G/giphy.gif">
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Physics</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>

<p>Much of gameplay derives from how agents in the game world (players, enemies, puzzle pieces, interactive items, etc) interact with each other.  This is the domain of <em>physics</em>, the rules of how physical (or game) objects interact.  In a sense the game physics define how the game&rsquo;s simulation will unfold.</p>
<p>While game physics often correlate to the physics of the world we inhabit <em>they don&rsquo;t have to!</em>  In fact, most game physics approaches at least <em>simplify</em> real-world physics models to allow for real-time processing, and some abandon real-world physics altogether.</p>
<p>When games <em>do</em> try to implement realistic physics, they typically start with <em>rigid body dynamics</em>, a simplification of real-world physics where objects are represented as a <em>rigid body</em> and a <em>point mass</em>.  In games, the rigid body is essentially the collision shape we covered in chapter 4, and a point mass represents the object&rsquo;s position as a vector, and the mass as a float.</p>
<p>In this chapter we&rsquo;ll examine how to implement rigid body physics in games.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="linear-dynamics">Linear Dynamics</h1>

<p>At some point in your K-12 education, you probably encountered the equations of linear motion, which describe motion in terms of time, i.e.:</p>
<p>
<span class="math align-center">$$ v = at + v_0 \tag{1} $$</span>

<span class="math align-center">$$ p = p_0 + v_ot + \frac{1}{2}at^2 \tag{2} $$</span>

<span class="math align-center">$$ p = p_0 + \frac{1}{2}(v+v_0)t \tag{3} $$</span>

<span class="math align-center">$$ v^2 = v_0^2 2a(r - r_0) \tag{4} $$</span>

<span class="math align-center">$$ p = p_0 + vt - \frac{1}{2}at^2 \tag{5} $$</span></p>
<p>These equations can be used to calculate motion in a video game setting as well, i.e. to calculate an updated position <code>vector2 position</code> given velocity <code>vector2 velocity</code> and acceleration <code>vector2 acceleration</code>, we can take equation (5):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">position</span> <span class="p">+=</span> <span class="n">velocity</span> <span class="p">*</span> <span class="n">gameTime</span><span class="p">.</span><span class="n">ElapsedGameTime</span><span class="p">.</span><span class="n">TotalSeconds</span> <span class="p">+</span> <span class="m">1</span><span class="p">/</span><span class="m">2</span> <span class="p">*</span> <span class="n">acceleration</span> <span class="p">*</span> <span class="n">Math</span><span class="p">.</span><span class="n">Pow</span><span class="p">(</span><span class="n">gameTime</span><span class="p">.</span><span class="n">ElapsedGameTime</span><span class="p">.</span><span class="n">TotalSeconds</span><span class="p">);</span></span></span></code></pre></div><p>This seems like a lot of calculations, and it is.  If you&rsquo;ve also taken calculus, you probably encountered the relationship between position, velocity, and acceleration.</p>
<blockquote>
<p>position is where the object is located in the world
velocity is <em>the rate of change</em> of the position
acceleration is <em>the rate of change</em> of the velocity</p>
</blockquote>
<p>If we represent the position as a function (6), then <em>velocity is the derivative of that function</em> (7), and the acceleration <em>is the second derivative</em> (8):</p>
<p>
<span class="math align-center">$$ s(t) \tag{6} $$</span>

<span class="math align-center">$$ v(t) = s'(t) \tag{7} $$</span>

<span class="math align-center">$$ a(t) = v'(t) \tag{8} $$</span></p>
<p>So, do we need to do calculus to perform game physics?  Well, yes and no.</p>
<p>Calculus is based around the idea of looking at small sections of a function (it literally comes from the latin term for &ldquo;small stone&rdquo;).  Differential calculus cuts a function curve into small pieces to see how it changes, and Integral calculus joins small pieces to see how much there is.</p>
<p>Now consider our timestep - 1/30th or 1/60th of a second.  That&rsquo;s already a pretty small piece.  So if we want to know the current velocity, given our acceleration, we could <em>just look at that small piece</em>, i.e.:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">velocity</span> <span class="p">+=</span> <span class="n">acceleration</span> <span class="p">*</span> <span class="n">gameTime</span><span class="p">.</span><span class="n">elapsedGameTime</span><span class="p">.</span><span class="n">TotalSeconds</span><span class="p">;</span></span></span></code></pre></div><p>Similarly, our position is:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">position</span> <span class="p">+=</span> <span class="n">velocity</span> <span class="p">*</span> <span class="n">gameTime</span><span class="p">.</span><span class="n">elapsedGameTime</span><span class="p">.</span><span class="n">TotalSeconds</span></span></span></code></pre></div><p>That&rsquo;s it.  We can consider our acceleration as an instantaneous change (i.e. we apply a force).  Remeber the definition of force?</p>

<span class="math align-center">$$ \overline{F} = m\overline{a} \tag{9} $$</span>
<p>So to find our acceleration, we rearrange equation 9 to read:</p>

<span class="math align-center">$$ \overline{a} = \overline{F}/m $$</span>
<p>Thus, our acceleration would be the force acting on the body, divided by the mass of the body.  We could calculate this from real values, or try different numbers until we found ones that &ldquo;felt right&rdquo;.</p>
<p>If we have multiple forces acting on an object, we simply sum the individual accelerations to find the net acceleration at that instant, which is then applied to the velocity.</p>

  
  
<div class="box notices cstyle tip">
  <div class="box-label"><i class="fa-fw fas fa-lightbulb"></i> Tip</div>
  <div class="box-content">

<p>Games are a &ldquo;soft&rdquo; simulation, in that we are emulating, but often not <em>duplicating</em> behavior of objects the real world.  This also brings into play <a href="https://en.wikipedia.org/wiki/Hyperreality" rel="external" target="_blank">hyperreality</a>, a philosophical concept that deals with modern humans&rsquo; inability to distinguish perceptions of reality and simulated realities.</p>
<p>One great example is LucasArt&rsquo;s <a href="https://en.wikipedia.org/wiki/Digital_Molecular_Matter" rel="external" target="_blank">Digital Molecular Matter</a> developed for the <em>Force Unleashed</em> series.  Early tests with the physics engine duplicated the breaking of objects based on the actual molecular physics involved.  Playtesters responded that it &ldquo;felt fake&rdquo; as wood did not explode into splinters and glass did not shatter into clouds of thousands of pieces when broken&hellip; so the developers made the effects more unrealistically intense to satisfy player expectations.</p>
</div>
</div>
<h3 id="lunar-lander">Lunar Lander</h3>
<p>Let&rsquo;s look at a simple example, a lunar-lander style game.  We have a lunar lander that has a downward-facing thruster that the player can fire with the spacebar, causing an acceleration of 10 pixels/second<sup>2</sup>.  The lander is also moving laterally at a velocity of 100 pixels/second, and gravity is pulling downward at 5 pixels/second<sup>2</sup>.  We could write an update function like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Initial velocity </span>
</span></span><span class="line"><span class="cl"><span class="n">Vector2</span> <span class="n">velocity</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">Update</span><span class="p">(</span><span class="n">GameTime</span> <span class="n">gameTime</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">t</span> <span class="p">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">gameTime</span><span class="p">.</span><span class="n">ElapsedGameTime</span><span class="p">.</span><span class="n">TotalSeconds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">keyboardState</span><span class="p">.</span><span class="n">IsKeyDown</span><span class="p">(</span><span class="n">Keys</span><span class="p">.</span><span class="n">Space</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// apply thruster acceleration upward</span>
</span></span><span class="line"><span class="cl">        <span class="n">velocity</span> <span class="p">+=</span> <span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">40</span><span class="p">)</span> <span class="p">*</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// apply gravity downward</span>
</span></span><span class="line"><span class="cl">    <span class="n">velocity</span> <span class="p">+=</span> <span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="m">30</span><span class="p">)</span> <span class="p">*</span> <span class="n">t</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// update position</span>
</span></span><span class="line"><span class="cl">    <span class="n">position</span> <span class="p">+=</span> <span class="n">velocity</span> <span class="p">*</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Note that we can avoid all those complicated calculations, <em>because we are only looking at a small slice of time</em>.  If we wanted to look at a bigger span of time, i.e. where a bomb might fall, we have to take more into account.</p>
<p>Also, notice that for this game, we ignore any friction effects (after all, we&rsquo;re in the vacuum of space).  Game programmers often take advantage of any simplifications to these calculations we can.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="angular-dynamics">Angular Dynamics</h1>

<p>There is a second set of equations that govern angular motion (rotation) you may have encountered, where 
<span class="math align-center">$ \omega $</span> is angular velocity, 
<span class="math align-center">$ \alpha $</span> the angular acceleration, and 
<span class="math align-center">$ \theta $</span> the rotation of the body:</p>
<p>
<span class="math align-center">$$ \omega = \omega_0 + \alpha t \tag{1} $$</span>

<span class="math align-center">$$ \theta = \theta_0 + \omega_0 t + \frac{1}{2}\alpha t^2 \tag{2} $$</span>

<span class="math align-center">$$ \theta = \theta_0 + \frac{1}{2}(\omega_0 + \omega)t \tag{3} $$</span>

<span class="math align-center">$$ \omega^2 = \omega_0^2 + 2\alpha(\theta-\theta_0) \tag{4} $$</span>

<span class="math align-center">$$ \theta = \theta_0 + \omega t - \frac{1}{2}\alpha t^2 \tag{5} $$</span></p>
<p>These equations parallel those we saw for linear dynamics, and in fact, have the same derivative relationships between them:</p>
<p>
<span class="math align-center">$$ \theta(t) \tag{6} $$</span>

<span class="math align-center">$$ \omega(t) = \theta'(t) \tag{7} $$</span>

<span class="math align-center">$$ \alpha(t) = \omega'(t) \tag{8} $$</span></p>
<p>And, just like linear dynamics, we can utilize this relationship and our small timestep to sidestep complex calculations in our code.  Thus, we can calculate the rotational change from the angular velocity (assuming <code>float rotation</code>, <code>angularVelocity</code>, and <code>angularAcceleration</code> values expressed in radians):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">rotation</span> <span class="p">+=</span> <span class="n">angularVelocity</span> <span class="p">*</span> <span class="n">gameTime</span><span class="p">.</span><span class="n">elapsedGameTime</span><span class="p">.</span><span class="n">TotalSeconds</span><span class="p">;</span></span></span></code></pre></div><p>And the change in angular velocity can be calculated from the angular acceleration:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">angularAcceleration</span> <span class="p">=</span> <span class="n">angularVelocity</span> <span class="p">*</span> <span class="n">gameTime</span><span class="p">.</span><span class="n">elapsedGameTime</span><span class="p">.</span><span class="n">TotalSeconds</span><span class="p">;</span></span></span></code></pre></div><p>Finally, angular acceleration can be imposed with an instantaneous force.  However, this is slightly more complex than we saw with linear dynamics, as this force needs to be applied somewhere <em>other than the center of mass</em>.  Doing so applies both rotational and linear motion to an object.  This rotational aspect is referred to as <em>torque</em>, and is calculated by taking the cross product of the force&rsquo;s point of application relative to the center of mass and the force vector.  Thus:</p>

<span class="math align-center">$$ \tau = \overline{r} x \overline{F} $$</span>
<p>Where 
<span class="math align-center">$ tau $</span> is our torque, 
<span class="math align-center">$ \overline{r} $</span> is the vector from the center of mass to where the force is applied, and 
<span class="math align-center">$ \overline{F} $</span> is the force vector.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">torque</span> <span class="p">=</span> <span class="n">force</span><span class="p">.</span><span class="n">X</span> <span class="p">*</span> <span class="n">r</span><span class="p">.</span><span class="n">Y</span> <span class="p">-</span> <span class="n">force</span><span class="p">.</span><span class="n">Y</span> <span class="p">*</span> <span class="n">r</span><span class="p">.</span><span class="n">X</span><span class="p">;</span></span></span></code></pre></div><p>Torque is the force imposing angular acceleration, and can be applied directly to the velocity:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">angularAcceleration</span> <span class="p">+=</span> <span class="n">torque</span> <span class="p">*</span> <span class="n">gameTime</span><span class="p">.</span><span class="n">ElapsedGameTime</span><span class="p">.</span><span class="n">TotalSeconds</span><span class="p">;</span></span></span></code></pre></div><p>And much like force and linear acceleration, multiple torques applied to an object are summed.</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>XNA does not define the cross product function in its <code>Vector2</code> library, so we computed it manually above.  If you would like to add it as a method in your projects, we can do so using an <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" rel="external" target="_blank">extension method</a>, i.e. define in one of your game&rsquo;s namespaces:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kd">static</span> <span class="k">class</span> <span class="nc">Vector2Extensions</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// Computes the cross product of two Vector2 structs</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param ref=&#34;a&#34;&gt;The first vector&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param ref=&#34;b&#34;&gt;The second vector&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">float</span> <span class="n">CrossProduct</span><span class="p">(</span><span class="n">Vector2</span> <span class="n">a</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">b</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">X</span> <span class="p">*</span> <span class="n">b</span><span class="p">.</span><span class="n">Y</span> <span class="p">-</span> <span class="n">a</span><span class="p">.</span><span class="n">Y</span> <span class="p">*</span> <span class="n">b</span><span class="p">.</span><span class="n">X</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// Computes the cross product of this vector with another</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param ref=&#34;other&#34;&gt;the other vector&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">float</span> <span class="n">Cross</span><span class="p">(</span><span class="k">this</span> <span class="n">Vector2</span> <span class="n">a</span><span class="p">,</span> <span class="n">Vector2</span> <span class="n">other</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">CrossProduct</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">other</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>As long as this class is in scope (i.e. you have an appropriate <code>using</code> statement), you should be able to invoke <code>Cross()</code> on any <code>Vector2</code>.  So the code listing:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">torque</span> <span class="p">=</span> <span class="n">force</span><span class="p">.</span><span class="n">X</span> <span class="p">*</span> <span class="n">r</span><span class="p">.</span><span class="n">Y</span> <span class="p">-</span> <span class="n">force</span><span class="p">.</span><span class="n">Y</span> <span class="p">*</span> <span class="n">r</span><span class="p">.</span><span class="n">X</span><span class="p">;</span></span></span></code></pre></div><p>Could be rewritten as:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">torque</span> <span class="p">=</span> <span class="n">force</span><span class="p">.</span><span class="n">Cross</span><span class="p">(</span><span class="n">r</span><span class="p">);</span></span></span></code></pre></div><p> </p>
</div>
</div>
<h3 id="rocket-thrust">Rocket Thrust</h3>
<p>Let&rsquo;s work through an example.  Consider this diagram:</p>
<p><a href="#R-image-f0ba944c51506d7e8500569a94eaaf9e" class="lightbox-link"><img alt="Torque applied to a spaceship" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/6.3.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f0ba944c51506d7e8500569a94eaaf9e"><img alt="Torque applied to a spaceship" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/6.3.1.png"></a></p>
<p>The red arrow is the force vector applied from the left rocket.  The green arrow is the vector from the position the force is applied to the center of mass of the ship.  Firing just this one rocket will impose a rotation on the ship in the direction of the white arrow.  Firing <em>both</em> rockets will impose an opposite torque, cancelling both.</p>
<p>Let&rsquo;s write the control code for this spaceship.  We&rsquo;ll define class fields for both linear and angular velocity and acceleration, as well as position, direction, and angle.  We&rsquo;ll also supply a constant for the amount of linear acceleration applied by our spaceship:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Constants</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">LINEAR_ACCELERATION</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Linear movement fields</span>
</span></span><span class="line"><span class="cl"><span class="n">Vector2</span> <span class="n">position</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Vector2</span> <span class="n">direction</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Vector2</span> <span class="n">velocity</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Angular movement fields</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">angle</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">angularVelocity</span><span class="p">;</span></span></span></code></pre></div><p>Then we&rsquo;ll use these in our update method:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">Update</span><span class="p">(</span><span class="n">GameTime</span> <span class="n">gameTime</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">KeyBoardState</span> <span class="n">keyboardState</span> <span class="p">=</span> <span class="n">Keyboard</span><span class="p">.</span><span class="n">GetState</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">t</span> <span class="p">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">gameTime</span><span class="p">.</span><span class="n">ElapsedGameTime</span><span class="p">.</span><span class="n">TotalSeconds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">Vector2</span> <span class="n">acceleration</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">Zero</span><span class="p">;</span> <span class="c1">// linear acceleration</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">angularAcceleration</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="c1">// angular acceleration</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Determine if the left rocket is firing</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">keyboardState</span><span class="p">.</span><span class="n">IsKeyPressed</span><span class="p">(</span><span class="n">Keys</span><span class="p">.</span><span class="n">A</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// LABEL A: Apply linear force in the direction we face from left rocket</span>
</span></span><span class="line"><span class="cl">        <span class="n">acceleration</span> <span class="p">+=</span> <span class="n">direction</span> <span class="p">*</span> <span class="n">LINEAR_ACCELERATION</span> <span class="p">*</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// TODO 1: Calculate and apply torque from left rocket</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Determine if the right rocket is firing </span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">keyboardState</span><span class="p">.</span><span class="n">IsKeyPressed</span><span class="p">(</span><span class="n">Keys</span><span class="p">.</span><span class="n">D</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// LABEL B: Apply linear force in the direction we face from right rocket</span>
</span></span><span class="line"><span class="cl">        <span class="n">acceleration</span> <span class="p">+=</span> <span class="n">direction</span> <span class="p">*</span> <span class="n">LINEAR_ACCELERATION</span> <span class="p">*</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="c1">// TODO 2: Calculate and apply torque from right rocket</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Update linear velocity and position </span>
</span></span><span class="line"><span class="cl">    <span class="n">velocity</span> <span class="p">+=</span> <span class="n">acceleration</span> <span class="p">*</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">position</span> <span class="p">+=</span> <span class="n">velocity</span> <span class="p">*</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// update angular velocity and rotation </span>
</span></span><span class="line"><span class="cl">    <span class="n">angularVelocity</span> <span class="p">+=</span> <span class="n">angularAcceleration</span> <span class="p">*</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">angle</span> <span class="p">+=</span> <span class="n">angularVelocity</span> <span class="p">*</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// LABEL C: Apply rotation to our direction vector  </span>
</span></span><span class="line"><span class="cl">    <span class="n">direction</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">Vector2</span><span class="p">.</span><span class="n">UnitY</span><span class="p">,</span> <span class="k">new</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateRotationZ</span><span class="p">(</span><span class="n">theta</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>There&rsquo;s a lot  going on in this method, so let&rsquo;s break it down in pieces, starting with the code following the <code>LABEL</code> comments:</p>
<h4 id="label-a--b---apply-linear-force-in-the-direction-we-face-from-left-rocket-and-right-rocket">LABEL A &amp; B - Apply linear force in the direction we face from left rocket and right rocket</h4>
<p>When we apply force against a body <em>not toward its center</em>, part of that force becomes torque, but the rest of it is linear acceleration.  Technically, we can calculate exactly what this is with trigonometry.  But in this case, we don&rsquo;t care - we just want the ship to accelerate in the direction it is facing.  So we multiply the <code>direction</code> vector by a constant representing the force divided by the mass of our spaceship (acceleration), and the number of seconds that force was applied.</p>
<p>Note that we consider our spaceship mass to be constant here.  If we were really trying to be 100% accurate, the mass would change over time as we burn fuel.  But that&rsquo;s extra calculations, so unless you are going for realism, it&rsquo;s simpler to provide a constant, a lá <code>LINEAR_ACCELERATION</code>.  Yet another example of simplifying physics for games.</p>
<h4 id="label-c---apply-rotation-to-our-direction-vector">LABEL C - Apply rotation to our direction vector</h4>
<p>We need to know the direction the ship is facing to apply our linear acceleration.  Thus, we need to convert our angle <code>angle</code> into a <code>Vector2</code>.  We can do this with trigonometry:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">direction</span><span class="p">.</span><span class="n">X</span> <span class="p">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="n">Cos</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">direction</span><span class="p">.</span><span class="n">Y</span> <span class="p">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="n">Sin</span><span class="p">(</span><span class="n">theta</span><span class="p">);</span></span></span></code></pre></div><p>Or we can utilize matrix operations:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">direction</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">Vector2</span><span class="p">.</span><span class="n">UnitY</span><span class="p">,</span> <span class="k">new</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateRotationZ</span><span class="p">(</span><span class="n">theta</span><span class="p">));</span></span></span></code></pre></div><p>We&rsquo;ll discuss the math behind this second method soon.  Either method will work.</p>
<h3 id="todo-1-calculate-and-apply-torque-from-left-rocket">TODO 1: Calculate and apply torque from left rocket</h3>
<p>Here we need to insert code for calculating the torque.  First, we need to know the distance from the rocket engine to the center of mass of the ship.  Let&rsquo;s assume our ship sprite is 
<span class="math align-center">$ 152x115 $</span>, and our center of mass is at 
<span class="math align-center">$ <76,50> $</span>.  Thus, our <code>r</code> vector would be:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">Vector2</span> <span class="n">r</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">76</span><span class="p">,</span><span class="m">50</span><span class="p">);</span></span></span></code></pre></div><p>The second value we need is our force.  We could factor in our ship rotation at this point, but it is easier if we instead rotate our coordinate system and place its origin at the center of mass for the ship, i.e.:</p>
<p><a href="#R-image-a535debf62ffaf3242c61c08ce179dd1" class="lightbox-link"><img alt="The rotated coordinate system" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/6.3.2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a535debf62ffaf3242c61c08ce179dd1"><img alt="The rotated coordinate system" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/6.3.2.png"></a></p>
<p>Then our force vector is simply a vector in the upward direction, whose magnitude is the amount of the force tangential to the <code>r</code> vector.  For simplicity, we&rsquo;ll use a literal constant instead of calculating this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">Vector2</span> <span class="n">force</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector2</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">FORCE_MAGNITUDE</span><span class="p">);</span></span></span></code></pre></div><p>Then we can calculate the torque with the cross product of these two vectors:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">torque</span> <span class="p">=</span> <span class="n">force</span><span class="p">.</span><span class="n">X</span> <span class="p">*</span> <span class="n">r</span><span class="p">.</span><span class="n">Y</span> <span class="p">-</span> <span class="n">force</span><span class="p">.</span><span class="n">Y</span> <span class="p">*</span> <span class="n">r</span><span class="p">.</span><span class="n">X</span><span class="p">;</span></span></span></code></pre></div><p>And then calculate the rotational acceleration:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">angularAcceleration</span> <span class="p">+=</span> <span class="n">torque</span> <span class="p">/</span> <span class="n">ROTATIONAL_INERTIA</span><span class="p">;</span></span></span></code></pre></div><p>The <code>ROTATIONAL_INERTIA</code> represents the resistance of the body to rotation (basically, it plays the same role as mass in linear dynamics).  For simplicity, we could treat it as 
<span class="math align-center">$ 1 $</span> (no real effect - after all, we&rsquo;re in a vacuum), which allows us to refactor as:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">angularAcceleration</span> <span class="p">+=</span> <span class="n">torque</span><span class="p">;</span></span></span></code></pre></div><h3 id="todo-2-calculate-and-apply-torque-from-right-rocket">TODO 2: Calculate and apply torque from right rocket</h3>
<p>Now that we&rsquo;ve seen the longhand way of doing things &ldquo;properly&rdquo;, let&rsquo;s apply some game-programming savvy shortcuts to our right-engine calculations.</p>
<p>Note that for this example, the vector <code>r</code> does not change - the engine should always be the same distance from the center of mass, and the force vector of the engine will always be in the same direction. relative to <code>r</code>.  So the cross product of the two will <em>always be the same</em>.  So we could pre-calculate this value, <em>and</em> apply the proper moment of inertia, leaving us with a single constant representing the angular acceleration from the engines which we can represent as a constant, <code>ANGULAR_ACCELERATION</code>.  Since this is reversed for the  right engine, our simplified acceleration calculation would be:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">angularAcceleration</span> <span class="p">-=</span> <span class="n">ANGULAR_ACCELERATION</span> <span class="p">*</span> <span class="n">t</span><span class="p">;</span></span></span></code></pre></div><p>(and the right engine would have been <code>angularAcceleration += ANGULAR_ACCELERATION * t;</code>)</p>
<p>Thus, with careful thought we can simplify six addition operations, four multiplications, one subtraction, one multiplication, and two struct allocation operations to just <em>two multiplications and two additions</em>.  This kind of simplification and optimization is common in game programming.  And, in fact, after calculating the <code>ANGULAR_ACCELERATION</code> value we would probably tweak it until the movement felt natural and fun (or just guess at the value to begin with)!</p>
<p>Of course, if we were doing scientific simulation, we would instead have to carry out all of the calculations, couldn&rsquo;t use fudge factors, and would have additional considerations.  For example, if the fuel tanks are not at the center of mass, then every time we fire our rockets <em>the center of mass will shift!</em>  That is why scientific simulations are considered <em>hard simulations</em>.  Not so much because they are hard to write - but because accuracy is so important.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="elastic-collisions">Elastic Collisions</h1>

<p>Now that we&rsquo;ve looked at movement derived from both linear and angular dynamics, let&rsquo;s revisit them from the perspective of <em>collisions</em>.  If we have two rigid bodies that collide, what should be the outcome?  Consider an <em>elastic</em> collision (one in which the two objects &ldquo;bounce off&rdquo; one another).  From Newtonian mechanics we know that:</p>
<ol>
<li>Energy must be conserved</li>
<li>Momentum must be conserved</li>
</ol>
<p>Thus, if we consider our two objects in isolation (as a system of two), the total system must have the same energy and momentum <em>after</em> the collision that it had <em>before</em> (Note we are talking about <em>perfectly</em> elastic collisions here - in the real world some energy would be converted to heat and sound).</p>
<p>Momentum is the product of mass and velocity of an object:</p>

<span class="math align-center">$$ \rho = mv\tag{0} $$</span>
<p>Since we have two objects, the total momentum in the system is the sum of those:</p>

<span class="math align-center">$$ \rho = m_1v_1 + m_2v_2\tag{1} $$</span>
<p>And, due to the law of conservation of momentum,</p>

<span class="math align-center">$$ \rho_{before} = \rho_{after} \tag{2} $$</span>
<p>So, substituting equation 1 before and after the collision we find:</p>

<span class="math align-center">$$ m_1u_1 + m_2u_2 = m_1v_1 + m_2v_2\tag{3} $$</span>
<p>Where 
<span class="math align-center">$ u $</span> is the velocity <em>before</em> a collision, and 
<span class="math align-center">$ v $</span> is the velocity <em>after</em> (note that the mass of each object does not change).</p>
<p>And since our objects are both moving, they also have kinetic energy:</p>

<span class="math align-center">$$ E_k = \frac{1}{2}mv^2\tag{4} $$</span>
<p>As energy is conserved, the energy <em>before</em> the collision and <em>after</em> must likewise be conserved:</p>

<span class="math align-center">$$ E_{before} = E_{after} \tag{5} $$</span>
<p>Substituting equation 4 into 5 yields:</p>

<span class="math align-center">$$ \frac{1}{2}m_0u_0^2 + \frac{1}{2}m_1u_1^2 = \frac{1}{2}m_0v_0^2 + \frac{1}{2}m_1v_1^2 \tag{6} $$</span>
<p>Assuming we enter the collision knowing the values of 
<span class="math align-center">$ u_0, u_1, m_0, and m_1 $</span>, we have two unknowns 
<span class="math align-center">$ v_0 $</span> and 
<span class="math align-center">$ v_1 $</span> and two equations containing them (equations 3 and 6).  Thus, we can solve for 
<span class="math align-center">$ v_0 $</span> and 
<span class="math align-center">$ v_1 $</span>:</p>
<p>
<span class="math align-center">$$ v_0 = \frac{m_0 - m_1}{m_0 + m_1}u_0 + \frac{2m_1}{m_0+m_1}u_1 \tag{7} $$</span>

<span class="math align-center">$$ v_1 = \frac{2m_0}{m_0+m_1}u_0 + \frac{m_1 - m_0}{m_0 + m_1}u_1 \tag{8} $$</span></p>
<p>These two equations can give us the new velocities in a single dimension.  But we&rsquo;re primarily interested in <em>two</em> dimensions, and our velocities are expressed as <code>Vector2</code> objects.  However, there is a simple solution; use a coordinate system that aligns with the axis of collision, i.e. for two masses colliding, A and B:</p>
<p><a href="#R-image-5fa945a2f20a1fc3d55afce52ba834ce" class="lightbox-link"><img alt="Aligning the coordinate system with the axis of collision" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/6.4.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5fa945a2f20a1fc3d55afce52ba834ce"><img alt="Aligning the coordinate system with the axis of collision" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/6.4.1.png"></a></p>
<p>Note how the X-axis in the diagram is aligned with the line between the centers of mass A and B.  We can accomplish this in code by calculating the vector between the center of the two bodies, and determining the angle between that vector and the x-Axis:</p>
<p><a href="#R-image-e0360a4e9f07a4ae72a13761a318f347" class="lightbox-link"><img alt="Finding the angle between the line of collision and x-axis" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/6.4.2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-e0360a4e9f07a4ae72a13761a318f347"><img alt="Finding the angle between the line of collision and x-axis" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/6.4.2.png"></a></p>
<p>Remember that the angle between two vectors is related to the dot product:</p>

<span class="math align-center">$$ cos\theta = \frac{ a \cdotp b}{||a||*||b||} \tag {9} $$</span>
<p>If both vectors 
<span class="math align-center">$ a $</span> and 
<span class="math align-center">$ b $</span> are of unit length (normalized), then this simplifies to:</p>

<span class="math align-center">$$ cos\theta = a \cdotp b \tag {10} $$</span>
<p>And 
<span class="math align-center">$ \theta $</span> can be solved for by:</p>

<span class="math align-center">$$ \theta = cos^{-1}(a \cdotp b) \tag{11} $$</span>
<p>Given two rigid bodies <code>A</code> and <code>B</code>, we could then calculate this angle using their centers:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="c1">// Determine the line between centers of colliding objects A and B</span>
</span></span><span class="line"><span class="cl"><span class="n">Vector2</span> <span class="n">collisionLine</span> <span class="p">=</span> <span class="n">A</span><span class="p">.</span><span class="n">Center</span> <span class="p">-</span> <span class="n">B</span><span class="p">.</span><span class="n">Center</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Normalize that line</span>
</span></span><span class="line"><span class="cl"><span class="n">collisionLine</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="c1">// Determine the angle between the collision line and the x-axis</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">angle</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Acos</span><span class="p">(</span><span class="n">Vector2</span><span class="p">.</span><span class="n">Dot</span><span class="p">(</span><span class="n">collisionLine</span><span class="p">,</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">UnitX</span><span class="p">));</span></span></span></code></pre></div><p>Once we have this angle, we can rotate our velocity vectors using it, so that the coordinate system now aligns with that axis:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">Vector2</span> <span class="n">u0</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">Matrix</span><span class="p">.</span><span class="n">CreateRotationZ</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">Velocity</span><span class="p">,</span> <span class="n">angle</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">Vector2</span> <span class="n">u1</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">Matrix</span><span class="p">.</span><span class="n">CreateRotationZ</span><span class="p">(</span><span class="n">B</span><span class="p">.</span><span class="n">Velocity</span><span class="p">,</span> <span class="n">angle</span><span class="p">));</span></span></span></code></pre></div><p>We can use these values, along with the masses of the two objects, to calculate the changes in the X-component of the velocity using equations (7) and (8):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">m0</span> <span class="p">=</span> <span class="n">A</span><span class="p">.</span><span class="n">Mass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">float</span> <span class="n">m1</span> <span class="p">=</span> <span class="n">B</span><span class="p">.</span><span class="n">Mass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Vector2</span> <span class="n">v0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v0</span><span class="p">.</span><span class="n">X</span> <span class="p">=</span> <span class="p">((</span><span class="n">m0</span> <span class="p">-</span> <span class="n">m1</span><span class="p">)</span> <span class="p">/</span> <span class="p">(</span><span class="n">m0</span> <span class="p">+</span> <span class="n">m1</span><span class="p">))</span> <span class="p">*</span> <span class="n">u0</span><span class="p">.</span><span class="n">X</span> <span class="p">+</span> <span class="p">((</span><span class="m">2</span> <span class="p">*</span> <span class="n">m1</span><span class="p">)</span> <span class="p">/</span> <span class="p">(</span><span class="n">m0</span> <span class="p">+</span> <span class="n">m1</span><span class="p">))</span> <span class="p">*</span> <span class="n">u1</span><span class="p">.</span><span class="n">X</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Vector2</span> <span class="n">v1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v1</span><span class="p">.</span><span class="n">X</span> <span class="p">=</span> <span class="p">((</span><span class="m">2</span> <span class="p">*</span> <span class="n">m0</span><span class="p">)</span> <span class="p">/</span> <span class="p">(</span><span class="n">m0</span> <span class="p">+</span> <span class="n">m1</span><span class="p">))</span> <span class="p">*</span> <span class="n">u0</span><span class="p">.</span><span class="n">X</span> <span class="p">+</span> <span class="p">((</span><span class="n">m1</span> <span class="p">-</span> <span class="n">m0</span><span class="p">)</span> <span class="p">/</span> <span class="p">(</span><span class="n">m0</span> <span class="p">+</span> <span class="n">m1</span><span class="p">))</span> <span class="p">*</span> <span class="n">u1</span><span class="p">.</span><span class="n">X</span><span class="p">;</span></span></span></code></pre></div><p>And, because the collision axis and the x-axis are the same, this transfer of velocity <em>only</em> occurs along the x-axis.  The y components stay the same!</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">v0</span><span class="p">.</span><span class="n">Y</span> <span class="p">=</span> <span class="n">u0</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">v1</span><span class="p">.</span><span class="n">Y</span> <span class="p">=</span> <span class="n">u0</span><span class="p">.</span><span class="n">Y</span><span class="p">;</span></span></span></code></pre></div><p>Then, we can rotate the velocities back to the original coordinate system and assign the transformed velocities to our bodies:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">A</span><span class="p">.</span><span class="n">Velocity</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateRotationZ</span><span class="p">(-</span><span class="n">angle</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">B</span><span class="p">.</span><span class="n">Velocity</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateRotationZ</span><span class="p">(-</span><span class="n">angle</span><span class="p">));</span></span></span></code></pre></div><p>Some notes on this process:</p>
<ol>
<li>
<p>at this point we are not accounting for when the collision has gone some way into the bodies; it is possible that after velocity is transferred one will be &ldquo;stuck&rdquo; inside the other.  A common approach to avoid this is to move the two apart based on how much overlap there is.  A more accurate and costly approach is to calculate the time from the moment of impact until end of frame, move the bodies with the inverse of their original velocities multiplied by this delta t, and then apply the <em>new</em> velocities for the same delta t.</p>
</li>
<li>
<p>this approach only works on two bodies at a time.  If you have three or more colliding, the common approach is to solve for each pair in the collision multiple times until they are not colliding.  This is not accurate, but gives a reasonable approximation in many cases.</p>
</li>
</ol>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="physics-engines">Physics Engines</h1>

<p>If we want to incorporate more robust and realistic physics than that we have just explored, we would be well-served to look at <em>physics engines</em> designed for use in games.  These are simulations built along the same lines as what we&rsquo;ve discussed - essentially they represent the objects in the game world as rigid bodies, and provide the means for simulating them somewhat realistically.</p>
<h2 id="farseer--velcro-physics">Farseer / Velcro Physics</h2>
<p>One of the best-known of the physics engines developed for XNA was the Farseer Physics Engine, which was renamed to Velcro Physics when it was moved from CodePlex to GitHub.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cis580/commit/43f194969a638fa4572819da4b31060ad574a9ce">Aug 11, 2023</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cis580/js/clipboard.min.js?1723670679" defer></script>
    <script src="/cis580/js/perfect-scrollbar.min.js?1723670679" defer></script>
    <script>
      function useMathJax( config ){
        window.MathJax = Object.assign( window.MathJax || {}, {
          tex: {
            inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
            displayMath: [['\\[', '\\]'], ['$$', '$$']], 
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cis580/js/mathjax/tex-mml-chtml.js?1723670679"></script>
    <script src="/cis580/js/theme.js?1723670679" defer></script>
  </body>
</html>
