<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="For every actionâ€¦">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="Physics :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="For every actionâ€¦">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/06-physics/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Physics :: K-State CIS 580 Textbook">
    <meta property="og:description" content="For every actionâ€¦">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="Physics :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="For every actionâ€¦">
    <meta itemprop="datePublished" content="2018-08-24T10:53:05-05:00">
    <meta itemprop="dateModified" content="2023-08-11T11:18:05-05:00">
    <meta itemprop="wordCount" content="3">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>Physics :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/06-physics/index.html" rel="canonical" type="text/html" title="Physics :: K-State CIS 580 Textbook">
    <link href="/cis580/06-physics/index.xml" rel="alternate" type="application/rss+xml" title="Physics :: K-State CIS 580 Textbook">
    <link href="/cis580/06-physics/tele.html" rel="alternate" type="text/html" title="Physics :: K-State CIS 580 Textbook">
    <link href="/cis580/06-physics/embed.html" rel="alternate" type="text/html" title="Physics :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1755628803" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1755628803" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/search.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1755628803";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/format-print.min.css?1755628803" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/06-physics\/index.html';
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1755628803" rel="stylesheet">
  </head>
  <body class="mobile-support print" data-url="/cis580/06-physics/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper"> 
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class="a11y-only"><a itemprop="item" href="/cis580/index.html"><span itemprop="name">CIS 580: Foundations of Game Programming</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">Physics</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/ksu-cs-textbooks/cis580/edit/master/content/06-physics/_index.md" rel="external" target="_blank" title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/06-physics/index.print.html" title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/05-audio/04-music/index.html" title="Music (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/06-physics/01-introduction/index.html" title="Introduction (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
            <div class="topbar-button topbar-button-embed" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/06-physics/embed.html" title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a>
            </div>
            <div class="topbar-button topbar-button-tele" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/06-physics/tele.html" title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a>
            </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 06-physics" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="physics">Physics</h1>

<p>For every action&hellip;</p>
<img src="https://media.giphy.com/media/o65WgXSDBVY1G/giphy.gif">
  <footer class="footline">
  </footer>
</article>
          <section>
            <h1 class="a11y-only">Subsections of Physics</h1>
<article class="default">
  <header class="headline">
  </header>

<h1 id="introduction">Introduction</h1>

<p>Much of gameplay derives from how agents in the game world (players, enemies, puzzle pieces, interactive items, etc) interact with each other.  This is the domain of <em>physics</em>, the rules of how physical (or game) objects interact.  In a sense the game physics define how the game&rsquo;s simulation will unfold.</p>
<p>While game physics often correlate to the physics of the world we inhabit <em>they don&rsquo;t have to!</em>  In fact, most game physics approaches at least <em>simplify</em> real-world physics models to allow for real-time processing, and some abandon real-world physics altogether.</p>
<p>When games <em>do</em> try to implement realistic physics, they typically start with <em>rigid body dynamics</em>, a simplification of real-world physics where objects are represented as a <em>rigid body</em> and a <em>point mass</em>.  In games, the rigid body is essentially the collision shape we covered in chapter 4, and a point mass represents the object&rsquo;s position as a vector, and the mass as a float.</p>
<p>In this chapter we&rsquo;ll examine how to implement rigid body physics in games.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="linear-dynamics">Linear Dynamics</h1>

<p>At some point in your K-12 education, you probably encountered the equations of linear motion, which describe motion in terms of time, i.e.:</p>
<p><span class="math align-center">$$ v = at + v_0 \tag{1} $$</span>
<span class="math align-center">$$ p = p_0 + v_ot + \frac{1}{2}at^2 \tag{2} $$</span>
<span class="math align-center">$$ p = p_0 + \frac{1}{2}(v+v_0)t \tag{3} $$</span>
<span class="math align-center">$$ v^2 = v_0^2 2a(r - r_0) \tag{4} $$</span>
<span class="math align-center">$$ p = p_0 + vt - \frac{1}{2}at^2 \tag{5} $$</span></p>
<p>These equations can be used to calculate motion in a video game setting as well, i.e. to calculate an updated position <code>vector2 position</code> given velocity <code>vector2 velocity</code> and acceleration <code>vector2 acceleration</code>, we can take equation (5):</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>position += velocity * gameTime.ElapsedGameTime.TotalSeconds + <span style="color:#ae81ff">1</span>/<span style="color:#ae81ff">2</span> * acceleration * Math.Pow(gameTime.ElapsedGameTime.TotalSeconds);</span></span></code></pre></div>
<p>This seems like a lot of calculations, and it is.  If you&rsquo;ve also taken calculus, you probably encountered the relationship between position, velocity, and acceleration.</p>
<blockquote>
<p>position is where the object is located in the world
velocity is <em>the rate of change</em> of the position
acceleration is <em>the rate of change</em> of the velocity</p>
</blockquote>
<p>If we represent the position as a function (6), then <em>velocity is the derivative of that function</em> (7), and the acceleration <em>is the second derivative</em> (8):</p>
<p><span class="math align-center">$$ s(t) \tag{6} $$</span>
<span class="math align-center">$$ v(t) = s'(t) \tag{7} $$</span>
<span class="math align-center">$$ a(t) = v'(t) \tag{8} $$</span></p>
<p>So, do we need to do calculus to perform game physics?  Well, yes and no.</p>
<p>Calculus is based around the idea of looking at small sections of a function (it literally comes from the latin term for &ldquo;small stone&rdquo;).  Differential calculus cuts a function curve into small pieces to see how it changes, and Integral calculus joins small pieces to see how much there is.</p>
<p>Now consider our timestep - 1/30th or 1/60th of a second.  That&rsquo;s already a pretty small piece.  So if we want to know the current velocity, given our acceleration, we could <em>just look at that small piece</em>, i.e.:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>velocity += acceleration * gameTime.elapsedGameTime.TotalSeconds;</span></span></code></pre></div>
<p>Similarly, our position is:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>position += velocity * gameTime.elapsedGameTime.TotalSeconds</span></span></code></pre></div>
<p>That&rsquo;s it.  We can consider our acceleration as an instantaneous change (i.e. we apply a force).  Remeber the definition of force?</p>
<span class="math align-center">$$ \overline{F} = m\overline{a} \tag{9} $$</span>
<p>So to find our acceleration, we rearrange equation 9 to read:</p>
<span class="math align-center">$$ \overline{a} = \overline{F}/m $$</span>
<p>Thus, our acceleration would be the force acting on the body, divided by the mass of the body.  We could calculate this from real values, or try different numbers until we found ones that &ldquo;felt right&rdquo;.</p>
<p>If we have multiple forces acting on an object, we simply sum the individual accelerations to find the net acceleration at that instant, which is then applied to the velocity.</p>

<details open class=" box cstyle notices tip">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-lightbulb"></i> 
    Tip
  </summary>
  <div class="box-content">
<p>Games are a &ldquo;soft&rdquo; simulation, in that we are emulating, but often not <em>duplicating</em> behavior of objects the real world.  This also brings into play <a href="https://en.wikipedia.org/wiki/Hyperreality" rel="external" target="_blank">hyperreality</a>, a philosophical concept that deals with modern humans&rsquo; inability to distinguish perceptions of reality and simulated realities.</p>
<p>One great example is LucasArt&rsquo;s <a href="https://en.wikipedia.org/wiki/Digital_Molecular_Matter" rel="external" target="_blank">Digital Molecular Matter</a> developed for the <em>Force Unleashed</em> series.  Early tests with the physics engine duplicated the breaking of objects based on the actual molecular physics involved.  Playtesters responded that it &ldquo;felt fake&rdquo; as wood did not explode into splinters and glass did not shatter into clouds of thousands of pieces when broken&hellip; so the developers made the effects more unrealistically intense to satisfy player expectations.</p>
  </div>
</details>
<h3 id="lunar-lander">Lunar Lander</h3>
<p>Let&rsquo;s look at a simple example, a lunar-lander style game.  We have a lunar lander that has a downward-facing thruster that the player can fire with the spacebar, causing an acceleration of 10 pixels/second<sup>2</sup>.  The lander is also moving laterally at a velocity of 100 pixels/second, and gravity is pulling downward at 5 pixels/second<sup>2</sup>.  We could write an update function like:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// Initial velocity </span>
</span></span><span style="display:flex;"><span>Vector2 velocity = <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> t = (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(keyboardState.IsKeyDown(Keys.Space))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// apply thruster acceleration upward</span>
</span></span><span style="display:flex;"><span>        velocity += <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">0</span>, -<span style="color:#ae81ff">40</span>) * t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// apply gravity downward</span>
</span></span><span style="display:flex;"><span>    velocity += <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">30</span>) * t
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// update position</span>
</span></span><span style="display:flex;"><span>    position += velocity * t;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Note that we can avoid all those complicated calculations, <em>because we are only looking at a small slice of time</em>.  If we wanted to look at a bigger span of time, i.e. where a bomb might fall, we have to take more into account.</p>
<p>Also, notice that for this game, we ignore any friction effects (after all, we&rsquo;re in the vacuum of space).  Game programmers often take advantage of any simplifications to these calculations we can.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="angular-dynamics">Angular Dynamics</h1>

<p>There is a second set of equations that govern angular motion (rotation) you may have encountered, where <span class="math align-center">$ \omega $</span> is angular velocity, <span class="math align-center">$ \alpha $</span> the angular acceleration, and <span class="math align-center">$ \theta $</span> the rotation of the body:</p>
<p><span class="math align-center">$$ \omega = \omega_0 + \alpha t \tag{1} $$</span>
<span class="math align-center">$$ \theta = \theta_0 + \omega_0 t + \frac{1}{2}\alpha t^2 \tag{2} $$</span>
<span class="math align-center">$$ \theta = \theta_0 + \frac{1}{2}(\omega_0 + \omega)t \tag{3} $$</span>
<span class="math align-center">$$ \omega^2 = \omega_0^2 + 2\alpha(\theta-\theta_0) \tag{4} $$</span>
<span class="math align-center">$$ \theta = \theta_0 + \omega t - \frac{1}{2}\alpha t^2 \tag{5} $$</span></p>
<p>These equations parallel those we saw for linear dynamics, and in fact, have the same derivative relationships between them:</p>
<p><span class="math align-center">$$ \theta(t) \tag{6} $$</span>
<span class="math align-center">$$ \omega(t) = \theta'(t) \tag{7} $$</span>
<span class="math align-center">$$ \alpha(t) = \omega'(t) \tag{8} $$</span></p>
<p>And, just like linear dynamics, we can utilize this relationship and our small timestep to sidestep complex calculations in our code.  Thus, we can calculate the rotational change from the angular velocity (assuming <code>float rotation</code>, <code>angularVelocity</code>, and <code>angularAcceleration</code> values expressed in radians):</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>rotation += angularVelocity * gameTime.elapsedGameTime.TotalSeconds;</span></span></code></pre></div>
<p>And the change in angular velocity can be calculated from the angular acceleration:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>angularAcceleration = angularVelocity * gameTime.elapsedGameTime.TotalSeconds;</span></span></code></pre></div>
<p>Finally, angular acceleration can be imposed with an instantaneous force.  However, this is slightly more complex than we saw with linear dynamics, as this force needs to be applied somewhere <em>other than the center of mass</em>.  Doing so applies both rotational and linear motion to an object.  This rotational aspect is referred to as <em>torque</em>, and is calculated by taking the cross product of the force&rsquo;s point of application relative to the center of mass and the force vector.  Thus:</p>
<span class="math align-center">$$ \tau = \overline{r} x \overline{F} $$</span>
<p>Where <span class="math align-center">$ tau $</span> is our torque, <span class="math align-center">$ \overline{r} $</span> is the vector from the center of mass to where the force is applied, and <span class="math align-center">$ \overline{F} $</span> is the force vector.</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>torque = force.X * r.Y - force.Y * r.X;</span></span></code></pre></div>
<p>Torque is the force imposing angular acceleration, and can be applied directly to the velocity:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>angularAcceleration += torque * gameTime.ElapsedGameTime.TotalSeconds;</span></span></code></pre></div>
<p>And much like force and linear acceleration, multiple torques applied to an object are summed.</p>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>XNA does not define the cross product function in its <code>Vector2</code> library, so we computed it manually above.  If you would like to add it as a method in your projects, we can do so using an <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods" rel="external" target="_blank">extension method</a>, i.e. define in one of your game&rsquo;s namespaces:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Vector2Extensions</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Computes the cross product of two Vector2 structs</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param ref=&#34;a&#34;&gt;The first vector&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param ref=&#34;b&#34;&gt;The second vector&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">float</span> CrossProduct(Vector2 a, Vector2 b)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> a.X * b.Y - a.Y * b.X;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Computes the cross product of this vector with another</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param ref=&#34;other&#34;&gt;the other vector&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">float</span> Cross(<span style="color:#66d9ef">this</span> Vector2 a, Vector2 other)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> CrossProduct(a, other);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>As long as this class is in scope (i.e. you have an appropriate <code>using</code> statement), you should be able to invoke <code>Cross()</code> on any <code>Vector2</code>.  So the code listing:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>torque = force.X * r.Y - force.Y * r.X;</span></span></code></pre></div>
<p>Could be rewritten as:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>torque = force.Cross(r);</span></span></code></pre></div>
<p>Â </p>
  </div>
</details>
<h3 id="rocket-thrust">Rocket Thrust</h3>
<p>Let&rsquo;s work through an example.  Consider this diagram:</p>
<p><a href="#R-image-b184c15f121c0c026561a696d475e28f" class="lightbox-link"><img alt="Torque applied to a spaceship" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/6.3.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b184c15f121c0c026561a696d475e28f"><img alt="Torque applied to a spaceship" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/6.3.1.png"></a></p>
<p>The red arrow is the force vector applied from the left rocket.  The green arrow is the vector from the position the force is applied to the center of mass of the ship.  Firing just this one rocket will impose a rotation on the ship in the direction of the white arrow.  Firing <em>both</em> rockets will impose an opposite torque, cancelling both.</p>
<p>Let&rsquo;s write the control code for this spaceship.  We&rsquo;ll define class fields for both linear and angular velocity and acceleration, as well as position, direction, and angle.  We&rsquo;ll also supply a constant for the amount of linear acceleration applied by our spaceship:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// Constants</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> LINEAR_ACCELERATION = <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Linear movement fields</span>
</span></span><span style="display:flex;"><span>Vector2 position;
</span></span><span style="display:flex;"><span>Vector2 direction;
</span></span><span style="display:flex;"><span>Vector2 velocity;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Angular movement fields</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> angle; 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> angularVelocity;</span></span></code></pre></div>
<p>Then we&rsquo;ll use these in our update method:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    KeyBoardState keyboardState = Keyboard.GetState();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> t = (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>    Vector2 acceleration = Vector2.Zero; <span style="color:#75715e">// linear acceleration</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span> angularAcceleration = <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// angular acceleration</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Determine if the left rocket is firing</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(keyboardState.IsKeyPressed(Keys.A))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// LABEL A: Apply linear force in the direction we face from left rocket</span>
</span></span><span style="display:flex;"><span>        acceleration += direction * LINEAR_ACCELERATION * t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// TODO 1: Calculate and apply torque from left rocket</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Determine if the right rocket is firing </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(keyboardState.IsKeyPressed(Keys.D))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// LABEL B: Apply linear force in the direction we face from right rocket</span>
</span></span><span style="display:flex;"><span>        acceleration += direction * LINEAR_ACCELERATION * t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// TODO 2: Calculate and apply torque from right rocket</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Update linear velocity and position </span>
</span></span><span style="display:flex;"><span>    velocity += acceleration * t;
</span></span><span style="display:flex;"><span>    position += velocity * t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// update angular velocity and rotation </span>
</span></span><span style="display:flex;"><span>    angularVelocity += angularAcceleration * t;
</span></span><span style="display:flex;"><span>    angle += angularVelocity * t;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// LABEL C: Apply rotation to our direction vector  </span>
</span></span><span style="display:flex;"><span>    direction = Vector2.Transform(Vector2.UnitY, <span style="color:#66d9ef">new</span> Matrix.CreateRotationZ(theta));
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>There&rsquo;s a lot  going on in this method, so let&rsquo;s break it down in pieces, starting with the code following the <code>LABEL</code> comments:</p>
<h4 id="label-a--b---apply-linear-force-in-the-direction-we-face-from-left-rocket-and-right-rocket">LABEL A &amp; B - Apply linear force in the direction we face from left rocket and right rocket</h4>
<p>When we apply force against a body <em>not toward its center</em>, part of that force becomes torque, but the rest of it is linear acceleration.  Technically, we can calculate exactly what this is with trigonometry.  But in this case, we don&rsquo;t care - we just want the ship to accelerate in the direction it is facing.  So we multiply the <code>direction</code> vector by a constant representing the force divided by the mass of our spaceship (acceleration), and the number of seconds that force was applied.</p>
<p>Note that we consider our spaceship mass to be constant here.  If we were really trying to be 100% accurate, the mass would change over time as we burn fuel.  But that&rsquo;s extra calculations, so unless you are going for realism, it&rsquo;s simpler to provide a constant, a lÃ¡ <code>LINEAR_ACCELERATION</code>.  Yet another example of simplifying physics for games.</p>
<h4 id="label-c---apply-rotation-to-our-direction-vector">LABEL C - Apply rotation to our direction vector</h4>
<p>We need to know the direction the ship is facing to apply our linear acceleration.  Thus, we need to convert our angle <code>angle</code> into a <code>Vector2</code>.  We can do this with trigonometry:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>direction.X = (<span style="color:#66d9ef">float</span>)Math.Cos(theta);
</span></span><span style="display:flex;"><span>direction.Y = (<span style="color:#66d9ef">float</span>)Math.Sin(theta);</span></span></code></pre></div>
<p>Or we can utilize matrix operations:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>direction = Vector2.Transform(Vector2.UnitY, <span style="color:#66d9ef">new</span> Matrix.CreateRotationZ(theta));</span></span></code></pre></div>
<p>We&rsquo;ll discuss the math behind this second method soon.  Either method will work.</p>
<h3 id="todo-1-calculate-and-apply-torque-from-left-rocket">TODO 1: Calculate and apply torque from left rocket</h3>
<p>Here we need to insert code for calculating the torque.  First, we need to know the distance from the rocket engine to the center of mass of the ship.  Let&rsquo;s assume our ship sprite is <span class="math align-center">$ 152x115 $</span>, and our center of mass is at <span class="math align-center">$ <76,50> $</span>.  Thus, our <code>r</code> vector would be:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Vector2 r = <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">76</span>,<span style="color:#ae81ff">50</span>);</span></span></code></pre></div>
<p>The second value we need is our force.  We could factor in our ship rotation at this point, but it is easier if we instead rotate our coordinate system and place its origin at the center of mass for the ship, i.e.:</p>
<p><a href="#R-image-72761dbb7246da5cc6ac99c7dd2c7811" class="lightbox-link"><img alt="The rotated coordinate system" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/6.3.2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-72761dbb7246da5cc6ac99c7dd2c7811"><img alt="The rotated coordinate system" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/6.3.2.png"></a></p>
<p>Then our force vector is simply a vector in the upward direction, whose magnitude is the amount of the force tangential to the <code>r</code> vector.  For simplicity, we&rsquo;ll use a literal constant instead of calculating this:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Vector2 force = <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">0</span>, FORCE_MAGNITUDE);</span></span></code></pre></div>
<p>Then we can calculate the torque with the cross product of these two vectors:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> torque = force.X * r.Y - force.Y * r.X;</span></span></code></pre></div>
<p>And then calculate the rotational acceleration:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> angularAcceleration += torque / ROTATIONAL_INERTIA;</span></span></code></pre></div>
<p>The <code>ROTATIONAL_INERTIA</code> represents the resistance of the body to rotation (basically, it plays the same role as mass in linear dynamics).  For simplicity, we could treat it as <span class="math align-center">$ 1 $</span> (no real effect - after all, we&rsquo;re in a vacuum), which allows us to refactor as:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> angularAcceleration += torque;</span></span></code></pre></div>
<h3 id="todo-2-calculate-and-apply-torque-from-right-rocket">TODO 2: Calculate and apply torque from right rocket</h3>
<p>Now that we&rsquo;ve seen the longhand way of doing things &ldquo;properly&rdquo;, let&rsquo;s apply some game-programming savvy shortcuts to our right-engine calculations.</p>
<p>Note that for this example, the vector <code>r</code> does not change - the engine should always be the same distance from the center of mass, and the force vector of the engine will always be in the same direction. relative to <code>r</code>.  So the cross product of the two will <em>always be the same</em>.  So we could pre-calculate this value, <em>and</em> apply the proper moment of inertia, leaving us with a single constant representing the angular acceleration from the engines which we can represent as a constant, <code>ANGULAR_ACCELERATION</code>.  Since this is reversed for the  right engine, our simplified acceleration calculation would be:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>angularAcceleration -= ANGULAR_ACCELERATION * t;</span></span></code></pre></div>
<p>(and the right engine would have been <code>angularAcceleration += ANGULAR_ACCELERATION * t;</code>)</p>
<p>Thus, with careful thought we can simplify six addition operations, four multiplications, one subtraction, one multiplication, and two struct allocation operations to just <em>two multiplications and two additions</em>.  This kind of simplification and optimization is common in game programming.  And, in fact, after calculating the <code>ANGULAR_ACCELERATION</code> value we would probably tweak it until the movement felt natural and fun (or just guess at the value to begin with)!</p>
<p>Of course, if we were doing scientific simulation, we would instead have to carry out all of the calculations, couldn&rsquo;t use fudge factors, and would have additional considerations.  For example, if the fuel tanks are not at the center of mass, then every time we fire our rockets <em>the center of mass will shift!</em>  That is why scientific simulations are considered <em>hard simulations</em>.  Not so much because they are hard to write - but because accuracy is so important.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="elastic-collisions">Elastic Collisions</h1>

<p>Now that we&rsquo;ve looked at movement derived from both linear and angular dynamics, let&rsquo;s revisit them from the perspective of <em>collisions</em>.  If we have two rigid bodies that collide, what should be the outcome?  Consider an <em>elastic</em> collision (one in which the two objects &ldquo;bounce off&rdquo; one another).  From Newtonian mechanics we know that:</p>
<ol>
<li>Energy must be conserved</li>
<li>Momentum must be conserved</li>
</ol>
<p>Thus, if we consider our two objects in isolation (as a system of two), the total system must have the same energy and momentum <em>after</em> the collision that it had <em>before</em> (Note we are talking about <em>perfectly</em> elastic collisions here - in the real world some energy would be converted to heat and sound).</p>
<p>Momentum is the product of mass and velocity of an object:</p>
<span class="math align-center">$$ \rho = mv\tag{0} $$</span>
<p>Since we have two objects, the total momentum in the system is the sum of those:</p>
<span class="math align-center">$$ \rho = m_1v_1 + m_2v_2\tag{1} $$</span>
<p>And, due to the law of conservation of momentum,</p>
<span class="math align-center">$$ \rho_{before} = \rho_{after} \tag{2} $$</span>
<p>So, substituting equation 1 before and after the collision we find:</p>
<span class="math align-center">$$ m_1u_1 + m_2u_2 = m_1v_1 + m_2v_2\tag{3} $$</span>
<p>Where <span class="math align-center">$ u $</span> is the velocity <em>before</em> a collision, and <span class="math align-center">$ v $</span> is the velocity <em>after</em> (note that the mass of each object does not change).</p>
<p>And since our objects are both moving, they also have kinetic energy:</p>
<span class="math align-center">$$ E_k = \frac{1}{2}mv^2\tag{4} $$</span>
<p>As energy is conserved, the energy <em>before</em> the collision and <em>after</em> must likewise be conserved:</p>
<span class="math align-center">$$ E_{before} = E_{after} \tag{5} $$</span>
<p>Substituting equation 4 into 5 yields:</p>
<span class="math align-center">$$ \frac{1}{2}m_0u_0^2 + \frac{1}{2}m_1u_1^2 = \frac{1}{2}m_0v_0^2 + \frac{1}{2}m_1v_1^2 \tag{6} $$</span>
<p>Assuming we enter the collision knowing the values of <span class="math align-center">$ u_0, u_1, m_0, and m_1 $</span>, we have two unknowns <span class="math align-center">$ v_0 $</span> and <span class="math align-center">$ v_1 $</span> and two equations containing them (equations 3 and 6).  Thus, we can solve for <span class="math align-center">$ v_0 $</span> and <span class="math align-center">$ v_1 $</span>:</p>
<p><span class="math align-center">$$ v_0 = \frac{m_0 - m_1}{m_0 + m_1}u_0 + \frac{2m_1}{m_0+m_1}u_1 \tag{7} $$</span>
<span class="math align-center">$$ v_1 = \frac{2m_0}{m_0+m_1}u_0 + \frac{m_1 - m_0}{m_0 + m_1}u_1 \tag{8} $$</span></p>
<p>These two equations can give us the new velocities in a single dimension.  But we&rsquo;re primarily interested in <em>two</em> dimensions, and our velocities are expressed as <code>Vector2</code> objects.  However, there is a simple solution; use a coordinate system that aligns with the axis of collision, i.e. for two masses colliding, A and B:</p>
<p><a href="#R-image-16362a6edca5196900b69ab7c0dd85df" class="lightbox-link"><img alt="Aligning the coordinate system with the axis of collision" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/6.4.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-16362a6edca5196900b69ab7c0dd85df"><img alt="Aligning the coordinate system with the axis of collision" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/6.4.1.png"></a></p>
<p>Note how the X-axis in the diagram is aligned with the line between the centers of mass A and B.  We can accomplish this in code by calculating the vector between the center of the two bodies, and determining the angle between that vector and the x-Axis:</p>
<p><a href="#R-image-64a4e6dce62a0a860abb2ad9e3d855cb" class="lightbox-link"><img alt="Finding the angle between the line of collision and x-axis" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/6.4.2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-64a4e6dce62a0a860abb2ad9e3d855cb"><img alt="Finding the angle between the line of collision and x-axis" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/6.4.2.png"></a></p>
<p>Remember that the angle between two vectors is related to the dot product:</p>
<span class="math align-center">$$ cos\theta = \frac{ a \cdotp b}{||a||*||b||} \tag {9} $$</span>
<p>If both vectors <span class="math align-center">$ a $</span> and <span class="math align-center">$ b $</span> are of unit length (normalized), then this simplifies to:</p>
<span class="math align-center">$$ cos\theta = a \cdotp b \tag {10} $$</span>
<p>And <span class="math align-center">$ \theta $</span> can be solved for by:</p>
<span class="math align-center">$$ \theta = cos^{-1}(a \cdotp b) \tag{11} $$</span>
<p>Given two rigid bodies <code>A</code> and <code>B</code>, we could then calculate this angle using their centers:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// Determine the line between centers of colliding objects A and B</span>
</span></span><span style="display:flex;"><span>Vector2 collisionLine = A.Center - B.Center;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Normalize that line</span>
</span></span><span style="display:flex;"><span>collisionLine.Normalize();
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Determine the angle between the collision line and the x-axis</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> angle = Math.Acos(Vector2.Dot(collisionLine, Vector2.UnitX));</span></span></code></pre></div>
<p>Once we have this angle, we can rotate our velocity vectors using it, so that the coordinate system now aligns with that axis:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Vector2 u0 = Vector2.Transform(Matrix.CreateRotationZ(A.Velocity, angle));
</span></span><span style="display:flex;"><span>Vector2 u1 = Vector2.Transform(Matrix.CreateRotationZ(B.Velocity, angle));</span></span></code></pre></div>
<p>We can use these values, along with the masses of the two objects, to calculate the changes in the X-component of the velocity using equations (7) and (8):</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> m0 = A.Mass;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> m1 = B.Mass;
</span></span><span style="display:flex;"><span>Vector2 v0;
</span></span><span style="display:flex;"><span>v0.X = ((m0 - m1) / (m0 + m1)) * u0.X + ((<span style="color:#ae81ff">2</span> * m1) / (m0 + m1)) * u1.X;
</span></span><span style="display:flex;"><span>Vector2 v1;
</span></span><span style="display:flex;"><span>v1.X = ((<span style="color:#ae81ff">2</span> * m0) / (m0 + m1)) * u0.X + ((m1 - m0) / (m0 + m1)) * u1.X;</span></span></code></pre></div>
<p>And, because the collision axis and the x-axis are the same, this transfer of velocity <em>only</em> occurs along the x-axis.  The y components stay the same!</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>v0.Y = u0.Y;
</span></span><span style="display:flex;"><span>v1.Y = u0.Y;</span></span></code></pre></div>
<p>Then, we can rotate the velocities back to the original coordinate system and assign the transformed velocities to our bodies:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>A.Velocity = Vector2.Transform(v0, Matrix.CreateRotationZ(-angle));
</span></span><span style="display:flex;"><span>B.Velocity = Vector2.Transform(v1, Matrix.CreateRotationZ(-angle));</span></span></code></pre></div>
<p>Some notes on this process:</p>
<ol>
<li>
<p>at this point we are not accounting for when the collision has gone some way into the bodies; it is possible that after velocity is transferred one will be &ldquo;stuck&rdquo; inside the other.  A common approach to avoid this is to move the two apart based on how much overlap there is.  A more accurate and costly approach is to calculate the time from the moment of impact until end of frame, move the bodies with the inverse of their original velocities multiplied by this delta t, and then apply the <em>new</em> velocities for the same delta t.</p>
</li>
<li>
<p>this approach only works on two bodies at a time.  If you have three or more colliding, the common approach is to solve for each pair in the collision multiple times until they are not colliding.  This is not accurate, but gives a reasonable approximation in many cases.</p>
</li>
</ol>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="physics-engines">Physics Engines</h1>

<p>If we want to incorporate more robust and realistic physics than that we have just explored, we would be well-served to look at <em>physics engines</em> designed for use in games.  These are simulations built along the same lines as what we&rsquo;ve discussed - essentially they represent the objects in the game world as rigid bodies, and provide the means for simulating them somewhat realistically.</p>
<h2 id="farseer--velcro-physics">Farseer / Velcro Physics</h2>
<p>One of the best-known of the physics engines developed for XNA was the Farseer Physics Engine, which was renamed to Velcro Physics when it was moved from CodePlex to GitHub.</p>

  <footer class="footline">
  </footer>
</article>
          </section>
        </div>
      </main>
<div class="git-footer">
  <p class="theme-version-footer">8.0.0</p>
<p>Last modified by:
              <i class='fa-fw fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cis580/commit/43f194969a638fa4572819da4b31060ad574a9ce">Aug 11, 2023</a>
</p>

</div>
    </div>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cis580/js/mathjax/tex-mml-chtml.js?1755628803"></script>
    <script src="/cis580/js/clipboard/clipboard.min.js?1755628803" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1755628803" defer></script>
    <script src="/cis580/js/theme.min.js?1755628803" defer></script>
  </body>
</html>
