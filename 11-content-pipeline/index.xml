<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Content Pipeline :: K-State CIS 580 Textbook</title>
    <link>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/index.html</link>
    <description>Get Your Assets into the Game!&#xA;via GIPHY</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 11 Oct 2023 12:42:22 -0500</lastBuildDate>
    <atom:link href="https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/01-introduction/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/01-introduction/index.html</guid>
      <description>The creation of assets (textures, audio, models, etc) is a major aspect of game development. In fact, asset creators account for most of a game development team (often a 90/10 split between asset creators and programmers). So creating and using assets is a very important part of creating games!&#xA;To make this process manageable, most assets are created with other software tools - editors specific to the kind of asset we are dealing with.</description>
    </item>
    <item>
      <title>The Content Pipeline</title>
      <link>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/02-the-content-pipeline/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/02-the-content-pipeline/index.html</guid>
      <description>As we described in the introduction, the XNA Content Pipeline’s purpose is to transform asset files (content) in to a form most readily useable by our games. It is implemented as a separate build step that is run every time we compile our game. In fact, each XNA game is actually two projects - the Content project, and the Game project.&#xA;The pipeline is broken up into several steps:&#xA;Importing the asset data Processing the asset data Serializing the asset data Loading the serialized asset data You can see the process here:</description>
    </item>
    <item>
      <title>Extending the Pipeline</title>
      <link>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/03-extending-the-pipeline/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/03-extending-the-pipeline/index.html</guid>
      <description>You might be wondering why the content pipeline in XNA was created this way - with importers, processors, content writers, and content readers. The answer is simple - modularity. If you want to load a new image format that the TextureImporter does not handle, you can write your own custom importer to load its data into a TextureContent object, and then still use the existing TextureProcessor and serialization process.&#xA;Alternatively, you may want to handle a new content type that has no associated classes in XNA at all.</description>
    </item>
    <item>
      <title>Custom Importer</title>
      <link>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/04-custom-importer/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/04-custom-importer/index.html</guid>
      <description>An importer is a class that extends the ContentImporter&lt;T&gt; class and overrides its Import() method. Notice the class is a template class (the &lt;T&gt; in the definition). When we define our own class, we need to replace that T with the specific class we want the importer to populate. In our case, this is the BasicTilemapContent we defined in the previous page.&#xA;All importers need to override the Import() method. This method takes a filename (the filename of the asset) as an argument, and returns the class specified in the template.</description>
    </item>
    <item>
      <title>Custom Processor</title>
      <link>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/05-custom-processor/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/05-custom-processor/index.html</guid>
      <description>A processor is a class that extends the ContentProcessor&lt;TInput, TOutput&gt;class and overrides its Process() method. Like the importer, this is a template class, but with two templates! The TInput identifies the class coming into the Process() method as an argument, and the TOutput identifies the class being returned from the method. Not that these don’t have to be different classes - in our case, we’ll continue using the TilemapContent class we defined earlier, and just populate a few more of its properties:</description>
    </item>
    <item>
      <title>Using in a Game</title>
      <link>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/06-using-in-a-game/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/06-using-in-a-game/index.html</guid>
      <description>Using our newly-created custom pipeline in a game we are building is not terribly complicated, but does require some understanding of how projects in Visual Studio interact. Perhaps most important to this is understanding that the Content.mgcb file in your game solution is actually another Visual Studio project! As such, it can reference other project, just like the C# projects you are used to. This can be done through the MGCB Editor.</description>
    </item>
    <item>
      <title>The Context Object</title>
      <link>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/07-the-context/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/07-the-context/index.html</guid>
      <description>You probably noticed that we supply a context object to both our importer and processor - a ContentImporterContext for the importer and a ContentProcessorContext for the processor.&#xA;They both contain a Logger property, which allows us to log messages during the build process of our assets. This is important, as we can’t use breakpoints in a content project. So instead, we often use context.Logger.LogMessage(), context.Logger.LogImportantMessage(), and context.Logger.LogWarning() to let us expose the inner workings of our context pipeline.</description>
    </item>
    <item>
      <title>Summary</title>
      <link>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/08-summary/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/11-content-pipeline/08-summary/index.html</guid>
      <description>In this chapter we explored the XNA Content Pipeline in more detail, and saw how to extend the pipeline with new custom importers and processors. We saw how these can offload preparing assets for inclusion in our game to the build step, rather than performing that work while running the game. We also saw how to add custom parameters to our content processors, allowing us to tweak how assets are prepared.</description>
    </item>
  </channel>
</rss>