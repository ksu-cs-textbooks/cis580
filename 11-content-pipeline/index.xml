




	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Content Pipeline on K-State CIS 580 Textbook</title>
    <link>https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/index.html</link>
    <description>Recent content in Content Pipeline on K-State CIS 580 Textbook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 20 Mar 2020 10:53:05 -0500</lastBuildDate><atom:link href="https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/01-introduction/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/01-introduction/index.html</guid>
      <description>The creation of assets (textures, audio, models, etc) is a major aspect of game development. In fact, asset creators account for most of a game development team (often a 90/10 split between asset creators and programmers). So creating and using assets is a very important part of creating games!
To make this process manageable, most assets are created with other software tools - editors specific to the kind of asset we are dealing with.</description>
    </item>
    <item>
      <title>The Content Pipeline</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/02-the-content-pipeline/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/02-the-content-pipeline/index.html</guid>
      <description>As we described in the introduction, the XNA Content Pipeline&amp;rsquo;s purpose is to transform asset files (content) in to a form most readily useable by our games. It is implemented as a separate build step that is run every time we compile our game. In fact, each XNA game is actually two projects - the Content project, and the Game project.
The pipeline is broken up into several steps:
Importing the asset data Processing the asset data Serializing the asset data Loading the serialized asset data You can see the process here:</description>
    </item>
    <item>
      <title>Extending the Pipeline</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/03-extending-the-pipline/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/03-extending-the-pipline/index.html</guid>
      <description>You might be wondering why the content pipeline in XNA was created this way - with importers, processors, content writers, and content readers. The answer is simple - modularity. If you want to load a new image format that the TextureImporter does not handle, you can write your own custom importer to load its data into a TextureContent object, and then still use the existing TextureProcessor and serialization process.
Alternatively, you may want to handle a new content type that has no associated classes in XNA at all.</description>
    </item>
    <item>
      <title>Extending the Pipeline</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/04-custom-importer/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/04-custom-importer/index.html</guid>
      <description>You might be wondering why the content pipeline in XNA was created this way - with importers, processors, content writers, and content readers. The answer is simple - modularity. If you want to load a new image format that the TextureImporter does not handle, you can write your own custom importer to load its data into a TextureContent object, and then still use the existing TextureProcessor and serialization process.
Alternatively, you may want to handle a new content type that has no associated classes in XNA at all.</description>
    </item>
    <item>
      <title>Extending the Pipeline</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/04-tiledmap-class/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/11-content-pipeline/04-tiledmap-class/index.html</guid>
      <description>You might be wondering why the content pipeline in XNA was created this way - with importers, processors, content writers, and content readers. The answer is simple - modularity. If you want to load a new image format that the TextureImporter does not handle, you can write your own custom importer to load its data into a TextureContent object, and then still use the existing TextureProcessor and serialization process.
Alternatively, you may want to handle a new content type that has no associated classes in XNA at all.</description>
    </item>
  </channel>
</rss>