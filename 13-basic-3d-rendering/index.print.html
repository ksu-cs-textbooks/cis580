




	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="K-State CIS 580 Textbook">
    <meta name="author" content="Nathan H. Bean">
    <title>Basic 3D Rendering :: K-State CIS 580 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis580/13-basic-3d-rendering/index.html" rel="canonical" type="text/html" title="Basic 3D Rendering :: K-State CIS 580 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis580/13-basic-3d-rendering/index.xml" rel="alternate" type="application/rss+xml" title="Basic 3D Rendering :: K-State CIS 580 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis580/13-basic-3d-rendering/tele.html" rel="alternate" type="text/html" title="Basic 3D Rendering :: K-State CIS 580 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis580/13-basic-3d-rendering/embed.html" rel="alternate" type="text/html" title="Basic 3D Rendering :: K-State CIS 580 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/fontawesome-all.min.css?1692031297" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis580/css/fontawesome-all.min.css?1692031297" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/nucleus.css?1692031297" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/auto-complete.css?1692031297" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis580/css/auto-complete.css?1692031297" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/perfect-scrollbar.min.css?1692031297" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/fonts.css?1692031297" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis580/css/fonts.css?1692031297" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/theme.css?1692031297" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/theme-auto.css?1692031297" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/variant.css?1692031297" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/print.css?1692031297" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/format-print.css?1692031297" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/ie.css?1692031297" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/url.js?1692031297"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/variant.js?1692031297"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis580/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis580/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis580/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/custom.css?1692031297" rel="stylesheet">

  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis580/13-basic-3d-rendering/index.html">
    <div id="body" class="default-animation">
      <div id="sidebar-overlay"></div>
      <div id="toc-overlay"></div>
      <nav id="topbar" class="highlightable">
        <div>
          <div id="top-tele-link">
            <a class="print-link" title='Teleprompter View' href="https://ksu-cs-textbooks.github.io/cis580/13-basic-3d-rendering/tele.html">
              <i class="fas fa-tv fa-fw"></i>
            </a>
          </div>
          <div id="top-embed-link">
            <a class="print-link" title='Embeddable Version' href="https://ksu-cs-textbooks.github.io/cis580/13-basic-3d-rendering/embed.html">
              <i class="fas fa-expand-arrows-alt fa-fw"></i>
            </a>
          </div>
          <div id="breadcrumbs">
            <span id="sidebar-toggle-span">
              <a href="#" id="sidebar-toggle" class="topbar-link" title='Menu (CTRL+ALT+n)'><i class="fas fa-bars fa-fw"></i></a>
            </span>
            <ol class="links" itemscope itemtype="http://schema.org/BreadcrumbList">
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><a itemprop="item" href="https://ksu-cs-textbooks.github.io/cis580/index.html"><span itemprop="name">CIS 580: Foundations of Game Programming</span></a><meta itemprop="position" content="1"> &gt; </li>
              <li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Basic 3D Rendering</span><meta itemprop="position" content="2"></li>
            </ol>
          </div>
        </div>
      </nav>
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>
<h1 id="basic-3d-rendering">Basic 3D Rendering</h1>

<p>It&rsquo;s all triangles!</p>
<img src="https://media.giphy.com/media/3oKIPaYYYLafTAM0i4/giphy.gif"/>
            <footer class="footline">

            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Basic 3D Rendering</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="introduction">Introduction</h1>

<p>The term &ldquo;3D rendering&rdquo; refers to converting a three-dimensional representation of a scene into a two-dimensional frame.  While there are multiple ways to represent and render three-dimensional scenes (ray-tracing, voxels, etc.), games are dominated by a standardized technique supported by graphics card hardware.  This approach is so ubiquitous that when we talk about 3D rendering in games, this is the approach we are typically referring to.</p>
<p>Remember that games are &ldquo;real-time&rdquo;, which means they <em>must</em> present a new frame every 1/30th of a second to create the illusion of motion.  Thus, a 3D game must perform the conversion from 3D representation to 2D representation, <em>plus</em> update the game world, within that narrow span of time.  To fully support monitors with higher refresh rates, this span may be cut further - 1/60th of a second for a 60-hertz refresh rate, or 1/120th of a second for a 120-hertz refresh rate.  Further, to support VR googles, the frame must be rendered <em>twice</em>, once from the perspective of each eye, which further halves the amount of time available for a single frame.</p>
<p>This need for speed is what has driven the adoption and evolution of graphics cards.  The hardware of the graphics cards includes a <em>graphics processing unit</em>, a processor that has been optimized for the math needed to support this technique, and dedicated <em>video memory</em>, where the data needed to support 3D rendering is stored.  The GPU operates in parallel with and semi-independently from the CPU - the game running on the CPU sends instructions to the GPU, which the GPU carries out.  Like any multiprocessor program, care must be taken to avoid accessing shared memory (RAM or Video RAM) concurrently.  This sharing of memory and transmission of instructions is facilitated by a low-level rendering library, typically <a href="https://en.wikipedia.org/wiki/DirectX" target="_blank">DirectX</a>
 or <a href="https://en.wikipedia.org/wiki/OpenGL" target="_blank">OpenGL</a>
.</p>
<p>MonoGame supports both, through different kinds of projects, and provides abstractions that provide a platform-independence layer, in the <a href="https://www.monogame.net/documentation/?page=N_Microsoft_Xna_Framework_Graphics" target="_blank">Xna.Framework.Graphics namespace</a>
.  One important aspect of this layer is that it provides managed memory in conjunction with C#, which is a departure from most game programing (where the developer must manage their memory explicitly, allocating and de-allocating as needed).</p>
<h2 id="the-graphics-pipeline">The Graphics Pipeline</h2>
<p>This process of rendering using 3D accelerated hardware is often described as the Graphics Pipeline:</p>
<p>
<a href="#image-773dae09b5f2b4a77d1640726ed86a23" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis580/images/graphics-pipeline.png" alt="Graphics Pipeline" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-773dae09b5f2b4a77d1640726ed86a23">
<img src="https://ksu-cs-textbooks.github.io/cis580/images/graphics-pipeline.png" alt="Graphics Pipeline" class="lightbox-image" loading="lazy">
</a></p>
<p>We&rsquo;ll walk through this process as we write a demonstration project that will render a rotating 3D cube.  The starter code for this project can be found on <a href="https://github.com/ksu-cis/basic-3d-starter" target="_blank">GitHub</a>
.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="it-starts-with-triangles">It Starts with Triangles</h1>

<p>You probably remember from our discussions of matrix math that we can create matrices to represent arbitrary transformations.  Moreover, we can transform a vector by multiplying it by one of these transformation matrices.  This is the mathematical foundations of hardware-accelerated 3D rendering.  In fact, the GPU is nothing more than a processor optimized for performing matrix and vector operations.</p>
<p>We model our three-dimensional worlds with triangles.  Lots and lots of triangles.  Why triangles?  Remember that three points define a plane.  Three points also can define a triangle.  So we know that the three endpoints of a triangle will <em>always</em> be coplanar.  If we used more than three points, there is a possibility that we might screw up and have one out-of-plane, which would break the process.  So 3D rendering is almost entirely based on rendering triangles (you can also render lines and points with OpenGL and DirectX, but XNA only supports triangles and lines).</p>
<p>Complex objects are therefore composed of multiple triangles, which typically share sides and create a closed shape with a distinct inside and outside.  We call these <em>triangle meshes</em>, and they effectively create a hollow shell in the shape of the object to be rendered:</p>
<p>
<a href="#image-e2222bd778c42278110d038b97eb6f3a" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis580/images/triangle-mesh.png" alt="Triangle Mesh" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-e2222bd778c42278110d038b97eb6f3a">
<img src="https://ksu-cs-textbooks.github.io/cis580/images/triangle-mesh.png" alt="Triangle Mesh" class="lightbox-image" loading="lazy">
</a></p>
<h2 id="vertices">Vertices</h2>
<p>Rather than creating structures for storing triangles, we store the endpoints of the triangles as <em>vertices</em>.  These vertices are a data structure that (at a minimum) defines the coordinate of the triangle endpoint in three dimensions (A Vector3 in XNA).  Vertices can contain additional data needed to render the mesh, including color, texture coordinates, and additional vectors like the surface normal (a Vector3 pointing <em>out</em> from the surface).</p>
<p>Let&rsquo;s create a class to represent our cube, and give it an array of vertices that have both a position and a color:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// A class for rendering a single triangle</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Triangle</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The vertices of the triangle</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    VertexPositionColor[] vertices;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Note the <a href="https://www.monogame.net/documentation/?page=T_Microsoft_Xna_Framework_Graphics_VertexPositionColor" target="_blank">VertexPositionColor</a>
 is defined in the <code>Microsoft.Xna.Framework.Graphics</code> namespace.</p>
<h2 id="triangles">Triangles</h2>
<p>Triangles are then defined by the order the vertices are presented to the graphics card, defined by a <em>graphics primitive type</em>.  There are four supported by XNA, and appear in the <a href="https://www.monogame.net/documentation/?page=T_Microsoft_Xna_Framework_Graphics_PrimitiveType" target="_blank">PrimitiveType enumeration</a>
.  These are <em>LineList</em>, <em>LineStrip</em>, <em>TriangleList</em>, and <em>TriangleStrip</em>.  The first two vertices in a <code>LineList</code> define the two endpoints of a line, the second two, a second line.  In contrast, with a <code>LineStrip</code> each successive line connects to the previous one, sharing a vertex.  Thus vertices 0 and 1 define the first line, vertices 1 and 2 define the second, vertices 2 and 3 the third, and so on&hellip;</p>
<p>The <code>TriangleList</code> and <code>TriangleStrip</code> work the same way.  In a <code>TriangleList</code> each three vertices define a single triangle.  Hence vertices 0, 1, and 2 define the first triangle, and vertices 3, 4, and 5, the second, and so on.  With the <code>TriangleStrip</code>, vertices 0, 1, and 2 define the first triangle; vertices 1, 2, and 3 define the second, vertices 2, 3, and 4 the third, and so on&hellip;</p>
<p>Our <code>Triangle</code> will only be using vertices 0, 1, and 2, so either approach will be identical.  Let&rsquo;s go ahead and define those vertices in a helper method:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Initializes the vertices of the triangle</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> InitializeVertices()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        vertices = <span style="color:#66d9ef">new</span> VertexPositionColor[<span style="color:#ae81ff">3</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// vertex 0</span>
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">0</span>].Position = <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">0</span>].Color = Color.Red;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// vertex 1</span>
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">1</span>].Position = <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">1</span>].Color = Color.Green;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// vertex 2 </span>
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">2</span>].Position = <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">2</span>].Color = Color.Blue;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h2 id="the-effect">The Effect</h2>
<p>One of the major innovations of hardware graphics has been the introduction of <em>programmable shaders</em>.  A shader is simply a program that runs on a GPU, and performs some steps of the graphics pipeline.  At the time XNA was created, there were three points in the graphics pipeline where programmable shaders could be inserted: the <em>vertex shader</em>, the <em>geometry shader</em>, and the <em>pixel shader</em> (additional shader points have been added to graphics cards since).  These shaders are written in a language specific to the GPU and graphics library (DirectX or OpenGL).  In XNA, this language is <a href="https://en.wikipedia.org/wiki/High-Level_Shading_Language" target="_blank">HLSL</a>
.</p>
<p>XNA seeks to simplify the details of setting up shaders by abstracting the heavy lifting into the <a href="https://www.monogame.net/documentation/?page=T_Microsoft_Xna_Framework_Graphics_Effect" target="_blank">Effect Class</a>
.  An <code>Effect</code> handles configuring the graphics device to produce a specific effect through a combination of shaders and hardware settings.  We can create custom classes derived from the <code>Effect</code> class, or use one of those already defined in XNA:</p>
<ul>
<li><a href="https://www.monogame.net/docs/html/T_Microsoft_Xna_Framework_Graphics_BasicEffect.html" target="_blank">BasicEffect</a>
</li>
<li><a href="https://www.monogame.net/docs/html/T_Microsoft_Xna_Framework_Graphics_AlphaTestEffect.html" target="_blank">AlphaTestEffect</a>
</li>
<li><a href="https://www.monogame.net/docs/html/T_Microsoft_Xna_Framework_Graphics_DualTextureEffect.html" target="_blank">DualTextureEffect</a>
</li>
<li><a href="https://www.monogame.net/docs/html/T_Microsoft_Xna_Framework_Graphics_EnvironmentMapEffect.html" target="_blank">EnvironmentMapEffect</a>
</li>
<li><a href="https://www.monogame.net/docs/html/T_Microsoft_Xna_Framework_Graphics_SkinnedEffect.html" target="_blank">SkinnedEffect</a>
</li>
<li><a href="https://www.monogame.net/docs/html/T_Microsoft_Xna_Framework_Graphics_SpriteEffect.html" target="_blank">SpriteEffect</a>
</li>
</ul>
<p>With our triangle, we&rsquo;ll use the <code>BasicEffect</code>, which provides a basic rendering pipeline.  Let&rsquo;s add a field for one to our <code>Triangle</code> class:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The effect to use rendering the triangle</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    BasicEffect effect;</span></span></code></pre></div><p>The effect also needs  a reference to the <code>GraphicsDevice</code> held by our <code>Game</code> instance; so let&rsquo;s also add a <code>Game</code> field:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The game this triangle belongs to </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    Game game;</span></span></code></pre></div><p>You&rsquo;ll also need to add the <code>Microsoft.Xna.Framework</code> namespace to make <code>Game</code> available.</p>
<p>Now let&rsquo;s initialize our effects settings in a second helper method, <code>InitializeEffect()</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Initializes the BasicEffect to render our triangle</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> InitializeEffect()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        effect = <span style="color:#66d9ef">new</span> BasicEffect(game.GraphicsDevice);
</span></span><span style="display:flex;"><span>        effect.World = Matrix.Identity;
</span></span><span style="display:flex;"><span>        effect.View = Matrix.CreateLookAt(
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>), <span style="color:#75715e">// The camera position</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), <span style="color:#75715e">// The camera target,</span>
</span></span><span style="display:flex;"><span>            Vector3.Up            <span style="color:#75715e">// The camera up vector</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        effect.Projection = Matrix.CreatePerspectiveFieldOfView(
</span></span><span style="display:flex;"><span>            MathHelper.PiOver4,                         <span style="color:#75715e">// The field-of-view </span>
</span></span><span style="display:flex;"><span>            game.GraphicsDevice.Viewport.AspectRatio,   <span style="color:#75715e">// The aspect ratio</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0.1f</span>, <span style="color:#75715e">// The near plane distance </span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">100.0f</span> <span style="color:#75715e">// The far plane distance</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        effect.VertexColorEnabled = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>There&rsquo;s a lot going on here, so lets&rsquo; break it down.</p>
<h3 id="the-world-matrix">The World Matrix</h3>
<p>The line <code>effect.World = Matrix.Identity</code> creates the <em>world matrix</em>.  This matrix embodies a transformation that transforms our vertices from <em>model space</em> to <em>game space</em>.  Consider our triangle - it has three endpoints (0, 1, 0), (1, 1, 0), and (1, 0, 0).  As it is defined, it has one endpoint above the origin, one to the right, and the third is above and to the right - in line with the others.  This is its <em>model space</em>.  We might want it to appear somewhere else in our game world - say at (100, 100, 0).  We call our game world <em>world space</em>, and a matrix that would embody the transformation needed to move our triangle from its model space coordinates to its world space coordinates is the <em>world matrix</em>.  We&rsquo;re using <code>Matrix.Identity</code> here, which won&rsquo;t change those coordinates at all.</p>
<p>Instead of thinking of triangles, think of crates.  We probably would use the same crate multiple times throughout our game.  The crate would have been drawn in a modeling program, and probably had its origin at a corner or bottom corner (model space).  When we put it into the level, we would translate and rotate it to get it in just the right spot (world space).  We might put a second copy in a different location, with its own translation.  Hence, the two instances would have the same model coordinates, but different transformations to place them in the world, embodied in different world matrices.</p>
<h3 id="the-view-matrix">The View Matrix</h3>
<p>The line <code>effect.View = Matrix.CreateLookAt(..)</code> creates the <em>view matrix</em>.  This is the transform that shifts us from <em>world space</em> into <em>view space</em>.  View space is relative to the position of the observer - the eye (or camera) is at the origin (0, 0, 0), and they are looking along the z-axis.  Since the observer exists somewhere in the game world, the view transformation shifts the coordinate system so that that position becomes the origin, and everything in the world moves along with it.</p>
<p><a href="https://www.monogame.net/documentation/?page=M_Microsoft_Xna_Framework_Matrix_CreateLookAt" target="_blank">Matrix.CreateLookAt()</a>
 is a method for creating a matrix to embody this transformation, and allows us to specify where the observer is looking from, and to.  The first argument is the position of the observer - where the observer&rsquo;s eye would be in the world.  The second argument is a vector in the direction the observer is looking.  The third helps orient the observer by defining which direction is up.  Normally this would be the up vector (0, 1, 0), but if the observer was a plane that was executing a barrel roll, it would be the down vector (0, -1, 0) halfway through the roll, and every value between as the plane rolled.</p>
<h3 id="the-projection-matrix">The Projection Matrix</h3>
<p>The line <code>effect.Projection = Matrix.CreatePerspectiveFieldOfView(...)</code> creates the <em>projection matrix</em>.  This is the matrix that transforms our 3D scene into a 2D one.  It does this by setting z-values to 0 while (possibly) tweaking x- and y-values to create the illusion of perspective.  There are two commonly used projections in video games: <em>orthographic</em>, which simply removes the z-values, flattening the scene; and <em>perspective</em>, which stretches distant objects an squishes near ones, creating the illusion of depth.</p>
<p><a href="https://www.monogame.net/documentation/?page=M_Microsoft_Xna_Framework_Matrix_CreatePerspectiveFieldOfView" target="_blank">Matrix.CreatePerspectiveFieldOfView()</a>
 creates a perspective matrix that accounts for the field of view of the observer.  The first argument is an angle measuring how wide the field of view should be, measured in radians.  Humans have approximately a 120 degree field-of-view, but most of this is peripheral vision, so we typically use smaller numbers.  This can also be tweaked to provide the illusion of using a telescope or wide lens.  The second argument is the aspect ratio - this should match the aspect ratio of the screen, or the result will seem distorted.  For this reason we draw its value directly from the <code>GraphicsDevice</code>.  The last two values are floats indicating the far and near planes.  The near plane is how close objects can be to the observer before they won&rsquo;t be rendered, and the far plan is how far away they can be.</p>
<p><a href="https://www.monogame.net/documentation/?page=M_Microsoft_Xna_Framework_Matrix_CreateOrthographic" target="_blank">Matrix.CreateOrthographic()</a>
 creates an orthographic matrix.  As there is no distortion, its arguments simply describe a cube, with the near plane and far plane composing the nearest and farthest sides.  The near face is centered on the observer, and only the vertices within the cube are rendered.</p>
<h3 id="vertex-color">Vertex Color</h3>
<p>Finally, the line <code>effect.VertexColorEnabled</code> indicates we want to use the colors in the vertex data to set the color of the triangle.  Since each corner has a different color, the pixels on the face of the triangle will be linearly interpolated by the distance to each corner, creating a gradient.</p>
<h2 id="constructing-the-triangle">Constructing the Triangle</h2>
<p>We&rsquo;ll need to write a constructor that will call both the initialization methods, as well as accept the <code>Game</code> instance:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Constructs a triangle instance</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;game&#34;&gt;The game that is creating the triangle&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Triangle(Game game)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.game = game;
</span></span><span style="display:flex;"><span>        InitializeVertices();
</span></span><span style="display:flex;"><span>        InitializeEffect();
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h2 id="drawing-the-triangle">Drawing the Triangle</h2>
<p>And we&rsquo;ll need to draw our triangle using our <code>BasicEffect</code> and <code>GraphicDevice</code>.  Let&rsquo;s put this code into a <code>Draw()</code> method:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Draws the triangle</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        effect.CurrentTechnique.Passes[<span style="color:#ae81ff">0</span>].Apply();
</span></span><span style="display:flex;"><span>        game.GraphicsDevice.DrawUserPrimitives&lt;VertexPositionColor&gt;(
</span></span><span style="display:flex;"><span>            PrimitiveType.TriangleList, 
</span></span><span style="display:flex;"><span>            vertices,       <span style="color:#75715e">// The vertex data </span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>,              <span style="color:#75715e">// The first vertex to use</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">1</span>               <span style="color:#75715e">// The number of triangles to draw</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>An <code>Effect</code> can require multiple passes through the rendering pipeline, and can even contain multiple techniques.  The line <code>effect.CurrentTechnique.Passes[0].Apply()</code> therefore sets up the graphics device for the first pass with the current technique (with our <code>BasicEffect</code>, it only has one pass).  Then we trigger the rendering with <code>game.GraphicsDevice.DrawUserPrimitives&lt;VertexPositionColor&gt;(...)</code>.  We need to specify what kind of vertex data the graphics card should expect, hence the template <code>&lt;VertexPositionColor&gt;</code>.  The first argument is the type of primitive to render.  In our case, either <code>PrimitiveType.TriangleList</code> or <code>PrimitiveType.TriangleStrip</code> will work, as both use the first three vertices to define the first triangle, and we only have one.  The second argument is an offset in our vertex data - we&rsquo;re starting with the first, so its value is <code>0</code>.  The last argument is the number of primitives (in this case, triangles) to draw.  We only have one defined, so its value is <code>1</code>.</p>
<h2 id="adding-the-triangle-to-game1">Adding the Triangle to Game1</h2>
<p>Now let&rsquo;s use our <code>Triangle</code> in <code>Game1</code>.  Add a field for the triangle to the <code>Game1</code> class:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// The triangle to draw</span>
</span></span><span style="display:flex;"><span>    Triangle triangle;</span></span></code></pre></div><p>And construct it in our <code>Game1.LoadContent()</code>.  We want to be sure the graphics device is set up before we construct our <code>Triangle</code>, so this is a good spot:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Create the triangle</span>
</span></span><span style="display:flex;"><span>    triangle = <span style="color:#66d9ef">new</span> Triangle(<span style="color:#66d9ef">this</span>);</span></span></code></pre></div><p>And finally, let&rsquo;s render it in our <code>Game1.Draw()</code> method:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the triangle </span>
</span></span><span style="display:flex;"><span>    triangle.Draw();</span></span></code></pre></div><p>If you run your code, you should now see the triangle rendered:</p>
<p>
<a href="#image-a81aad575fea03a4d2f366601387c1ac" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis580/images/basic-3d-2.1.png" alt="The rendered triangle" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-a81aad575fea03a4d2f366601387c1ac">
<img src="https://ksu-cs-textbooks.github.io/cis580/images/basic-3d-2.1.png" alt="The rendered triangle" class="lightbox-image" loading="lazy">
</a></p>
<h2 id="rotating-the-triangle">Rotating the Triangle</h2>
<p>Let&rsquo;s go one step farther, and make our triangle rotate around the center of the world.  To do this, we&rsquo;ll add an <code>Update()</code> method to our <code>Triangle</code> class, and modify the <code>effect.World</code> matrix:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Rotates the triangle around the y-axis</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;gameTime&#34;&gt;The GameTime object&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">float</span> angle = (<span style="color:#66d9ef">float</span>)gameTime.TotalGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>        effect.World = Matrix.CreateRotationY(angle);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>The <code>gameTime.TotalGameTime.TotalSeconds</code> represents the total time that has elapsed since the game started running.  We pass this to the <code>Matrix.CreateRotationY()</code> to provide the angle (measured in radians) that the triangle should rotate.</p>
<p>Finally, we&rsquo;ll need to add the <code>Triangle.Update()</code> call to our <code>Game1.Update()</code> method:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Update the triangle </span>
</span></span><span style="display:flex;"><span>    triangle.Update(gameTime);</span></span></code></pre></div><p>Now when you run the program, your triangle rotates around the y-axis.  But for 180 degrees of the rotation, it disappears!  What is happening?</p>
<h2 id="backface-culling">Backface Culling</h2>
<p>If we think back to the idea that the triangles in a 3D mesh are the <em>surface</em> of the object, it makes sense that we would only want to draw the <em>outside</em> faces (as the inside faces will always be obscured).  This is exactly what the graphics device is doing - using a technique called <a href="https://en.wikipedia.org/wiki/Back-face_culling" target="_blank">backface culling</a>
 to only draw triangles that are facing the camera (which eliminates around half the triangles in the scene).</p>
<p>But how do we know which face is the front-facing one?  The graphics device uses <em>winding order</em> to determine this.  Winding order refers to the order the vertices are presented to the hardware.  We can change this value by changing the <a href="">CullMode</a>
.  By default, XNA uses <code>CullCounterClockwiseFace</code>; let&rsquo;s try swapping that.  Add these lines to your <code>Triangle.Draw()</code> method, before you invoke  <code>DrawUserPrimitives()</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Change the backface culling mode</span>
</span></span><span style="display:flex;"><span>    RasterizerState rasterizerState = <span style="color:#66d9ef">new</span> RasterizerState();
</span></span><span style="display:flex;"><span>    rasterizerState.CullMode = CullMode.CullClockwiseFace;
</span></span><span style="display:flex;"><span>    game.GraphicsDevice.RasterizerState = rasterizerState;</span></span></code></pre></div><p>Now its the <em>other</em> face of the triangle that does not appear!  Try changing the <code>CullMode.CullClockwiseFace</code> to <code>CullMode.None</code>.  Now <em>both</em> faces appear!</p>
<p>It is a good idea to cache the prior state <em>before</em> you make changes, and restore them when we&rsquo;re done.  I.e., we should refactor our <code>Draw()</code> method to:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Draws the triangle</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Cache old rasterizer state</span>
</span></span><span style="display:flex;"><span>        RasterizerState oldState = game.GraphicsDevice.RasterizerState;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Disable backface culling </span>
</span></span><span style="display:flex;"><span>        RasterizerState rasterizerState = <span style="color:#66d9ef">new</span> RasterizerState();
</span></span><span style="display:flex;"><span>        rasterizerState.CullMode = CullMode.None;
</span></span><span style="display:flex;"><span>        game.GraphicsDevice.RasterizerState = rasterizerState;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Apply our effect</span>
</span></span><span style="display:flex;"><span>        effect.CurrentTechnique.Passes[<span style="color:#ae81ff">0</span>].Apply();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Draw the triangle</span>
</span></span><span style="display:flex;"><span>        game.GraphicsDevice.DrawUserPrimitives&lt;VertexPositionColor&gt;(
</span></span><span style="display:flex;"><span>            PrimitiveType.TriangleList, 
</span></span><span style="display:flex;"><span>            vertices,       <span style="color:#75715e">// The vertex data </span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>,              <span style="color:#75715e">// The first vertex to use</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">1</span>               <span style="color:#75715e">// The number of triangles to draw</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Restore the prior rasterizer state </span>
</span></span><span style="display:flex;"><span>        game.GraphicsDevice.RasterizerState = oldState;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>Otherwise, our change to the rasterizer state could affect other things we are drawing.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="rendering-a-textured-quad">Rendering a Textured Quad</h1>

<p>While the point of a <code>TriangleStrip</code> is to optimize by reducing the number of vertices, in most cases it still will have repeats, and it is difficult to define a complex mesh out of a single strip.  Thus, in addition to vertices, we can provide <em>indices</em> to specific vertices.  The collection of indices contains nothing more than integers referencing vertices in the vertices collection.  This means each unique vertex needs to be defined exactly once, and the indices take on the role of defining the triangles by giving the position of each successive vertex in the triangle list in the vertex array.</p>
<h2 id="defining-a-textured-quad">Defining a Textured Quad</h2>
<p>Let&rsquo;s give this a try by defining a <code>Quad</code> class with both vertices and indices:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// A class representing a quad (a rectangle composed of two triangles)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Quad</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The vertices of the quad</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    VertexPositionTexture[] vertices;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The vertex indices of the quad</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">short</span>[] indices;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The effect to use rendering the triangle</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    BasicEffect effect;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The game this cube belongs to </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    Game game;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>You will note that instead of our vertex structure being a <code>VertexPositionColor</code>, this time we&rsquo;re using <code>VertexPositionTexture</code>.  Instead of giving each vertex a color, this time we&rsquo;ll be giving it a texture coordinate, and having our <code>effect</code> apply a texture to the face of the quad.</p>
<p>Note also that we use the <code>short</code> data type for our index array.  As a quad has only four vertices (one in each corner), we only need four vertices to define one.  If our vertices start at index 0, that means we only need to represent indices 1-4, so a short is more than sufficient.  With a larger vertex array, we might need to use a larger type of integer.</p>
<h3 id="defining-the-vertices">Defining the Vertices</h3>
<p>As with our triangle, we&rsquo;ll initialize our vertices in a helper method, <code>InitializeVertices</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Initializes the vertices of our quad</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> InitializeVertices() {
</span></span><span style="display:flex;"><span>        vertices = <span style="color:#66d9ef">new</span> VertexPositionTexture[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Define vertex 0 (top left)</span>
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">0</span>].Position = <span style="color:#66d9ef">new</span> Vector3(-<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">0</span>].TextureCoordinate = <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">0</span>, -<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Define vertex 1 (top right)</span>
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">1</span>].Position = <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">1</span>].TextureCoordinate = <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">1</span>, -<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// define vertex 2 (bottom right)</span>
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">2</span>].Position = <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">1</span>, -<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">2</span>].TextureCoordinate = <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// define vertex 3 (bottom left) </span>
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">3</span>].Position = <span style="color:#66d9ef">new</span> Vector3(-<span style="color:#ae81ff">1</span>, -<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        vertices[<span style="color:#ae81ff">3</span>].TextureCoordinate = <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>The quad is two by two, centered on the origin.  The texture coordinates are expressed as floats that fall in the range [0 &hellip; 1].  The texture coordinate (0,0) is the upper-left hand corner of our texture, and (1, 1) is the lower-right corner.</p>
<h3 id="defining-the-indices">Defining the Indices</h3>
<p>Now let&rsquo;s define our indices in their own helper method, <code>InitializeIndices</code>.  Let&rsquo;s assume we&rsquo;re using a triangle list, so we&rsquo;ll need to define all six vertices (with a triangle strip we could cut this to 4):</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Initialize the indices of our quad</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> InitializeIndices() {
</span></span><span style="display:flex;"><span>        indices = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">short</span>[<span style="color:#ae81ff">6</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Define triangle 0 </span>
</span></span><span style="display:flex;"><span>        indices[<span style="color:#ae81ff">0</span>] = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        indices[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        indices[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// define triangle 1</span>
</span></span><span style="display:flex;"><span>        indices[<span style="color:#ae81ff">3</span>] = <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        indices[<span style="color:#ae81ff">4</span>] = <span style="color:#ae81ff">3</span>;
</span></span><span style="display:flex;"><span>        indices[<span style="color:#ae81ff">5</span>] = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h2 id="initializing-the-effect">Initializing the Effect</h2>
<p>And we&rsquo;ll need to set up our effect, which we&rsquo;ll again do in a method named <code>InitializeEffect()</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Initializes the basic effect used to draw the quad</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> InitializeEffect()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        effect = <span style="color:#66d9ef">new</span> BasicEffect(game.GraphicsDevice);
</span></span><span style="display:flex;"><span>        effect.World = Matrix.Identity;
</span></span><span style="display:flex;"><span>        effect.View = Matrix.CreateLookAt(
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>), <span style="color:#75715e">// The camera position</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), <span style="color:#75715e">// The camera target,</span>
</span></span><span style="display:flex;"><span>            Vector3.Up            <span style="color:#75715e">// The camera up vector</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        effect.Projection = Matrix.CreatePerspectiveFieldOfView(
</span></span><span style="display:flex;"><span>            MathHelper.PiOver4,                         <span style="color:#75715e">// The field-of-view </span>
</span></span><span style="display:flex;"><span>            game.GraphicsDevice.Viewport.AspectRatio,   <span style="color:#75715e">// The aspect ratio</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0.1f</span>, <span style="color:#75715e">// The near plane distance </span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">100.0f</span> <span style="color:#75715e">// The far plane distance</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        effect.TextureEnabled = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        effect.Texture = game.Content.Load&lt;Texture2D&gt;(<span style="color:#e6db74">&#34;monogame-logo&#34;</span>);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>This looks almost identical to our triangle example.  The only difference is in the last two lines - instead of setting <code>effect.VertexColorEnabled</code>, we&rsquo;re setting <code>effect.TextureEnabled</code> to <code>true</code>, and providing the <em>monogame-logo.png</em> texture to the <code>effect</code>.</p>
<h3 id="draw-method">Draw() Method</h3>
<p>Now let&rsquo;s write our <code>Draw()</code> method:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Draws the quad</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        effect.CurrentTechnique.Passes[<span style="color:#ae81ff">0</span>].Apply();
</span></span><span style="display:flex;"><span>        game.GraphicsDevice.DrawUserIndexedPrimitives&lt;VertexPositionTexture&gt;(
</span></span><span style="display:flex;"><span>            PrimitiveType.TriangleList,
</span></span><span style="display:flex;"><span>            vertices,   <span style="color:#75715e">// The vertex collection</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>,          <span style="color:#75715e">// The starting index in the vertex array</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">4</span>,          <span style="color:#75715e">// The number of indices in the shape</span>
</span></span><span style="display:flex;"><span>            indices,    <span style="color:#75715e">// The index collection</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>,          <span style="color:#75715e">// The starting index in the index array</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">2</span>           <span style="color:#75715e">// The number of triangles to draw</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h3 id="the-quad-constructor">The Quad Constructor</h3>
<p>To wrap up the <code>Quad</code>, we&rsquo;ll need to add a constructor that takes a parameter of type <code>Game</code> and invokes our initialization:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Constructs the Quad</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;game&#34;&gt;The Game the Quad belongs to&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Quad(Game game)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.game = game;
</span></span><span style="display:flex;"><span>        InitializeVertices();
</span></span><span style="display:flex;"><span>        InitializeIndices();
</span></span><span style="display:flex;"><span>        InitializeEffect();
</span></span><span style="display:flex;"><span>    }   </span></span></code></pre></div><h2 id="adding-our-quad-to-game1">Adding our Quad to Game1</h2>
<p>Now let&rsquo;s use our <code>Quad</code> in <code>Game1</code>.  Add a field for the quad to the <code>Game1</code> class:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// The quad to draw</span>
</span></span><span style="display:flex;"><span>    Quad quad;</span></span></code></pre></div><p>And construct it in our <code>Game1.LoadContent()</code>.  We want to be sure the graphics device is set up before we construct our <code>Quad</code>, so this is a good spot:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Create the quad</span>
</span></span><span style="display:flex;"><span>    quad = <span style="color:#66d9ef">new</span> Quad(<span style="color:#66d9ef">this</span>);</span></span></code></pre></div><p>And finally, let&rsquo;s render it in our <code>Game1.Draw()</code> method:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the quad</span>
</span></span><span style="display:flex;"><span>    quad.Draw();</span></span></code></pre></div><p>If you run your code, you should now see the textured quad rendered:</p>
<p>
<a href="#image-9d0854c130425555cb0182d7423ed44c" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis580/images/basic-3d-3.1.png" alt="The rendered quad" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-9d0854c130425555cb0182d7423ed44c">
<img src="https://ksu-cs-textbooks.github.io/cis580/images/basic-3d-3.1.png" alt="The rendered quad" class="lightbox-image" loading="lazy">
</a></p>
<p>Notice that even though our texture has a transparent background, the background is rendered in black.  Alpha blending is managed by the <code>GraphicsDevice.BlendState</code>, so we&rsquo;ll need to tweak it before we draw the quad:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    game.GraphicsDevice.BlendState = BlendState.AlphaBlend;</span></span></code></pre></div><p>Notice the <a href="https://www.monogame.net/documentation/?page=T_Microsoft_Xna_Framework_Graphics_BlendState" target="_blank">BlendState</a>
 class is the same one we used with <code>SpriteBatch</code> - and it works the same way.</p>
<p>If you run the game now, the logo&rsquo;s background will be properly transparent.</p>
<p>Just as with the <code>RasterizerState</code>, it is a good idea to restore the old <code>BlendState</code>.  So our final <code>Quad.Draw()</code> method might look like:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Draws the quad</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Cache the old blend state </span>
</span></span><span style="display:flex;"><span>    BlendState oldBlendState = game.GraphicsDevice.BlendState;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Enable alpha blending </span>
</span></span><span style="display:flex;"><span>    game.GraphicsDevice.BlendState = BlendState.AlphaBlend;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Apply our effect</span>
</span></span><span style="display:flex;"><span>    effect.CurrentTechnique.Passes[<span style="color:#ae81ff">0</span>].Apply();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Render the quad</span>
</span></span><span style="display:flex;"><span>    game.GraphicsDevice.DrawUserIndexedPrimitives&lt;VertexPositionTexture&gt;(
</span></span><span style="display:flex;"><span>        PrimitiveType.TriangleList,
</span></span><span style="display:flex;"><span>        vertices,   <span style="color:#75715e">// The vertex collection</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0</span>,          <span style="color:#75715e">// The starting index in the vertex array</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">4</span>,          <span style="color:#75715e">// The number of indices in the shape</span>
</span></span><span style="display:flex;"><span>        indices,    <span style="color:#75715e">// The index collection</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0</span>,          <span style="color:#75715e">// The starting index in the index array</span>
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">2</span>           <span style="color:#75715e">// The number of triangles to draw</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Restore the old blend state </span>
</span></span><span style="display:flex;"><span>    game.GraphicsDevice.BlendState = oldBlendState;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>This <code>Quad</code> is very similar to the sprites we&rsquo;ve worked with already - in fact, the <code>SpriteBatch</code> is an optimized way of drawing a lot of textured quads.  It also configures the graphics device and has its own effect, the <a href="https://www.monogame.net/documentation/?page=T_Microsoft_Xna_Framework_Graphics_SpriteEffect" target="_blank">SpriteEffect</a>
.  Because of this optimization, in most cases, you&rsquo;ll want to use the <code>SpriteBatch</code> for textured quads.  But it is good to understand how it is drawing 2D sprites using the 3D pipeline.</p>
<p>Speaking of&hellip; so far we&rsquo;ve only drawn 2D shapes in a 3D world.  Let&rsquo;s move on to an actual 3D shape next.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="rendering-a-cube">Rendering a Cube</h1>

<p>We&rsquo;ll continue our exploration of the rendering pipeline with another shape - a cube.  And as before, we&rsquo;ll introduce another concept - <em>vertex</em> and <em>index buffers</em>.</p>
<p>For our triangle and quad, we drew our shapes using <code>GraphicsDevice.DrawUserPrimitives&lt;T&gt;()</code> and <code>GraphicsDevice.DrawUserIndexedPrimitives&lt;T&gt;()</code>.   Our <code>vertices</code> and <code>indices</code> were simply arrays we declared normally, that we passed to the graphics card using the aforementioned methods.  As with most variables we deal with in C#, the memory used by the <code>vertices</code> and <code>indices</code> arrays was allocated from the computer&rsquo;s RAM.  When we invoked the methods, one of the tasks they do is stream the data to the GPU, so that it can be rendered.</p>
<p>This process can be significantly sped up if, instead of storing the vertex and index data in RAM, we store it in Video Ram (VRAM).  VRAM is the memory that is a part of our graphics card.  Not surprisingly, the GPU has direct access to VRAM and can stream data from it quite quickly - more quickly than it can from RAM.  Especially if we are drawing the same shape using the same vertex and index data every frame.</p>
<p>So how do we get this data into the VRAM?  We have to create a <a href="https://www.monogame.net/documentation/?page=T_Microsoft_Xna_Framework_Graphics_VertexBuffer" target="_blank">VertexBuffer</a>
 and an <a href="https://www.monogame.net/documentation/?page=T_Microsoft_Xna_Framework_Graphics_IndexBuffer" target="_blank">IndexBuffer</a>
.  Let&rsquo;s create a <code>Cube</code> class with instances of these classes.</p>
<h2 id="defining-the-cube-class">Defining the Cube Class</h2>
<p>We&rsquo;ll declare a <code>Cube</code> class much like our <code>Triangle</code> and <code>Quad</code>:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// A class for rendering a cube</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Cube</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The vertices of the cube</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    VertexBuffer vertices;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The vertex indices of the cube</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    IndexBuffer indices;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The effect to use rendering the cube</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    BasicEffect effect;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The game this cube belongs to </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    Game game;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>The only real difference at this point is the use of a <code>VertexBuffer</code> and <code>IndexBuffer</code> as fields.</p>
<h3 id="creating-the-vertex-buffer">Creating the Vertex Buffer</h3>
<p>We need to create the vertex data in much the same way we did with our other shapes - we start with a collection of vertices (we&rsquo;ll use an array again, and give our vertices colors), but then we&rsquo;ll copy that data <em>into</em> the <code>VertexBuffer</code>, which effectively copies it into VRAM (if space is available).  Once again we&rsquo;ll wrap this in an initialization method:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Initialize the vertex buffer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> InitializeVertices()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> vertexData = <span style="color:#66d9ef">new</span> VertexPositionColor[] { 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> VertexPositionColor() { Position = <span style="color:#66d9ef">new</span> Vector3(-<span style="color:#ae81ff">3</span>,  <span style="color:#ae81ff">3</span>, -<span style="color:#ae81ff">3</span>), Color = Color.Blue },
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> VertexPositionColor() { Position = <span style="color:#66d9ef">new</span> Vector3( <span style="color:#ae81ff">3</span>,  <span style="color:#ae81ff">3</span>, -<span style="color:#ae81ff">3</span>), Color = Color.Green },
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> VertexPositionColor() { Position = <span style="color:#66d9ef">new</span> Vector3(-<span style="color:#ae81ff">3</span>, -<span style="color:#ae81ff">3</span>, -<span style="color:#ae81ff">3</span>), Color = Color.Red },
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> VertexPositionColor() { Position = <span style="color:#66d9ef">new</span> Vector3( <span style="color:#ae81ff">3</span>, -<span style="color:#ae81ff">3</span>, -<span style="color:#ae81ff">3</span>), Color = Color.Cyan },
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> VertexPositionColor() { Position = <span style="color:#66d9ef">new</span> Vector3(-<span style="color:#ae81ff">3</span>,  <span style="color:#ae81ff">3</span>,  <span style="color:#ae81ff">3</span>), Color = Color.Blue },
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> VertexPositionColor() { Position = <span style="color:#66d9ef">new</span> Vector3( <span style="color:#ae81ff">3</span>,  <span style="color:#ae81ff">3</span>,  <span style="color:#ae81ff">3</span>), Color = Color.Red },
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> VertexPositionColor() { Position = <span style="color:#66d9ef">new</span> Vector3(-<span style="color:#ae81ff">3</span>, -<span style="color:#ae81ff">3</span>,  <span style="color:#ae81ff">3</span>), Color = Color.Green },
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> VertexPositionColor() { Position = <span style="color:#66d9ef">new</span> Vector3( <span style="color:#ae81ff">3</span>, -<span style="color:#ae81ff">3</span>,  <span style="color:#ae81ff">3</span>), Color = Color.Cyan }
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        vertices = <span style="color:#66d9ef">new</span> VertexBuffer(
</span></span><span style="display:flex;"><span>            game.GraphicsDevice,            <span style="color:#75715e">// The graphics device to load the buffer on </span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">typeof</span>(VertexPositionColor),    <span style="color:#75715e">// The type of the vertex data </span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">8</span>,                              <span style="color:#75715e">// The count of the vertices </span>
</span></span><span style="display:flex;"><span>            BufferUsage.None                <span style="color:#75715e">// How the buffer will be used</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        vertices.SetData&lt;VertexPositionColor&gt;(vertexData);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>We declare our <code>vertexData</code> as an instance variable, which means once this method returns, its memory will be reclaimed.  The <code>VertexBuffer</code> constructor allocates the space needed for the data in VRAM, while the <code>VertexBuffer.SetData()</code> method what actually copies it into that location, managing the process for us.</p>
<p>If we were writing DirectX code in C++, we would need to:</p>
<ol>
<li>Allocate memory in VRAM for the buffer</li>
<li>Lock that memory location (remember, both the GPU and CPU can access VRAM at a given time)</li>
<li>Copy the bytes of the buffer into that location, and</li>
<li>Release the lock</li>
</ol>
<p>If you are interested in seeing what the equivalent code in C++ looks like, visit <a href="http://www.directxtutorial.com/Lesson.aspx?lessonid=9-4-7" target="_blank">www.directxtutorial.com</a>
.  Our vertex and index data is adapted from the cube presented there.</p>
<h3 id="creating-the-index-buffer">Creating the Index Buffer</h3>
<p>The index buffer is initialized and the data copied in the same way:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Initializes the index buffer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> InitializeIndices()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">var</span> indexData = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">short</span>[]
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#75715e">// Side 0</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">6</span>, <span style="color:#75715e">// Side 1</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#75715e">// Side 2</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">4</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">7</span>, <span style="color:#75715e">// Side 3 </span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">0</span>, <span style="color:#75715e">// Side 4 </span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">2</span>, <span style="color:#75715e">// Side 5 </span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">6</span>
</span></span><span style="display:flex;"><span>        };
</span></span><span style="display:flex;"><span>        indices = <span style="color:#66d9ef">new</span> IndexBuffer(
</span></span><span style="display:flex;"><span>            game.GraphicsDevice,            <span style="color:#75715e">// The graphics device to use</span>
</span></span><span style="display:flex;"><span>            IndexElementSize.SixteenBits,   <span style="color:#75715e">// The size of the index </span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">36</span>,                             <span style="color:#75715e">// The count of the indices</span>
</span></span><span style="display:flex;"><span>            BufferUsage.None                <span style="color:#75715e">// How the buffer will be used</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        indices.SetData&lt;<span style="color:#66d9ef">short</span>&gt;(indexData);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h3 id="initializing-the-effect">Initializing the Effect</h3>
<p>And our <code>BasicEffect</code> is configured identically to how we di so for our <code>Triangle</code> class:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Initializes the BasicEffect to render our cube</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> InitializeEffect()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        effect = <span style="color:#66d9ef">new</span> BasicEffect(game.GraphicsDevice);
</span></span><span style="display:flex;"><span>        effect.World = Matrix.Identity;
</span></span><span style="display:flex;"><span>        effect.View = Matrix.CreateLookAt(
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">4</span>), <span style="color:#75715e">// The camera position</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>), <span style="color:#75715e">// The camera target,</span>
</span></span><span style="display:flex;"><span>            Vector3.Up            <span style="color:#75715e">// The camera up vector</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        effect.Projection = Matrix.CreatePerspectiveFieldOfView(
</span></span><span style="display:flex;"><span>            MathHelper.PiOver4,                         <span style="color:#75715e">// The field-of-view </span>
</span></span><span style="display:flex;"><span>            game.GraphicsDevice.Viewport.AspectRatio,   <span style="color:#75715e">// The aspect ratio</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0.1f</span>, <span style="color:#75715e">// The near plane distance </span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">100.0f</span> <span style="color:#75715e">// The far plane distance</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>        effect.VertexColorEnabled = <span style="color:#66d9ef">true</span>;     
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h3 id="drawing-the-cube">Drawing the Cube</h3>
<p>Our <code>cube.Draw()</code> method will be a bit different though:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Draws the Cube</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// apply the effect </span>
</span></span><span style="display:flex;"><span>        effect.CurrentTechnique.Passes[<span style="color:#ae81ff">0</span>].Apply();
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// set the vertex buffer</span>
</span></span><span style="display:flex;"><span>        game.GraphicsDevice.SetVertexBuffer(vertices);
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// set the index buffer</span>
</span></span><span style="display:flex;"><span>        game.GraphicsDevice.Indices = indices;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Draw the triangles</span>
</span></span><span style="display:flex;"><span>        game.GraphicsDevice.DrawIndexedPrimitives(
</span></span><span style="display:flex;"><span>            PrimitiveType.TriangleList, <span style="color:#75715e">// Tye type to draw</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>,                          <span style="color:#75715e">// The first vertex to use</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">0</span>,                          <span style="color:#75715e">// The first index to use</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ae81ff">12</span>                          <span style="color:#75715e">// the number of triangles to draw</span>
</span></span><span style="display:flex;"><span>        );
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>Before we can use <a href="https://www.monogame.net/documentation/?page=M_Microsoft_Xna_Framework_Graphics_GraphicsDevice_DrawIndexedPrimitives" target="_blank">GraphicsDevice.DrawIndexedPrimitives()</a>
, we need to tell the <code>GraphicsDevice</code> which <code>VertexBuffer</code> and <code>IndexBuffer</code> to use.  The first is set with a method, the second through assignment.  With both set, we can invoke <code>GraphicsDevice.DrawIndexedPrimitives()</code> and it will draw the contents of the buffers.</p>
<h3 id="constructing-the-cube">Constructing the Cube</h3>
<p>The <code>Cube</code> constructor is back in familiar territory:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Constructs a cube instance</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;game&#34;&gt;The game that is creating the cube&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Cube(Game1 game)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.game = game;
</span></span><span style="display:flex;"><span>        InitializeVertices();
</span></span><span style="display:flex;"><span>        InitializeIndices();
</span></span><span style="display:flex;"><span>        InitializeEffect();
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><h2 id="adding-the-cube-to-game1">Adding the Cube to Game1</h2>
<p>To render our cube, we must go back to the <code>Game1</code> class and add a reference to one:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// The cube to draw </span>
</span></span><span style="display:flex;"><span>    Cube cube;</span></span></code></pre></div><p>Construct it in the <code>Game1.LoadContent()</code> method:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Create the cube</span>
</span></span><span style="display:flex;"><span>    cube = <span style="color:#66d9ef">new</span> Cube(<span style="color:#66d9ef">this</span>);</span></span></code></pre></div><p>And draw it in the <code>Game1.Draw()</code> method:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// draw the cube</span>
</span></span><span style="display:flex;"><span>    cube.Draw();</span></span></code></pre></div><p>If you run your code now, the cube is so big that the front face takes up the whole screen!</p>
<h2 id="changing-the-view-matrix">Changing the View Matrix</h2>
<p>We could scale our cube down with a world transform - but rather than doing that, let&rsquo;s look at it from farther away by changing the view transform.  Let&rsquo;s add an <code>Update()</code> method to our <code>Cube</code> class:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Updates the Cube</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;gameTime&#34;&gt;&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Look at the cube from farther away</span>
</span></span><span style="display:flex;"><span>        effect.View = Matrix.CreateLookAt(
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>, -<span style="color:#ae81ff">10</span>),
</span></span><span style="display:flex;"><span>            Vector3.Zero,
</span></span><span style="display:flex;"><span>            Vector3.Up
</span></span><span style="display:flex;"><span>        ); 
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>And invoke this method in the <code>Game1.Update()</code> method:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// update the cube </span>
</span></span><span style="display:flex;"><span>    cube.Update(gameTime);</span></span></code></pre></div><p>Now if you run the program, you should see the cube, and be able to see that its edges are distorted to simulate depth:</p>
<p>
<a href="#image-6e4840845c2a1ac63f580b5142584449" class="lightbox-link">
<img src="https://ksu-cs-textbooks.github.io/cis580/images/basic-3d-4.1.png" alt="Rendered Cube" style="height: auto; width: auto;" loading="lazy">
</a>
<a href="javascript:history.back();" class="lightbox" id="image-6e4840845c2a1ac63f580b5142584449">
<img src="https://ksu-cs-textbooks.github.io/cis580/images/basic-3d-4.1.png" alt="Rendered Cube" class="lightbox-image" loading="lazy">
</a></p>
<p>Let&rsquo;s set our viewpoint rotating around the cube by refactoring our <code>Cube.Update()</code> method:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Updates the Cube</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;gameTime&#34;&gt;&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">float</span> angle = (<span style="color:#66d9ef">float</span>)gameTime.TotalGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Look at the cube from farther away while spinning around it</span>
</span></span><span style="display:flex;"><span>        effect.View = Matrix.CreateRotationY(angle) * Matrix.CreateLookAt(
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">new</span> Vector3(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>, -<span style="color:#ae81ff">10</span>),
</span></span><span style="display:flex;"><span>            Vector3.Zero,
</span></span><span style="display:flex;"><span>            Vector3.Up
</span></span><span style="display:flex;"><span>        ); 
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div><p>Now our cube appears to be spinning!  But actually, it is our vantage point that is circling the cube, unlike the triangle, which is actually spinning in place.  The final effect is the same, but one spin is applied to the world transform, and the other to the view transform.  We&rsquo;ll speak about both in more detail later.</p>

            <footer class="footline">

            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>
<h1 id="summary">Summary</h1>

<p>This wraps up our discussion of the basics of 3D rendering.  As you might expect, this is just the basic foundations.  From here we&rsquo;ll explore using models, creating lighting effect, animations, and more.  But all of these will depend on understanding and using these basic elements, so get comfortable with them!</p>

            <footer class="footline">

            </footer>
          </article>

          </section>

        </div>
      </main>
    
<div class="git-footer">
<p class="theme-version-footer">5.18.0</p>
<p>Last modified by: 
            <i class='fas fa-user'></i> Russell Feldhausen
            <i class='fas fa-calendar'></i> <a href="https://gitlab.cs.ksu.edu/cs-textbooks/cis580-textbook/-/commit/43f194969a638fa4572819da4b31060ad574a9ce">Aug 11, 2023</a>
</p>
</div>

    
    </div>
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/clipboard.min.js?1692031299" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/perfect-scrollbar.min.js?1692031299" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/theme.js?1692031299" defer></script>
  </body>
</html>
