




  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="Instead of letting the OS tell us when an input event occurs (as we do with event-driven programming), in the game loop we use device polling with the input devices. This means that we ask the device for its current state when we start processing user input.
Consider a gamepad with a button, A. We can represent such a button with a boolean value; true if it is pressed, and false if it is not.">
    <meta name="author" content="Nathan Bean">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Input Polling :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="Instead of letting the OS tell us when an input event occurs (as we do with event-driven programming), in the game loop we use device polling with the input devices. This means that we ask the device for its current state when we start processing user input.
Consider a gamepad with a button, A. We can represent such a button with a boolean value; true if it is pressed, and false if it is not.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/02-player-input/02-input-polling/">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Input Polling :: K-State CIS 580 Textbook">
    <meta property="og:description" content="Instead of letting the OS tell us when an input event occurs (as we do with event-driven programming), in the game loop we use device polling with the input devices. This means that we ask the device for its current state when we start processing user input.
Consider a gamepad with a button, A. We can represent such a button with a boolean value; true if it is pressed, and false if it is not.">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Player Input">
    <meta property="article:published_time" content="2018-08-24T10:53:26-05:00">
    <meta property="article:modified_time" content="2021-01-24T22:34:21-06:00">
    <meta itemprop="name" content="Input Polling :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="Instead of letting the OS tell us when an input event occurs (as we do with event-driven programming), in the game loop we use device polling with the input devices. This means that we ask the device for its current state when we start processing user input.
Consider a gamepad with a button, A. We can represent such a button with a boolean value; true if it is pressed, and false if it is not.">
    <meta itemprop="datePublished" content="2018-08-24T10:53:26-05:00">
    <meta itemprop="dateModified" content="2021-01-24T22:34:21-06:00">
    <meta itemprop="wordCount" content="426">
    <title>Input Polling :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/02-player-input/02-input-polling/" rel="canonical" type="text/html" title="Input Polling :: K-State CIS 580 Textbook">
    <link href="/cis580/02-player-input/02-input-polling/index.xml" rel="alternate" type="application/rss+xml" title="Input Polling :: K-State CIS 580 Textbook">
    <link href="/cis580/02-player-input/02-input-polling/index.print.html" rel="alternate" type="text/html" title="Input Polling :: K-State CIS 580 Textbook">
    <link href="/cis580/02-player-input/02-input-polling/embed.html" rel="alternate" type="text/html" title="Input Polling :: K-State CIS 580 Textbook">
    <link href="/cis580/css/fontawesome-all.min.css?1719519540" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/fontawesome-all.min.css?1719519540" rel="stylesheet"></noscript>
    <link href="/cis580/css/nucleus.css?1719519540" rel="stylesheet">
    <link href="/cis580/css/auto-complete.css?1719519540" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/auto-complete.css?1719519540" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar.min.css?1719519540" rel="stylesheet">
    <link href="/cis580/css/fonts.css?1719519540" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/fonts.css?1719519540" rel="stylesheet"></noscript>
    <link href="/cis580/css/theme.css?1719519540" rel="stylesheet">
    <link href="/cis580/css/theme-auto.css?1719519540" rel="stylesheet" id="R-variant-style">
    <link href="/cis580/css/chroma-auto.css?1719519540" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cis580/css/variant.css?1719519540" rel="stylesheet">
    <link href="/cis580/css/print.css?1719519540" rel="stylesheet" media="print">
    <script src="/cis580/js/variant.js?1719519540"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.index_js_url="/cis580/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cis580/css/custom.css?1719519540" rel="stylesheet">
  </head>
  <body class="mobile-support tele disableInlineCopyToClipboard" data-url="/cis580/02-player-input/02-input-polling/">
    
    <div id="tele" class="tele mirror">
    
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="input-polling">Input Polling</h1>

<p>Instead of letting the OS tell us when an input event occurs (as we do with event-driven programming), in the game loop we use <em>device polling</em> with the input devices.  This means that we <em>ask the device</em> for its current state when we start processing user input.</p>
<p>Consider a gamepad with a button, <strong>A</strong>.  We can represent such a button with a boolean value; <code>true</code> if it is pressed, and <code>false</code> if it is not.  Thus, the classic NES controller could be represented by a struct composed entirely of booleans:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">struct</span> <span class="nc">NESPad</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The D-Pad</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">bool</span> <span class="n">Up</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">bool</span> <span class="n">Down</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">bool</span> <span class="n">Left</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">bool</span> <span class="n">Right</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The Buttons</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">bool</span> <span class="n">A</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">bool</span> <span class="n">B</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">bool</span> <span class="n">Start</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">bool</span> <span class="n">Select</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>At the start of each iteration of the game loop, we could gather the current state and assign it to a copy of this struct, say <code>PlayerOneInput</code>.  We would then use it in the <code>Update()</code> method:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">Update</span><span class="p">(</span><span class="n">GameTime</span> <span class="n">gameTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">PlayerOneInput</span><span class="p">.</span><span class="n">Left</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">PlayerPosition</span><span class="p">.</span><span class="n">X</span> <span class="p">+=</span> <span class="n">Speed</span> <span class="p">*</span> <span class="n">gameTime</span><span class="p">.</span><span class="n">ElapsedGameTime</span><span class="p">.</span><span class="n">TotalSeconds</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>That works well for continuous actions like walking, but what about discrete ones like jumping?  Remember, your game is updating at 1/30th or 1/60th of a second.  No player is so fast that they only hold down a button for 1/60th of a second.  Instead, they&rsquo;ll hold it down for several frames, even when they meant to just tap it.  If our jump logic is something like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">PlayerOneInput</span><span class="p">.</span><span class="n">A</span><span class="p">)</span> <span class="n">Jump</span><span class="p">();</span></span></span></code></pre></div><p>We&rsquo;ll end up calling that <code>Jump()</code> method multiple frames in a row!</p>
<p>The solution is to keep <em>two</em> structs: one with the current frame&rsquo;s input, and one with the prior frames, i.e.:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="n">NESPad</span> <span class="n">currentPlayerOneInput</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">NESPad</span> <span class="n">priorPlayerOneInput</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">Update</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">currentPlayerOneInput</span><span class="p">.</span><span class="n">A</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">priorPlayerOneInput</span><span class="p">.</span><span class="n">A</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// The A button was just pressed this frame, so Jump!</span>
</span></span><span class="line"><span class="cl">        <span class="n">Jump</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>That wraps up <em>using</em> the input, but how about <em>getting it</em> in the first place?  That&rsquo;s what the <em>process input</em> stage in the game loop is about.  But you&rsquo;ve probably noticed that your MonoGame <code>Game</code> class doesn&rsquo;t have a corresponding method&hellip;</p>
<p>This is because XNA was built to handle four XBox 360 gamepads (as you would see on an XBox 360), as well as keyboard and mouse input <em>out of the box</em>.  And MonoGame added support for Joysticks and expanded the number and kind of gamepads that could be used.  The process input stage is there - we just don&rsquo;t need to see it.  Instead, we can grab the already-polled input data with one of the static input classes.  We&rsquo;ll take a look at each of these next.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>
</div>
</main>
</div>

</div>




<script src="/cis580/js/clipboard.min.js?1719519540" defer></script>
<script src="/cis580/js/perfect-scrollbar.min.js?1719519540" defer></script>
<script src="/cis580/js/theme.js?1719519540" defer></script>

<script src="/cis580/js/tele-scroll.js?1719519540" defer></script>

</body>
</html>
