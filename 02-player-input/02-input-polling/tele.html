<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="Instead of letting the OS tell us when an input event occurs (as we do with event-driven programming), in the game loop we use device polling with the input devices. This means that we ask the device for its current state when we start processing user input.
Consider a gamepad with a button, A. We can represent such a button with a boolean value; true if it is pressed, and false if it is not.">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="Input Polling :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="Instead of letting the OS tell us when an input event occurs (as we do with event-driven programming), in the game loop we use device polling with the input devices. This means that we ask the device for its current state when we start processing user input.
Consider a gamepad with a button, A. We can represent such a button with a boolean value; true if it is pressed, and false if it is not.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/02-player-input/02-input-polling/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Input Polling :: K-State CIS 580 Textbook">
    <meta property="og:description" content="Instead of letting the OS tell us when an input event occurs (as we do with event-driven programming), in the game loop we use device polling with the input devices. This means that we ask the device for its current state when we start processing user input.
Consider a gamepad with a button, A. We can represent such a button with a boolean value; true if it is pressed, and false if it is not.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Player Input">
    <meta property="article:published_time" content="2018-08-24T10:53:26-05:00">
    <meta property="article:modified_time" content="2021-01-24T22:34:21-06:00">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="Input Polling :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="Instead of letting the OS tell us when an input event occurs (as we do with event-driven programming), in the game loop we use device polling with the input devices. This means that we ask the device for its current state when we start processing user input.
Consider a gamepad with a button, A. We can represent such a button with a boolean value; true if it is pressed, and false if it is not.">
    <meta itemprop="datePublished" content="2018-08-24T10:53:26-05:00">
    <meta itemprop="dateModified" content="2021-01-24T22:34:21-06:00">
    <meta itemprop="wordCount" content="430">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>Input Polling :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/02-player-input/02-input-polling/index.html" rel="canonical" type="text/html" title="Input Polling :: K-State CIS 580 Textbook">
    <link href="/cis580/02-player-input/02-input-polling/index.xml" rel="alternate" type="application/rss+xml" title="Input Polling :: K-State CIS 580 Textbook">
    <link href="/cis580/02-player-input/02-input-polling/index.print.html" rel="alternate" type="text/html" title="Input Polling :: K-State CIS 580 Textbook">
    <link href="/cis580/02-player-input/02-input-polling/embed.html" rel="alternate" type="text/html" title="Input Polling :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1756153111" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1756153111" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1756153111" defer></script>
    <script src="/cis580/js/search.min.js?1756153111" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1756153111";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1756153111" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1756153111" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1756153111" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1756153111" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1756153111" rel="stylesheet">
    <link href="/cis580/css/format-html.min.css?1756153111" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/02-player-input\/02-input-polling\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1756153111" rel="stylesheet">
  </head>
  <body class="mobile-support html" data-url="/cis580/02-player-input/02-input-polling/index.html">
    
    <div id="tele" class="tele mirror">
    
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 02-player-input" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="input-polling">Input Polling</h1>

<p>Instead of letting the OS tell us when an input event occurs (as we do with event-driven programming), in the game loop we use <em>device polling</em> with the input devices.  This means that we <em>ask the device</em> for its current state when we start processing user input.</p>
<p>Consider a gamepad with a button, <strong>A</strong>.  We can represent such a button with a boolean value; <code>true</code> if it is pressed, and <code>false</code> if it is not.  Thus, the classic NES controller could be represented by a struct composed entirely of booleans:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NESPad</span> 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The D-Pad</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Up;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Down;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Left;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Right;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The Buttons</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> A;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> B;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Start;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Select;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>At the start of each iteration of the game loop, we could gather the current state and assign it to a copy of this struct, say <code>PlayerOneInput</code>.  We would then use it in the <code>Update()</code> method:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(PlayerOneInput.Left) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        PlayerPosition.X += Speed * gameTime.ElapsedGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>That works well for continuous actions like walking, but what about discrete ones like jumping?  Remember, your game is updating at 1/30th or 1/60th of a second.  No player is so fast that they only hold down a button for 1/60th of a second.  Instead, they&rsquo;ll hold it down for several frames, even when they meant to just tap it.  If our jump logic is something like:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(PlayerOneInput.A) Jump();</span></span></code></pre></div>
<p>We&rsquo;ll end up calling that <code>Jump()</code> method multiple frames in a row!</p>
<p>The solution is to keep <em>two</em> structs: one with the current frame&rsquo;s input, and one with the prior frames, i.e.:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>NESPad currentPlayerOneInput;
</span></span><span style="display:flex;"><span>NESPad priorPlayerOneInput;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(currentPlayerOneInput.A &amp;&amp; !priorPlayerOneInput.A) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The A button was just pressed this frame, so Jump!</span>
</span></span><span style="display:flex;"><span>        Jump();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>That wraps up <em>using</em> the input, but how about <em>getting it</em> in the first place?  That&rsquo;s what the <em>process input</em> stage in the game loop is about.  But you&rsquo;ve probably noticed that your MonoGame <code>Game</code> class doesn&rsquo;t have a corresponding method&hellip;</p>
<p>This is because XNA was built to handle four XBox 360 gamepads (as you would see on an XBox 360), as well as keyboard and mouse input <em>out of the box</em>.  And MonoGame added support for Joysticks and expanded the number and kind of gamepads that could be used.  The process input stage is there - we just don&rsquo;t need to see it.  Instead, we can grab the already-polled input data with one of the static input classes.  We&rsquo;ll take a look at each of these next.</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script src="/cis580/js/clipboard/clipboard.min.js?1756153111" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1756153111" defer></script>
    <script src="/cis580/js/theme.min.js?1756153111" defer></script>
      
      
      
    </div> 
  <script src="/cis580/js/tele-scroll.min.js?1756153111" defer></script>
  </body>
</html>
