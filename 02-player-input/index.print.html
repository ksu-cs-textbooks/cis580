<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="Need Input!">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="Player Input :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="Need Input!">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/02-player-input/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Player Input :: K-State CIS 580 Textbook">
    <meta property="og:description" content="Need Input!">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="Player Input :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="Need Input!">
    <meta itemprop="datePublished" content="2018-08-24T10:53:05-05:00">
    <meta itemprop="dateModified" content="2023-08-11T11:18:05-05:00">
    <meta itemprop="wordCount" content="2">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>Player Input :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/02-player-input/index.html" rel="canonical" type="text/html" title="Player Input :: K-State CIS 580 Textbook">
    <link href="/cis580/02-player-input/index.xml" rel="alternate" type="application/rss+xml" title="Player Input :: K-State CIS 580 Textbook">
    <link href="/cis580/02-player-input/tele.html" rel="alternate" type="text/html" title="Player Input :: K-State CIS 580 Textbook">
    <link href="/cis580/02-player-input/embed.html" rel="alternate" type="text/html" title="Player Input :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1755628803" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1755628803" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/search.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1755628803";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/format-print.min.css?1755628803" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/02-player-input\/index.html';
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1755628803" rel="stylesheet">
  </head>
  <body class="mobile-support print" data-url="/cis580/02-player-input/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper"> 
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class="a11y-only"><a itemprop="item" href="/cis580/index.html"><span itemprop="name">CIS 580: Foundations of Game Programming</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">Player Input</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/ksu-cs-textbooks/cis580/edit/master/content/02-player-input/_index.md" rel="external" target="_blank" title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/02-player-input/index.print.html" title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/01-intro-to-monogame/07-summary/index.html" title="Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/02-player-input/01-introduction/index.html" title="Introduction (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
            <div class="topbar-button topbar-button-embed" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/02-player-input/embed.html" title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a>
            </div>
            <div class="topbar-button topbar-button-tele" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/02-player-input/tele.html" title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a>
            </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 02-player-input" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="player-input">Player Input</h1>

<p>Need Input!
<a href="#R-image-4fb6ca4f49ef25fef5018a62aa693ef5" class="lightbox-link"><img alt="Need Input" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/need-input.gif" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4fb6ca4f49ef25fef5018a62aa693ef5"><img alt="Need Input" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/need-input.gif"></a></p>

  <footer class="footline">
  </footer>
</article>
          <section>
            <h1 class="a11y-only">Subsections of Player Input</h1>
<article class="default">
  <header class="headline">
  </header>

<h1 id="introduction">Introduction</h1>

<p>By this point you have probably built a lot of programs with user interfaces.  Most, or possibly all, were written in an event-driven fashion, i.e. you created a method to serve as an event handler, i.e.:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> OnButtonPress(<span style="color:#66d9ef">object</span> sender, EventArgs e)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Your logic here...</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>This approach is a good fit for most productivity desktop applications.  After all, most of the time your text editor is just waiting for you to do something interesting - like move the mouse or type a letter.  During this waiting period, it doesn&rsquo;t need to do anything else - what is on-screen isn&rsquo;t changing, what it has stored internally isn&rsquo;t changing.  It basically spends most of its time waiting.</p>
<p>Most games, on the other hand, are <em>never</em> waiting.  They are real-time simulations of a world.  The Goomba will keep walking, the Bullet Bill flying, and the Piranha Plant popping in and out of pipes whether or not Mario moves.  Hence the game loop - each update and render cycle updates the state of the game world, and then renders that updated world.</p>
<p>While event-driven programming is extremely efficient in a desktop application that waits on user input most of the time, it is problematic in a real-time game.  Hence, the <em>process input</em> stage in the game loop from Game Programming Patterns:</p>
<p><a href="#R-image-bef5090f6cccda789b424b502c032ca0" class="lightbox-link"><img alt="The Game Loop" class="border lazy lightbox figure-image" loading="lazy" src="https://gameprogrammingpatterns.com/images/game-loop-simple.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-bef5090f6cccda789b424b502c032ca0"><img alt="The Game Loop" class="border lazy lightbox lightbox-image" loading="lazy" src="https://gameprogrammingpatterns.com/images/game-loop-simple.png"></a></p>
<p>But what exactly does that step entail?  Let&rsquo;s find out.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="input-polling">Input Polling</h1>

<p>Instead of letting the OS tell us when an input event occurs (as we do with event-driven programming), in the game loop we use <em>device polling</em> with the input devices.  This means that we <em>ask the device</em> for its current state when we start processing user input.</p>
<p>Consider a gamepad with a button, <strong>A</strong>.  We can represent such a button with a boolean value; <code>true</code> if it is pressed, and <code>false</code> if it is not.  Thus, the classic NES controller could be represented by a struct composed entirely of booleans:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">NESPad</span> 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The D-Pad</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Up;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Down;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Left;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Right;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The Buttons</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> A;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> B;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Start;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Select;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>At the start of each iteration of the game loop, we could gather the current state and assign it to a copy of this struct, say <code>PlayerOneInput</code>.  We would then use it in the <code>Update()</code> method:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(PlayerOneInput.Left) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        PlayerPosition.X += Speed * gameTime.ElapsedGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>That works well for continuous actions like walking, but what about discrete ones like jumping?  Remember, your game is updating at 1/30th or 1/60th of a second.  No player is so fast that they only hold down a button for 1/60th of a second.  Instead, they&rsquo;ll hold it down for several frames, even when they meant to just tap it.  If our jump logic is something like:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(PlayerOneInput.A) Jump();</span></span></code></pre></div>
<p>We&rsquo;ll end up calling that <code>Jump()</code> method multiple frames in a row!</p>
<p>The solution is to keep <em>two</em> structs: one with the current frame&rsquo;s input, and one with the prior frames, i.e.:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>NESPad currentPlayerOneInput;
</span></span><span style="display:flex;"><span>NESPad priorPlayerOneInput;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(currentPlayerOneInput.A &amp;&amp; !priorPlayerOneInput.A) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The A button was just pressed this frame, so Jump!</span>
</span></span><span style="display:flex;"><span>        Jump();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>That wraps up <em>using</em> the input, but how about <em>getting it</em> in the first place?  That&rsquo;s what the <em>process input</em> stage in the game loop is about.  But you&rsquo;ve probably noticed that your MonoGame <code>Game</code> class doesn&rsquo;t have a corresponding method&hellip;</p>
<p>This is because XNA was built to handle four XBox 360 gamepads (as you would see on an XBox 360), as well as keyboard and mouse input <em>out of the box</em>.  And MonoGame added support for Joysticks and expanded the number and kind of gamepads that could be used.  The process input stage is there - we just don&rsquo;t need to see it.  Instead, we can grab the already-polled input data with one of the static input classes.  We&rsquo;ll take a look at each of these next.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="keyboard-input">Keyboard Input</h1>

<p>Let&rsquo;s start with the keyboard.  MonoGame uses the <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.KeyboardState.html" rel="external" target="_blank"><code>KeyboardState</code></a> struct to represent the state of a keyboard.  It is essentially a wrapper around an array of bits - one for each key in a standard keyboard.  The indices of each key are represented by the <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.Keys.html" rel="external" target="_blank"><code>Keys</code></a> enumeration (you can find a complete listing <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.Keys.html" rel="external" target="_blank">in the docs</a>).</p>
<p>We get the current state of the keyboard with the static <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.Keyboard.html" rel="external" target="_blank"><code>Keyboard</code></a>&rsquo;s <code>GetState()</code> method, which returns the aforementioned <code>KeyboardState</code> struct.  Thus, if we wanted to have current and prior keyboard states, we&rsquo;d add fields to hold them:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> KeyboardState priorKeyboardState;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> KeyboardState currentKeyboardState;</span></span></code></pre></div>
<p>And within our <code>Update(GameTime gameTime)</code> method, we&rsquo;d first copy the current (but now old) state to the prior variable, and then grab the updated state for the current variable:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    priorKeyboardState = currentKeyboardState;
</span></span><span style="display:flex;"><span>    currentKeyboardState = Keyboard.GetState();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Your update logic goes here...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">base</span>.Update(gameTime);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>The <code>KeyboardState</code> struct contains properties:</p>
<ul>
<li><code>Keys</code> - an array of 256 bits, with each bit corresponding to a particular key</li>
<li><code>CapsLock</code> - a boolean indicating if the caps lock is on</li>
<li><code>NumLock</code> - a boolean indicating if the num lock is on</li>
</ul>
<p>But more often, we&rsquo;ll use its method <code>IsKeyDown(Keys key)</code> or <code>IsKeyUp(Keys key)</code>, both of which take a <code>Keys</code> value.  For example, we can check if the escape key is pressed with:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(currentKeyboardState.IsKeyDown(Keys.Escape))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Escape key is down</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>And, if we need to determine if a key was <em>just pressed this frame</em>, we would use:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(currentKeyboardState.IsKeyDown(Keys.I) &amp;&amp;
</span></span><span style="display:flex;"><span>         priorKeyboardState.IsKeyUp(Keys.I))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The I key was just pressed this frame</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>Similarly, to see if a key was <em>just released this frame</em>, we would reverse the current and previous conditions:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(currentKeyboardState.IsKeyUp(Keys.I) &amp;&amp;
</span></span><span style="display:flex;"><span>        priorKeyboardSate.IsKeyDown(Keys.I))
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// The I key was just released this frame</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>Note that part of the reason we use a <code>struct</code> instead of a <code>Class</code> for our state is that a <code>struct</code> is a <em>value</em> type, i.e. it allocates <em>exactly</em> the space need to store its data, and when we set it equal to a different struct instance, i.e.:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    priorKeyboardState = currentKeyboardState;</span></span></code></pre></div>
<p>What actually happens is we copy the bits from <code>currentKeyboardState</code> over the top of <code>priorKeyboardState</code>.  This is both a fast operation and it allocates no additional memory - ideal for the needs of a game.  This is also why so many of MonoGame&rsquo;s data types are structs instead of classes.</p>
  </div>
</details>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="mouse-input">Mouse Input</h1>

<p>Mouse input works much like keyboard input - we have a <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.MouseState.html" rel="external" target="_blank"><code>MouseState</code></a> struct that represents the state of the mouse, and we can get the current state from the static <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.Mouse.html" rel="external" target="_blank"><code>Mouse</code></a> class&rsquo;s <code>GetState()</code> method.  You&rsquo;ll also want to use the same caching strategy of a current and prior state if you want to know when a button goes down or comes up, i.e.:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    MouseState currentMouseState;
</span></span><span style="display:flex;"><span>    MouseState priorMouseState;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        priorMouseState = currentMouseState;
</span></span><span style="display:flex;"><span>        currentMouseState = Mouse.GetState();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// TODO: Add your update logic here </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">base</span>.Update(gameTime);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>However, the <code>MouseState</code> struct has a different set of properties:</p>
<ul>
<li><code>X</code> - the horizontal position of the mouse as an integer in relation to the window.</li>
<li><code>Y</code> - the vertical position of the mouse as an integer in relation to the window.</li>
<li><code>LeftButton</code> - a <code>ButtonState</code> indicating if the left button is down</li>
<li><code>MiddleButton</code> - a <code>ButtonState</code> indicating if the middle button is down</li>
<li><code>RightButton</code> - a <code>ButtonState</code> indicating if the right button is down</li>
<li><code>ScrollWheelValue</code> - an integer representing the cumulative scroll wheel value since the start of the game</li>
<li><code>HorizontalScrollWheelValue</code> - an integer representing the cumulative scroll wheel value since the start of the game</li>
<li><code>XButton1</code> - a <code>ButtonState</code> indicating if the XButton1 button is down</li>
<li><code>XButton2</code> - a <code>ButtonState</code> indicating if the XButton2  is down</li>
</ul>
<p>Note that instead of <code>booleans</code>, buttons are represented by the <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.ButtonState.html" rel="external" target="_blank"><code>ButtonState</code></a> enumeration.  This allows the internal representation of the <code>MouseState</code> buttons to be a single bitmask, making copy operations on the <code>MouseState</code> much faster (and the struct itself to take up less space).</p>
<p>Thus, to check if the <code>LeftButton</code> is down, we&rsquo;d need to use:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(currentMouseState.LeftButton == ButtonState.Pressed) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// left mouse button is pressed.</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>Note that not all mice have all of these possible inputs - the Horizontal scroll wheel and X buttons, especially, but many mice also lack the middle button and scroll wheel.  In those cases these values will be <code>ButtonState.Released</code> or <code>false</code>.</p>
  </div>
</details>
<h2 id="the-mouse-cursor">The Mouse Cursor</h2>
<p>You can set what cursor the mouse should use with the <code>Mouse.SetCursor(MouseCursor cursor)</code>, and supply the cursor of your choice, i.e. <code>MouseCursor.Crosshair</code>.  A full list of cursors can be found <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.MouseCursor.html#properties" rel="external" target="_blank">in the documentation</a>.</p>
<p>You can also create a cursor from a texture with <code>MouseCursor.FromTexture2D(Texture2D texture, int originX, int originY)</code>.  The <code>Texture2D</code> is loaded with a <code>ContentManager</code>, just as we did in our <em>HelloGame</em> example.  The <code>originX</code> and <code>originY</code> describe where the mouse pointer is <em>in relation to the upper-left-hand corner of the image</em>.</p>
<p>You can also hide the mouse cursor by setting the <code>Game.IsMouseVisible</code> property to <code>false</code>.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="gamepad-input">Gamepad Input</h1>

<p>MonoGame handles gamepad input in a similar fashion to Keyboard and Mouse input.  For example, there is a static <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.GamePad.html" rel="external" target="_blank"><code>GamePad</code></a> class and a <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.GamePadState.html" rel="external" target="_blank"><code>GamePadState</code></a> struct.</p>
<h2 id="player-indices">Player Indices</h2>
<p>However, XNA was originally designed to work with the XBox 360, which supported up to four players connected through XBox 360 gamepads. Thus, instead of using <code>GamePad.GetState()</code> we would use <code>GamePad.GetState(PlayerIndex playerIndex)</code>, where the <code>PlayerIndex</code> enumeration value corresponded to which player&rsquo;s gamepad we wanted to poll.</p>
<p>However, MonoGame can (in theory) support more than four gamepads, so it also added a <code>GamePad.GetState(int index)</code>.  You can find out how many gamepads are supported on your system with the property <code>GamePad.MaxiumumGamePadCount</code>.</p>
<p>Thus, to get the first gamepad&rsquo;s state, we would:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    GamePadState currentGamePadState;
</span></span><span style="display:flex;"><span>    GamePadState priorGamePadState;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        priorGamePadState = currentGamePadState;
</span></span><span style="display:flex;"><span>        currentGamePadState = GamePad.GetState(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// TODO: Add your update logic here </span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">base</span>.Update(gameTime);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h2 id="gamepad-capabilities-and-types">GamePad Capabilities and Types</h2>
<p>Also, the XBox controller had a standardized number of buttons and triggers, but MonoGame supports a wider variety of gamepads.  You can check the capabilities of any connected pad with <code>GamePad.GetCapabilities(int index)</code>, which returns a <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.GamePadCapabilities.html" rel="external" target="_blank"><code>GamePadCapabilities</code></a> struct, i.e.:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>GamePadCapabilities capabilities = GamePad.GetCapabilities(<span style="color:#ae81ff">1</span>);</span></span></code></pre></div>
<p>The <code>GamePadType</code> property is one of the <code>GamePadType</code> enumeration values, which include options like the various Rock band/Guitar hero instruments, dance pads, arcade sticks, flight sticks, and wheels.  Note that each of these types still provide their input through standard button and axis properties.</p>
<p>The various other properties of the <code>GamePadCapabilities</code> are booleans corresponding to different types of buttons pads, and sticks.  You can see them all listed <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.GamePadCapabilities.html#properties" rel="external" target="_blank">in the documentation</a>.</p>
<h2 id="gamepadstate">GamePadState</h2>
<p>The <code>GamePadState</code> is actually implemented as a partial struct, so additional data can be added based on the platform.  The various buttons, pads, and sticks are broken out into individual sub-structs.</p>
<h4 id="buttons">Buttons</h4>
<p>For example, the <code>GamePadState.Buttons</code> property is a <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.GamePadButtons.html" rel="external" target="_blank"><code>GamePadButtons</code></a> struct representing the traditional buttons (those that are either pressed or not - A, B, X, Y, Start, Back, Big Button, Left Shoulder, Right Shoulder, Left Stick, Right Stick).  As with the mouse buttons we saw before, these are represented using the <code>ButtonState</code> enum.  Thus, to determine if the A button is pressed, we would use:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(currentGamePadState.Buttons.A == ButtonState.Pressed)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// A button is pressed</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>And to determine if the X button was _just pressed this frame:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(currentGamePadState.Buttons.X == ButtonState.Pressed 
</span></span><span style="display:flex;"><span>    &amp;&amp; priorGamePadState.Buttons.X == ButtonState.Released)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// X button was just pressed this frame</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h4 id="dpad">DPad</h4>
<p>The <code>GamePadState.DPad</code> property is a <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.GamePadButtons.html" rel="external" target="_blank"><code>GamePadDPad</code></a> struct, also composed of <code>ButtonValues</code> for the four directions of the DPad (Up, Down, Left, Right).  I.e. to check if the right direction pad button is pressed:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(currentGamePadState.DPad.Right == ButtonState.Pressed)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Right Dpad button is pressed</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h4 id="triggers">Triggers</h4>
<p>The <code>GamePadState.Triggers</code> property is a <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.GamePadTriggers.html" rel="external" target="_blank"><code>GamePadTriggers</code></a> struct representing the two triggers (Left and Right).  Unlike other buttons, these measure the <em>travel</em>, or the amount of pull that has been applied to them.  Thus, they are represented by a <code>single</code> floating point number between 0 and 1.</p>
<p>To see if the left trigger is pulled back 3/4 of the way, we might use:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(currentGameState.Triggers.Left &gt; <span style="color:#ae81ff">0.75</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Left Trigger is pulled at least 3/4 of the way back</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<h4 id="thumbsticks">ThumbSticks</h4>
<p>The <code>GamePadState.Thumbsticks</code> property is a <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Input.GamePadThumbSticks.html" rel="external" target="_blank"><code>GamePadThumbSticks</code></a> struct representing the two thumbsticks (Left and Right).  These are represented by <code>Vector2</code> values with the <code>X</code> and <code>Y</code> falling between -1 and 1.</p>
<p>Thus, to get where the right thumbstick is pointing, we might use:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    Vector2 direction = GamePad.Thumbsticks.Right;</span></span></code></pre></div>
<h4 id="isbuttondownisbuttonup">IsButtonDown/IsButtonUp</h4>
<p>The <code>GamePadState</code> also implements convenience functions <code>IsButtonUp(Button button)</code> and <code>IsButtonDown(Button button)</code> that operate like the keyboards&rsquo; equivalents.</p>
<h2 id="vibration">Vibration</h2>
<p>Many gamepads come equipped with two vibration-inducing motors (left and right).  These are exposed through the <code>GamePad.SetVibration(int index, single left, single right)</code> method, where you can set a vibration in either motor using a floating point value between 0 and 1.</p>
<p>Thus, to start vibration in both of player one&rsquo;s gamepad&rsquo;s motors at half-strength, you would use:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>GamePad.SetVibration(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0.5f</span>. <span style="color:#ae81ff">0.5f</span>);</span></span></code></pre></div>
<p>To stop them you would need to send:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>GamePad.SetVibration(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>);</span></span></code></pre></div>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="input-manager">Input Manager</h1>

<p>At this point, you may be noticing that our input processing could quickly dominate our <code>Game</code> class, and can be very messy.  Especially if we want to support multiple forms of input in the same game.  Consider if we wanted to do a platformer - we might want the player to be able to use the keyboard <em>or</em> a gamepad.</p>
<p>One technique we can employ is an <em>input manager</em>, a class that handles polling the input and abstracts it to just the commands we care about.  I.e. for a simple platformer, we might want the four directions and &ldquo;jump&rdquo;.</p>
<p>We can create a class called <em>InputManager</em> that would provide those:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Microsoft.Xna.Framework;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Microsoft.Xna.Framework.Input;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Manages input for a simple platformer</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InputManager</span> 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The player&#39;s direction</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Vector2 Direction { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// If the player pressed jump this frame </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> Jump { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Note that we use <code>public</code> auto-properties, but override the <code>set</code> to be <code>private</code>.  This way outside code can access these boolean properties, but only the code in this class can set them.</p>
<p>We&rsquo;ll also need to declare our state variables:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// Input state variables</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> KeyboardState currentKeyboardState;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> KeyboardState priorKeyboardState;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> GamePadState currentGamePadState;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> GamePadState priorGamePadState;</span></span></code></pre></div>
<p>And, we&rsquo;ll process these in an update method:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Update the input object</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;gameTime&#34;&gt;The game time&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Update input state</span>
</span></span><span style="display:flex;"><span>        priorKeyboardState = currentKeyboardState;
</span></span><span style="display:flex;"><span>        currentKeyboardState = Keyboard.GetState();
</span></span><span style="display:flex;"><span>        priorGamePadState = currentGamePadState;
</span></span><span style="display:flex;"><span>        currentGamePadState = GamePad.GetState(<span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// TODO: Assign actions based on input</span>
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>This looks just like how we updated state before.  The next step is to abstract the input <em>into</em> the properties we defined.  We&rsquo;ll start with the <code>Direction</code>, which we are using a <code>Vector2</code> to represent.  This conveniently matches with our gamepad&rsquo;s thumbstick representation, so we can assign it directly:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Right thumbstick</span>
</span></span><span style="display:flex;"><span>    Direction = currentGamePadState.Thumbsticks.Right;</span></span></code></pre></div>
<p>If there is no gamepad available, this will be the vector <span class="math align-center">$ (0,0) $</span>.  Then we can check the WASD keys, and assign a corresponding value</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// WASD keys:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (currentKeyboardState.IsKeyDown(Keys.W)) Direction += <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">0</span>,-<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (currentKeyboardState.IsKeyDown(Keys.A)) Direction += <span style="color:#66d9ef">new</span> Vector2(-<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (currentKeyboardState.IsKeyDown(Keys.S)) Direction += <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (currentKeyboardState.IsKeyDown(Keys.D)) Direction += <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>);</span></span></code></pre></div>
<p>Note that we are adding a unit vector to the (supposedly zero) existing vector.  This does mean that a player using <em>both</em> keyboard and mouse could double the direction vector length, so if this is important in your game you&rsquo;ll need additional logic to prevent it.</p>
<p>For the <em>jump</em>, we want that to be a discrete push, i.e. it is only <code>true</code> the frame the button is pushed.  So we&rsquo;ll first need to reset it to false (in case it was true in a prior frame):</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// reset jump</span>
</span></span><span style="display:flex;"><span>    Jump = <span style="color:#66d9ef">false</span>;</span></span></code></pre></div>
<p>Now we can check if the &ldquo;A&rdquo; button is pressed:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(currentGamePadState.IsButtonDown(Buttons.A) &amp;&amp;  priorGamePadState.IsButtonUp(Buttons.A))
</span></span><span style="display:flex;"><span>        Jump = <span style="color:#66d9ef">true</span>;</span></span></code></pre></div>
<p>Similarly, we can check for the spacebar:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(currentKeyboardState.IsKeyDown(Keys.Space) &amp;&amp; priorKeyboardState.IsKeyUp(Keys.Space))
</span></span><span style="display:flex;"><span>        Jump = <span style="color:#66d9ef">true</span>;</span></span></code></pre></div>
<p>Now, we just need to construct an instance of <code>InputManager</code> in our game, invoke its <code>Update()</code> at the start of our game class&rsquo; <code>Update()</code> method, and then we can use the <code>Direction</code> and <code>Jump</code> properties to determine what should happen in our game.</p>
<p>This idea can be adapted to any game you want to make - but it will always be specific to the game, as what the controls need to do will vary from game to game.  It also makes it easier to allow for multiple forms of input, and to also do user-controlled <em>input mapping</em>, where users can reassign keys/buttons to corresponding actions.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="input-state">Input State</h1>

<p>The <a href="https://github.com/tomizechsterson/game-state-management-monogame" rel="external" target="_blank">Game State Management Sample</a> provides a contrasting approach to the input manager.  Instead of being tailored to a specific game, it seeks to provide generic access to all input information.  It also handles multiplayer input, and can be used to manage when a player switches gamepads.  A simplified form (which does not handle gestural input) is provided below.</p>
<p>In particular, the <code>IsButtonPressed(Buttons button, PlayerIndex? controllingPlayer, out PlayerIndex playerIndex)</code> can check for a key press on any connected keyboard, or identify what player&rsquo;s keyboard was the source of the input.  And the <code>IsNewButtonPress(Buttons button, PlayerIndex? controllingPlayer, out PlayerIndex playerIndex)</code> is handled the same way, but detects <em>new</em> button presses.</p>
<p>There are also equivalents for keyboard input.</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// Helper for reading input from keyboard, gamepad, and touch input. This class </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// tracks both the current and previous state of the input devices, and implements </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// query methods for high level input actions such as &#34;move up through the menu&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// or &#34;pause the game&#34;.</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InputState</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MaxInputs = <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">readonly</span> KeyboardState[] CurrentKeyboardStates;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">readonly</span> GamePadState[] CurrentGamePadStates;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> KeyboardState[] _lastKeyboardStates;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> GamePadState[] _lastGamePadStates;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">readonly</span> <span style="color:#66d9ef">bool</span>[] GamePadWasConnected;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> InputState()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        CurrentKeyboardStates = <span style="color:#66d9ef">new</span> KeyboardState[MaxInputs];
</span></span><span style="display:flex;"><span>        CurrentGamePadStates = <span style="color:#66d9ef">new</span> GamePadState[MaxInputs];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        _lastKeyboardStates = <span style="color:#66d9ef">new</span> KeyboardState[MaxInputs];
</span></span><span style="display:flex;"><span>        _lastGamePadStates = <span style="color:#66d9ef">new</span> GamePadState[MaxInputs];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        GamePadWasConnected = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[MaxInputs];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Reads the latest user input state.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; MaxInputs; i++)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            _lastKeyboardStates[i] = CurrentKeyboardStates[i];
</span></span><span style="display:flex;"><span>            _lastGamePadStates[i] = CurrentGamePadStates[i];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            CurrentKeyboardStates[i] = Keyboard.GetState();
</span></span><span style="display:flex;"><span>            CurrentGamePadStates[i] = GamePad.GetState((PlayerIndex)i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Keep track of whether a gamepad has ever been</span>
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// connected, so we can detect if it is unplugged.</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (CurrentGamePadStates[i].IsConnected)
</span></span><span style="display:flex;"><span>                GamePadWasConnected[i] = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Helper for checking if a key was pressed during this update. The</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// controllingPlayer parameter specifies which player to read input for.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If this is null, it will accept input from any player. When a keypress</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// is detected, the output playerIndex reports which player pressed it.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsKeyPressed(Keys key, PlayerIndex? controllingPlayer, <span style="color:#66d9ef">out</span> PlayerIndex playerIndex)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (controllingPlayer.HasValue)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Read input from the specified player.</span>
</span></span><span style="display:flex;"><span>            playerIndex = controllingPlayer.Value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> i = (<span style="color:#66d9ef">int</span>)playerIndex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> CurrentKeyboardStates[i].IsKeyDown(key);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Accept input from any player.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> IsKeyPressed(key, PlayerIndex.One, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsKeyPressed(key, PlayerIndex.Two, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsKeyPressed(key, PlayerIndex.Three, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsKeyPressed(key, PlayerIndex.Four, <span style="color:#66d9ef">out</span> playerIndex);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Helper for checking if a button was pressed during this update.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The controllingPlayer parameter specifies which player to read input for.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If this is null, it will accept input from any player. When a button press</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// is detected, the output playerIndex reports which player pressed it.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsButtonPressed(Buttons button, PlayerIndex? controllingPlayer, <span style="color:#66d9ef">out</span> PlayerIndex playerIndex)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (controllingPlayer.HasValue)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Read input from the specified player.</span>
</span></span><span style="display:flex;"><span>            playerIndex = controllingPlayer.Value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> i = (<span style="color:#66d9ef">int</span>)playerIndex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> CurrentGamePadStates[i].IsButtonDown(button);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Accept input from any player.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> IsButtonPressed(button, PlayerIndex.One, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsButtonPressed(button, PlayerIndex.Two, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsButtonPressed(button, PlayerIndex.Three, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsButtonPressed(button, PlayerIndex.Four, <span style="color:#66d9ef">out</span> playerIndex);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Helper for checking if a key was newly pressed during this update. The</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// controllingPlayer parameter specifies which player to read input for.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If this is null, it will accept input from any player. When a keypress</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// is detected, the output playerIndex reports which player pressed it.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsNewKeyPress(Keys key, PlayerIndex? controllingPlayer, <span style="color:#66d9ef">out</span> PlayerIndex playerIndex)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (controllingPlayer.HasValue)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Read input from the specified player.</span>
</span></span><span style="display:flex;"><span>            playerIndex = controllingPlayer.Value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> i = (<span style="color:#66d9ef">int</span>)playerIndex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (CurrentKeyboardStates[i].IsKeyDown(key) &amp;&amp;
</span></span><span style="display:flex;"><span>                    _lastKeyboardStates[i].IsKeyUp(key));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Accept input from any player.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> IsNewKeyPress(key, PlayerIndex.One, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsNewKeyPress(key, PlayerIndex.Two, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsNewKeyPress(key, PlayerIndex.Three, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsNewKeyPress(key, PlayerIndex.Four, <span style="color:#66d9ef">out</span> playerIndex);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Helper for checking if a button was newly pressed during this update.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The controllingPlayer parameter specifies which player to read input for.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// If this is null, it will accept input from any player. When a button press</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// is detected, the output playerIndex reports which player pressed it.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsNewButtonPress(Buttons button, PlayerIndex? controllingPlayer, <span style="color:#66d9ef">out</span> PlayerIndex playerIndex)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (controllingPlayer.HasValue)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Read input from the specified player.</span>
</span></span><span style="display:flex;"><span>            playerIndex = controllingPlayer.Value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> i = (<span style="color:#66d9ef">int</span>)playerIndex;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> CurrentGamePadStates[i].IsButtonDown(button) &amp;&amp;
</span></span><span style="display:flex;"><span>                    _lastGamePadStates[i].IsButtonUp(button);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Accept input from any player.</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> IsNewButtonPress(button, PlayerIndex.One, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsNewButtonPress(button, PlayerIndex.Two, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsNewButtonPress(button, PlayerIndex.Three, <span style="color:#66d9ef">out</span> playerIndex) ||
</span></span><span style="display:flex;"><span>                IsNewButtonPress(button, PlayerIndex.Four, <span style="color:#66d9ef">out</span> playerIndex);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="summary">Summary</h1>

<p>In this chapter we learned about <em>input polling</em> and how it is implemented in XNA using structures representing input state and static <code>GetState()</code> methods.  We saw the three primary forms of input we use in the MonoGame framework - the keyboard, the mouse, and the gamepad.</p>
<p>We also saw how a variety of game controllers (i.e. RockBand gear, steering wheels, flight sticks, etc.) are mapped to the standard gamepad; how its state struct is actually composed of several sub-structs; and how to turn on and off the vibration motors.</p>
<p>Finally, we discussed how we can use two copies of a state struct - one from the prior frame and one from the current frame - to determine if a button was just pressed or released.</p>

  <footer class="footline">
  </footer>
</article>
          </section>
        </div>
      </main>
<div class="git-footer">
  <p class="theme-version-footer">8.0.0</p>
<p>Last modified by:
              <i class='fa-fw fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cis580/commit/43f194969a638fa4572819da4b31060ad574a9ce">Aug 11, 2023</a>
</p>

</div>
    </div>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cis580/js/mathjax/tex-mml-chtml.js?1755628803"></script>
    <script src="/cis580/js/clipboard/clipboard.min.js?1755628803" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1755628803" defer></script>
    <script src="/cis580/js/theme.min.js?1755628803" defer></script>
  </body>
</html>
