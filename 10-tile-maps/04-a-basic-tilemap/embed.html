<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="Now that we have a good sense of what a tile map consists of, as well as how to effectively use a 1-dimensional array as a 2-dimensional array, let’s discuss actual implementations. As we discussed conceptually, we need: 1) a set of tiles, and 2) the arrangement of those tiles into a map.
Let’s start by thinking about our tiles. To draw a tile, we need to know:
What texture the tile appears in The bounds of the tile in that texture Where the tile should appear on screen To determine this information, we need several other items:">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="A Basic Tile Engine :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="Now that we have a good sense of what a tile map consists of, as well as how to effectively use a 1-dimensional array as a 2-dimensional array, let’s discuss actual implementations. As we discussed conceptually, we need: 1) a set of tiles, and 2) the arrangement of those tiles into a map.
Let’s start by thinking about our tiles. To draw a tile, we need to know:
What texture the tile appears in The bounds of the tile in that texture Where the tile should appear on screen To determine this information, we need several other items:">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/10-tile-maps/04-a-basic-tilemap/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="A Basic Tile Engine :: K-State CIS 580 Textbook">
    <meta property="og:description" content="Now that we have a good sense of what a tile map consists of, as well as how to effectively use a 1-dimensional array as a 2-dimensional array, let’s discuss actual implementations. As we discussed conceptually, we need: 1) a set of tiles, and 2) the arrangement of those tiles into a map.
Let’s start by thinking about our tiles. To draw a tile, we need to know:
What texture the tile appears in The bounds of the tile in that texture Where the tile should appear on screen To determine this information, we need several other items:">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Tile Maps">
    <meta property="article:published_time" content="2020-03-20T10:53:05-05:00">
    <meta property="article:modified_time" content="2022-03-03T14:59:28-06:00">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="A Basic Tile Engine :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="Now that we have a good sense of what a tile map consists of, as well as how to effectively use a 1-dimensional array as a 2-dimensional array, let’s discuss actual implementations. As we discussed conceptually, we need: 1) a set of tiles, and 2) the arrangement of those tiles into a map.
Let’s start by thinking about our tiles. To draw a tile, we need to know:
What texture the tile appears in The bounds of the tile in that texture Where the tile should appear on screen To determine this information, we need several other items:">
    <meta itemprop="datePublished" content="2020-03-20T10:53:05-05:00">
    <meta itemprop="dateModified" content="2022-03-03T14:59:28-06:00">
    <meta itemprop="wordCount" content="790">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>A Basic Tile Engine :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/10-tile-maps/04-a-basic-tilemap/index.html" rel="canonical" type="text/html" title="A Basic Tile Engine :: K-State CIS 580 Textbook">
    <link href="/cis580/10-tile-maps/04-a-basic-tilemap/index.xml" rel="alternate" type="application/rss+xml" title="A Basic Tile Engine :: K-State CIS 580 Textbook">
    <link href="/cis580/10-tile-maps/04-a-basic-tilemap/index.print.html" rel="alternate" type="text/html" title="A Basic Tile Engine :: K-State CIS 580 Textbook">
    <link href="/cis580/10-tile-maps/04-a-basic-tilemap/tele.html" rel="alternate" type="text/html" title="A Basic Tile Engine :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1756153111" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1756153111" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1756153111" defer></script>
    <script src="/cis580/js/search.min.js?1756153111" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1756153111";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1756153111" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1756153111" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1756153111" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1756153111" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1756153111" rel="stylesheet">
    <link href="/cis580/css/format-html.min.css?1756153111" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/10-tile-maps\/04-a-basic-tilemap\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1756153111" rel="stylesheet">
  </head>
  <body class="mobile-support embed html" data-url="/cis580/10-tile-maps/04-a-basic-tilemap/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 10-tile-maps" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="a-basic-tile-engine">A Basic Tile Engine</h1>

<p>Now that we have a good sense of what a tile map consists of, as well as how to effectively use a 1-dimensional array as a 2-dimensional array, let&rsquo;s discuss actual implementations. As we discussed conceptually, we need: 1) a set of tiles, and 2) the arrangement of those tiles into a map.</p>
<p>Let&rsquo;s start by thinking about our tiles.  To draw a tile, we need to know:</p>
<ol>
<li>What texture the tile appears in</li>
<li>The bounds of the tile in that texture</li>
<li>Where the tile should appear on screen</li>
</ol>
<p>To determine this information, we need several other items:</p>
<ul>
<li>The width of the map in tiles</li>
<li>The height of the map in tiles</li>
<li>The width of a tile in pixels</li>
<li>The height of a tile in pixels</li>
</ul>
<p>And we can simplify the problem with some assumptions:</p>
<ul>
<li>Tiles are all the same size</li>
<li>The tileset image has the tiles organized side-by-side in a grid pattern</li>
</ul>
<h4 id="representing-the-map">Representing the Map</h4>
<p>Given this understanding, we can determine some fields we&rsquo;ll need to keep track of the data:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;The map filename&lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">string</span> _mapFilename;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;The tileset texture&lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Texture2D _tilesetTexture;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;The map and tile dimensions&lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> _tileWidth, _tileHeight, _mapWidth, _mapHeight;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;The tileset data&lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Rectangle[] _tiles;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;The map data&lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span>[] _map;</span></span></code></pre></div>
<h4 id="loading-the-data">Loading the Data</h4>
<p>Now let&rsquo;s turn our attention to how we can <em>populate</em> those fields. Let&rsquo;s first consider how we might write the data for a tilemap in a text file:</p>
<div class="highlight" dir="auto"><pre tabindex="0"><code>tileset
64, 64
10, 10
3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 2, 2, 2, 2, 2, 2, 3, 3, 2, 4, 4, 1, 4, 2, 2, 2, 3, 3, 2, 2, 2, 2, 4, 4, 4, 2, 3, 3, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3, 1, 3, 2, 2, 2, 4, 4, 3, 3, 2, 2, 3, 2, 3, 2, 2, 4, 4, 3, 2, 2, 3, 2, 3, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3</code></pre></div>
<p>In this example, the first line is the name of the tileset image file (which is loaded through the content pipeline, so it has no extension).  The second line is the width and height of a tile, and the third line is the width and height of the map (measured in tiles).  The last line is the indices of the tiles from the tileset image.</p>
<p>Loading the data from this file requires a method like this:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> LoadContent(ContentManager content)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Read in the map file</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">string</span> data = File.ReadAllText(Path.Join(content.RootDirectory, _mapFilename));
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> lines = data.Split(<span style="color:#e6db74">&#39;\n&#39;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// First line is tileset image file name </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> tilesetFileName = lines[<span style="color:#ae81ff">0</span>].Trim();
</span></span><span style="display:flex;"><span>    _tilesetTexture = content.Load&lt;Texture2D&gt;(tilesetFileName);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Second line is tile size</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> secondLine = lines[<span style="color:#ae81ff">1</span>].Split(<span style="color:#e6db74">&#39;,&#39;</span>);
</span></span><span style="display:flex;"><span>    _tileWidth = <span style="color:#66d9ef">int</span>.Parse(secondLine[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    _tileHeight = <span style="color:#66d9ef">int</span>.Parse(secondLine[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Now that we know the tile size and tileset</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// image, we can determine tile bounds</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tilesetColumns = _tilesetTexture.Width / _tileWidth;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> tilesetRows = _tilesetTexture.Height / _tileWidth;
</span></span><span style="display:flex;"><span>    _tiles = <span style="color:#66d9ef">new</span> Rectangle[tilesetColumns * tilesetRows];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> y = <span style="color:#ae81ff">0</span>; y &lt; tilesetRows; y++)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x = <span style="color:#ae81ff">0</span>; x &lt; tilesetColumns; x++)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            _tiles[y * tilesetColumns + x] = <span style="color:#66d9ef">new</span> Rectangle(
</span></span><span style="display:flex;"><span>                x * _tileWidth, <span style="color:#75715e">// upper left-hand x cordinate</span>
</span></span><span style="display:flex;"><span>                y * _tileHeight, <span style="color:#75715e">// upper left-hand y coordinate</span>
</span></span><span style="display:flex;"><span>                _tileWidth, <span style="color:#75715e">// width </span>
</span></span><span style="display:flex;"><span>                _tileHeight <span style="color:#75715e">// height</span>
</span></span><span style="display:flex;"><span>                );
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Third line is map size (in tiles)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> thirdLine = lines[<span style="color:#ae81ff">2</span>].Split(<span style="color:#e6db74">&#39;,&#39;</span>);
</span></span><span style="display:flex;"><span>    _mapWidth = <span style="color:#66d9ef">int</span>.Parse(thirdLine[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    _mapHeight = <span style="color:#66d9ef">int</span>.Parse(thirdLine[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Fourth line is map data</span>
</span></span><span style="display:flex;"><span>    _map = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[_mapWidth * _mapHeight];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> fourthLine = lines[<span style="color:#ae81ff">3</span>].Split(<span style="color:#e6db74">&#39;,&#39;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; _mapWidth * _mapHeight; i++)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _map[i] = <span style="color:#66d9ef">int</span>.Parse(fourthLine[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>While there is a lot going on here, it is also mostly basic File I/O based on the structure of the file.</p>
<h4 id="rendering-the-tilemap">Rendering the Tilemap</h4>
<p>Finally, drawing the map involves iterating over the data and invoking <code>SpriteBatch.Draw()</code> for each tile that needs drawn.</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime, SpriteBatch spriteBatch)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> y = <span style="color:#ae81ff">0</span>; y &lt; _mapHeight; y++)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> x = <span style="color:#ae81ff">0</span>; x &lt; _mapWidth; x++) 
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Indexes start at 1, so shift for array coordinates</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> index = _map[y * _mapWidth + x] - <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Index of -1 (shifted from 0) should not be drawn</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (index == -<span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            spriteBatch.Draw(
</span></span><span style="display:flex;"><span>                _tilesetTexture,
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">new</span> Vector2(
</span></span><span style="display:flex;"><span>                    x * _tileWidth,
</span></span><span style="display:flex;"><span>                    y * _tileHeight
</span></span><span style="display:flex;"><span>                ),
</span></span><span style="display:flex;"><span>                _tiles[index],
</span></span><span style="display:flex;"><span>                Color.White
</span></span><span style="display:flex;"><span>            );
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Organizing these fields and methods into a class gives us a simple tile engine. This can be expanded to address a lot of different games&rsquo; needs.  However, it <em>does</em> require building the map file by hand, using raw tile indices.  This gets challenging quickly, which leads us to our next topic - using a tilemap editor.</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script src="/cis580/js/clipboard/clipboard.min.js?1756153111" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1756153111" defer></script>
    <script src="/cis580/js/theme.min.js?1756153111" defer></script>
  <script src="/cis580/js/embed-iframe.min.js?1756153111" defer></script>
  </body>
</html>
