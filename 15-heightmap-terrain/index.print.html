




  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="Keep your feet on the ground!">
    <meta name="author" content="Nathan Bean">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Heightmap Terrain :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="Keep your feet on the ground!">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/15-heightmap-terrain/">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Heightmap Terrain :: K-State CIS 580 Textbook">
    <meta property="og:description" content="Keep your feet on the ground!">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="website">
    <meta itemprop="name" content="Heightmap Terrain :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="Keep your feet on the ground!">
    <meta itemprop="datePublished" content="2020-03-20T10:53:05-05:00">
    <meta itemprop="dateModified" content="2023-08-11T11:18:05-05:00">
    <meta itemprop="wordCount" content="6">
    <title>Heightmap Terrain :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/15-heightmap-terrain/" rel="canonical" type="text/html" title="Heightmap Terrain :: K-State CIS 580 Textbook">
    <link href="/cis580/15-heightmap-terrain/index.xml" rel="alternate" type="application/rss+xml" title="Heightmap Terrain :: K-State CIS 580 Textbook">
    <link href="/cis580/15-heightmap-terrain/tele.html" rel="alternate" type="text/html" title="Heightmap Terrain :: K-State CIS 580 Textbook">
    <link href="/cis580/15-heightmap-terrain/embed.html" rel="alternate" type="text/html" title="Heightmap Terrain :: K-State CIS 580 Textbook">
    <link href="/cis580/css/fontawesome-all.min.css?1719519539" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/fontawesome-all.min.css?1719519539" rel="stylesheet"></noscript>
    <link href="/cis580/css/nucleus.css?1719519539" rel="stylesheet">
    <link href="/cis580/css/auto-complete.css?1719519539" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/auto-complete.css?1719519539" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar.min.css?1719519539" rel="stylesheet">
    <link href="/cis580/css/fonts.css?1719519539" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/fonts.css?1719519539" rel="stylesheet"></noscript>
    <link href="/cis580/css/theme.css?1719519539" rel="stylesheet">
    <link href="/cis580/css/theme-auto.css?1719519539" rel="stylesheet" id="R-variant-style">
    <link href="/cis580/css/chroma-auto.css?1719519539" rel="stylesheet" id="R-variant-chroma-style">
    <link href="/cis580/css/variant.css?1719519539" rel="stylesheet">
    <link href="/cis580/css/print.css?1719519539" rel="stylesheet" media="print">
    <link href="/cis580/css/format-print.css?1719519539" rel="stylesheet">
    <script src="/cis580/js/variant.js?1719519539"></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.index_js_url="/cis580/index.search.js";
      // variant stuff
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
    </script>
    
    <link href="/cis580/css/custom.css?1719519539" rel="stylesheet">
  </head>
  <body class="mobile-support print disableInlineCopyToClipboard" data-url="/cis580/15-heightmap-terrain/">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li
            itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement"><span itemprop="name">Heightmap Terrain</span><meta itemprop="position" content="1"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/14-lighting-and-cameras/07-summary/" title="Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/15-heightmap-terrain/01-introduction/" title="Introduction (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
            <header class="headline">
            </header>

<h1 id="heightmap-terrain">Heightmap Terrain</h1>

<p>Keep your feet on the ground!</p>
<img src="https://media.giphy.com/media/8ugUSaSctDDMI/giphy.gif"/>
            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          <section>
            <h1 class="a11y-only">Subsections of Heightmap Terrain</h1>
    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="introduction">Introduction</h1>

<p>Now that we understand how 3D worlds are built from triangle meshes, and how we can use cameras to explore those worlds, let&rsquo;s start putting those ideas to work.  In this section, we&rsquo;ll focus on creating terrain from a heightmap - a grayscale bitmap representing the changing elevation of the ground.</p>
<p>Like our earlier examples, we&rsquo;ll start from a starter project with our assets pre-loaded.  In addition, we&rsquo;ll include the <code>ICamera</code> interface and the <code>FPSCamera</code> we created in the lesson on <a href="https://textbooks.cs.ksu.edu/cis580/14-lighting-and-cameras/" rel="external" target="_blank">Lights and Cameras</a>.  It is also preloaded with public-domain content assets, including a heightmap from Wikimedia and a grass texture from Para on OpenGameArt&rsquo;s <a href="https://opengameart.org/content/synthetic-grass-texture-pack" rel="external" target="_blank">Synthetic Grass Texture Pack</a>.</p>
<p>You can find the starter project here: <a href="https://github.com/ksu-cis/heightmap-terrain-starter" rel="external" target="_blank">https://github.com/ksu-cis/heightmap-terrain-starter</a></p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="heightmaps">Heightmaps</h1>

<p>You might be wondering just what a <em>heightmap</em> is.  If you&rsquo;ve ever used a <a href="https://en.wikipedia.org/wiki/Topographic_map" rel="external" target="_blank">topographic map</a>, you&rsquo;ve seen a similar idea.  Contour maps include <em>contour</em> lines_, lines that trace when the ground reaches a certain altitude.  Inside the line is higher than that altitude, and outside of the line is lower (or visa-versa).  The contours themselves are typically marked with the altitude they represent.</p>
<p>A heightmap is similar, but instead of using lines, each <em>pixel</em> in the map represents a square section of land, and the color value at that point indicates the average altitude of that square.  Since there is only one value to represent, heightmaps are typically created in grayscale.  And, to optimize space, they may also be saved in a monochrome format (where each pixel is stored as a single 8-bit value, instead of the 32-bits typical for storing RGB values).</p>
<p><a href="#R-image-b875741204c1d18e8158e13e5a3acd46" class="lightbox-link"><img alt="Heightmap Example" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/Heightmap.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b875741204c1d18e8158e13e5a3acd46"><img alt="Heightmap Example" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/Heightmap.png"></a></p>
<p>You can obtain heightmaps in a number of ways.  You can draw a heightmap with any raster graphics program, though it takes a lot of skill and patience to make one that mimics natural terrain.  You can also get real-world heightmaps directly from organizations like the <a href="http://earthexplorer.usgs.gov/" rel="external" target="_blank">USGS</a> or <a href="http://viewfinderpanoramas.org/Coverage%20map%20viewfinderpanoramas_org3.htm" rel="external" target="_blank">NASA&rsquo;s Viewfinder Project</a>.  Or you can generate one using Perlin Noise and algorithms that mimic the results of plate tectonics.  There also exist many height-map generation programs, both open-source and commercial.</p>
<p>Along with the height map, you also need to know the sampling resolution (how large each terrain square should be), and the scale that should be applied to the heights (as the pixel values of the heightmap will be in values between 0 and 255).</p>
<p>Now, let&rsquo;s turn our attention to creating a Terrain class that will use a heightmap.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="terrain-class">Terrain Class</h1>

<p>We&rsquo;ll start with the class definition:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl"><span class="cs">/// A class representing terrain</span>
</span></span><span class="line"><span class="cl"><span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">Terrain</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// The game this Terrain belongs to</span>
</span></span><span class="line"><span class="cl">    <span class="n">Game</span> <span class="n">game</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>As with most of our classes, we&rsquo;ll keep a reference to the <code>Game</code> object to access the shared <code>ContentManager</code> and <code>GraphicsDevice</code>.</p>
<h3 id="class-fields">Class Fields</h3>
<p>We could store our heightmap directly, but all we really need out of it are the height values, and these need to be scaled.  So instead, we&rsquo;ll store the result of that computation in a 2D array of floats:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// The height data </span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span><span class="p">[,]</span> <span class="n">heights</span><span class="p">;</span></span></span></code></pre></div><p>It&rsquo;s also convenient to keep track of the width and height of our terrain (in grid cells), and the total number of triangles in the terrain&rsquo;s mesh:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// The number of cells in the x-axis</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The number of cells in the z-axis</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">height</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The number of triangles in the mesh</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">triangles</span><span class="p">;</span></span></span></code></pre></div><p>To render the heightmap, we need a <code>VertexBuffer</code> and <code>IndexBuffer</code> to represent our triangle mesh, and a <code>BasicEffect</code> to render it, and a <code>Texture2D</code> to apply to it:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// The terrain mesh vertices</span>
</span></span><span class="line"><span class="cl">    <span class="n">VertexBuffer</span> <span class="n">vertices</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The terrain mesh indices</span>
</span></span><span class="line"><span class="cl">    <span class="n">IndexBuffer</span> <span class="n">indices</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The effect used to render the terrain</span>
</span></span><span class="line"><span class="cl">    <span class="n">BasicEffect</span> <span class="n">effect</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The texture to apply to the terrain surface</span>
</span></span><span class="line"><span class="cl">    <span class="n">Texture2D</span> <span class="n">texture</span><span class="p">;</span></span></span></code></pre></div><h3 id="getting-the-height-data">Getting the Height Data</h3>
<p>We&rsquo;ll write a helper method, <code>LoadHeights()</code>, to convert our heightmap from a <code>Texture2D</code> into our 2D array of floats.  As you might expect from our earlier discussion, we&rsquo;ll also need to know the scaling factor for determining the height. We&rsquo;ll take these as parameters to our method:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// Converts the supplied Texture2D into height data</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param name=&#34;heightmap&#34;&gt;The heightmap texture&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param name=&#34;scale&#34;&gt;The difference between the highest and lowest elevation&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">void</span> <span class="n">LoadHeights</span><span class="p">(</span><span class="n">Texture2D</span> <span class="n">heightmap</span><span class="p">,</span> <span class="kt">float</span> <span class="n">scale</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>An easy way to define the scale is to use the difference between the lowest and highest elevations, in the units of the game world.  If we treat the color of the pixel as a value between 0 and 1, we can just multiply the scale by the color.  Unfortunately, our color channels in a <code>Texture2D</code> are actually represented as a byte with value between 0 and 255.  But we can transform that into our desired range by dividing that value by 256.  Instead of doing that division operation in a loop (causing N*M divisions where N is the width of the heightmap and M is the width), we can pre-divide the scale, and get the same effect with a single division operation:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// Convert the scale factor to work with our color</span>
</span></span><span class="line"><span class="cl">   <span class="n">scale</span> <span class="p">/=</span> <span class="m">256</span><span class="p">;</span></span></span></code></pre></div><p>We&rsquo;ll also set the <code>width</code> and <code>height</code> properties to match the dimensions of our heightmap:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// The number of grid cells in the x-direction</span>
</span></span><span class="line"><span class="cl">    <span class="n">width</span> <span class="p">=</span> <span class="n">heightmap</span><span class="p">.</span><span class="n">Width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// The number of grid cells in the z-direction</span>
</span></span><span class="line"><span class="cl">    <span class="n">height</span> <span class="p">=</span> <span class="n">heightmap</span><span class="p">.</span><span class="n">Height</span><span class="p">;</span></span></span></code></pre></div><p>Which will also be the dimensions of our <code>heights</code> array:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="n">heights</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">float</span><span class="p">[</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">];</span>            </span></span></code></pre></div><p>Now, we need to get the color data from our heightmap.  We can extract that with the <a href="https://www.monogame.net/documentation/?page=M_Microsoft_Xna_Framework_Graphics_Texture2D_GetData__1_3" rel="external" target="_blank">Texture2D.GetData()</a> method.  This returns the data as a one-dimensional array of <code>Color</code> structures.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// Get the color data from the heightmap</span>
</span></span><span class="line"><span class="cl">    <span class="n">Color</span><span class="p">[]</span> <span class="n">heightmapColors</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Color</span><span class="p">[</span><span class="n">width</span> <span class="p">*</span> <span class="n">height</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="n">heightmap</span><span class="p">.</span><span class="n">GetData</span><span class="p">&lt;</span><span class="n">Color</span><span class="p">&gt;(</span><span class="n">heightmapColors</span><span class="p">);</span></span></span></code></pre></div><p>We can then iterate through our <code>heights</code> array, setting each entry to the color value extracted from the heightmap scaled by our scaling factor:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// Set the heights</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">y</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">heights</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">=</span> <span class="n">heightmapColors</span><span class="p">[</span><span class="n">x</span> <span class="p">+</span> <span class="n">y</span> <span class="p">*</span> <span class="n">width</span><span class="p">].</span><span class="n">R</span> <span class="p">*</span> <span class="n">scale</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>Remember that we can convert from two-dimensional array indices to a one-dimensional index with the equation <code>index = x + y * width]</code>.</p>
<p>After setting the heights, we&rsquo;ve finished with this method.  Next we&rsquo;ll tackle creating our vertices</p>
<h3 id="creating-the-vertices">Creating the Vertices</h3>
<p>We&rsquo;ll create our vertices in an <code>InitializeVertices()</code> helper method:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// Creates the terrain vertex buffer</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">void</span> <span class="n">InitializeVertices</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>We&rsquo;ll start by creating an array to hold our vertex data.  We&rsquo;ll use the <a href="https://www.monogame.net/documentation/?page=T_Microsoft_Xna_Framework_Graphics_VertexPositionNormalTexture" rel="external" target="_blank">VertexPositionNormalTexture</a> structure as the type of our vertices.  The size of this array will be the same size as the heightmap data:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="n">VertexPositionNormalTexture</span><span class="p">[]</span> <span class="n">terrainVertices</span> <span class="p">=</span> <span class="k">new</span> <span class="n">VertexPositionNormalTexture</span><span class="p">[</span><span class="n">width</span> <span class="p">*</span> <span class="n">height</span><span class="p">];</span>      </span></span></code></pre></div><p>We&rsquo;ll also create an index variable to simplify the transition between our 2D heights array and our 1D vertex array:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span></span></span></code></pre></div><p>Now we can iterate through the vertex data, setting the <code>Position</code>, <code>Normal</code>, and <code>Texture</code> properties of each vertex:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">z</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">z</span> <span class="p">&lt;</span> <span class="n">height</span><span class="p">;</span> <span class="n">z</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">terrainVertices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Position</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">heights</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="p">-</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">terrainVertices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Normal</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">Up</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">terrainVertices</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">TextureCoordinate</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector2</span><span class="p">((</span><span class="kt">float</span><span class="p">)</span><span class="n">x</span> <span class="p">/</span> <span class="m">50f</span><span class="p">,</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">z</span> <span class="p">/</span> <span class="m">50f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">i</span><span class="p">++;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>A couple of things to be aware of:</p>
<ol>
<li>We are creating our terrain starting at position (0, 0) and out along the positive x-axis and the negative z-axis.  This would be our <em>model</em> coordinates.</li>
<li>Right now, we&rsquo;re treating the surface normal as always being straight up.  It would be more accurate to calculate this normal based on the terrain slope at that point.</li>
<li>We&rsquo;re setting our texture coordinate to be 1/50th of index value.  This means our terrain texture will cover 50 grid cells.  This might need tweaked depending on what textures we are using.</li>
</ol>
<p>Armed with our vertex data, we can create and populate our  <code>VertexBuffer</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="n">vertices</span> <span class="p">=</span> <span class="k">new</span> <span class="n">VertexBuffer</span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">GraphicsDevice</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">VertexPositionNormalTexture</span><span class="p">),</span> <span class="n">terrainVertices</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="n">BufferUsage</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">vertices</span><span class="p">.</span><span class="n">SetData</span><span class="p">&lt;</span><span class="n">VertexPositionNormalTexture</span><span class="p">&gt;(</span><span class="n">terrainVertices</span><span class="p">);</span></span></span></code></pre></div><h3 id="creating-the-indices">Creating the Indices</h3>
<p>Before we dive into code, let&rsquo;s think about how we want to lay out our triangle mesh.  We could use either a triangle list, or a triangle strip.  With a triangle list, we need to have an index for <em>each</em> of the corners of <em>each</em> triangle.  Since we have two triangles per grid cell, the total number of indices would be <code>indexCount = 3 * width * height</code>.  Conversely, with a triangle strip, we only need <em>one</em> index for each triangle after the first, which needs three.  So its size would be <code>indexCount = width * height + 2</code>.  This is nearly <em>a third</em> of the size!  So naturally, we&rsquo;d like to use a triangle list.  This is pretty straightforward for a single row:</p>
<p><a href="#R-image-ec10623377fda0ae9d38f8e246b9544d" class="lightbox-link"><img alt="Single Row Triangle Strip" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ec10623377fda0ae9d38f8e246b9544d"><img alt="Single Row Triangle Strip" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.1.png"></a></p>
<p>The diagram above shows what a row defined as a triangle strip looks like.  Each vertex (the purple circle) is labeled by the order it appears in the indices.  The blue arrows denote the triangle edges defined by successive vertices.  The gray dashed lines denote the side of the triangle inferred from the order of the vertices.  And each triangle is numbered in blue by the order it is defined.</p>
<p>But what about the next row?  You might be tempted to start on the left again, but doing so will result in a triangle that stretches across the breadth of the terrain - which will look terrible!</p>
<p><a href="#R-image-b0ee845afe5ee7ef5427dc49a35d4aac" class="lightbox-link"><img alt="Triangle Stretching Across the Row" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b0ee845afe5ee7ef5427dc49a35d4aac"><img alt="Triangle Stretching Across the Row" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.2.png"></a></p>
<p>This triangle is outlined in the above diagram by the ochre lines.  Note that in the game they won&rsquo;t be curved - the triangle will just slice through the terrain.</p>
<p>Or, we can try zig-zagging, by going right-to-left with the second row.</p>
<p><a href="#R-image-65337b0d4c015a1726f681971f8fa983" class="lightbox-link"><img alt="Zig-zagging Triangle Strip" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-65337b0d4c015a1726f681971f8fa983"><img alt="Zig-zagging Triangle Strip" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.3.png"></a></p>
<p>Notice that doing so creates a triangle that stretches along the end of the terrain.  This probably wouldn&rsquo;t be a problem as we probably would obscure the edge of our terrain in the game anyway.  But also notice that the diagonals of each terrain row slant the opposite ways.  This <em>does</em> cause a problem for us, which we&rsquo;ll understand in a bit.</p>
<p>Instead, we&rsquo;ll create <em>two</em> extra triangles between each row.</p>
<p><a href="#R-image-90f754b701287f13ae42c9a14d182146" class="lightbox-link"><img alt="Our Triangle Strip Layout Strategy" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-90f754b701287f13ae42c9a14d182146"><img alt="Our Triangle Strip Layout Strategy" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.4.png"></a></p>
<p>Notice that for the two extra triangles created by this pattern, 6 and 7, two of their vertices are the same.  This means they are actually lines!  And they will be rendered as part of the edge of triangles 5 and 8.  Moreover, all our diagonals are slanting the same direction.</p>
<p>Let&rsquo;s use this pattern as we declare our indices in the helper method <code>InitializeIndices()</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// Creates the index buffer</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">void</span> <span class="n">InitializeIndices</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>We need to know how many indices are needed to draw our triangles, and use this value to initialize our index array:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// The number of triangles in the triangle strip</span>
</span></span><span class="line"><span class="cl">    <span class="n">triangles</span> <span class="p">=</span> <span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="p">*</span> <span class="m">2</span> <span class="p">*</span> <span class="p">(</span><span class="n">height</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span><span class="p">[]</span> <span class="n">terrainIndices</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">triangles</span><span class="p">];</span></span></span></code></pre></div><p>We&rsquo;ll also need a couple of index variables:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">z</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span></span></span></code></pre></div><p>Now as we iterate over the terrain, we&rsquo;ll need to reverse the direction each row.  So we&rsquo;ll use <em>two</em> inner loops, one for the row running left, and one for the row running right.  Since we don&rsquo;t know which will be our last row, we&rsquo;ll use the same invariant for both (<code>z &lt; height - 1</code>):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">z</span> <span class="p">&lt;</span> <span class="n">height</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">width</span><span class="p">;</span> <span class="n">x</span><span class="p">++)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">terrainIndices</span><span class="p">[</span><span class="n">i</span><span class="p">++]</span> <span class="p">=</span> <span class="n">x</span> <span class="p">+</span> <span class="n">z</span> <span class="p">*</span> <span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">terrainIndices</span><span class="p">[</span><span class="n">i</span><span class="p">++]</span> <span class="p">=</span> <span class="n">x</span> <span class="p">+</span> <span class="p">(</span><span class="n">z</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span> <span class="p">*</span> <span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">z</span><span class="p">++;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">z</span> <span class="p">&lt;</span> <span class="n">height</span> <span class="p">-</span> <span class="m">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="n">width</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">x</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span><span class="p">--)</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">terrainIndices</span><span class="p">[</span><span class="n">i</span><span class="p">++]</span> <span class="p">=</span> <span class="n">x</span> <span class="p">+</span> <span class="p">(</span><span class="n">z</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span> <span class="p">*</span> <span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">terrainIndices</span><span class="p">[</span><span class="n">i</span><span class="p">++]</span> <span class="p">=</span> <span class="n">x</span> <span class="p">+</span> <span class="n">z</span> <span class="p">*</span> <span class="n">width</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">z</span><span class="p">++;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>Another slight optimization we can perform is determining if we can get away with using 16-bit indices, or if we need 32-bit indices.  This is determined by size of our vertex buffer - we need to be able to hold its largest index:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="n">IndexElementSize</span> <span class="n">elementSize</span> <span class="p">=</span> <span class="p">(</span><span class="n">width</span> <span class="p">*</span> <span class="n">height</span> <span class="p">&gt;</span> <span class="kt">short</span><span class="p">.</span><span class="n">MaxValue</span><span class="p">)</span> <span class="p">?</span> <span class="n">IndexElementSize</span><span class="p">.</span><span class="n">ThirtyTwoBits</span> <span class="p">:</span> <span class="n">IndexElementSize</span><span class="p">.</span><span class="n">SixteenBits</span><span class="p">;</span></span></span></code></pre></div><p>Finally, we can create and populate our index buffer:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="n">indices</span> <span class="p">=</span> <span class="k">new</span> <span class="n">IndexBuffer</span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">GraphicsDevice</span><span class="p">,</span> <span class="n">elementSize</span><span class="p">,</span> <span class="n">terrainIndices</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="n">BufferUsage</span><span class="p">.</span><span class="n">None</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">indices</span><span class="p">.</span><span class="n">SetData</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(</span><span class="n">terrainIndices</span><span class="p">);</span></span></span></code></pre></div><h3 id="creating-the-effect">Creating the Effect</h3>
<p>We&rsquo;ll also initialize our <code>BasicEffect</code>, turning on texture rendering and setting our texture.  We&rsquo;ll also set our world matrix here.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// Initialize the effect used to render the terrain</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param name=&#34;world&#34;&gt;The world matrix&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">private</span> <span class="k">void</span> <span class="n">InitializeEffect</span><span class="p">(</span><span class="n">Matrix</span> <span class="n">world</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">effect</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BasicEffect</span><span class="p">(</span><span class="n">game</span><span class="p">.</span><span class="n">GraphicsDevice</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">effect</span><span class="p">.</span><span class="n">World</span> <span class="p">=</span> <span class="n">world</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">effect</span><span class="p">.</span><span class="n">Texture</span> <span class="p">=</span> <span class="n">grass</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">effect</span><span class="p">.</span><span class="n">TextureEnabled</span> <span class="p">=</span> <span class="kc">true</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>   </span></span></code></pre></div><p>We can skip setting the view and projection matrices, as these will come from our camera supplied to the <code>Draw()</code> method.</p>
<h3 id="the-constructor">The Constructor</h3>
<p>The constructor will invoke each of the initialization helper methods we just wrote:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// Constructs a new Terrain</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param name=&#34;game&#34;&gt;The game this Terrain belongs to&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param name=&#34;heightmap&#34;&gt;The heightmap used to set heights&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param name=&#34;heightRange&#34;&gt;The difference between the lowest and highest elevation in the terrain&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param name=&#34;world&#34;&gt;The terrain&#39;s position and orientation in the world&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">Terrain</span><span class="p">(</span><span class="n">Game</span> <span class="n">game</span><span class="p">,</span> <span class="n">Texture2D</span> <span class="n">heightmap</span><span class="p">,</span> <span class="kt">float</span> <span class="n">heightRange</span><span class="p">,</span> <span class="n">Matrix</span> <span class="n">world</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">this</span><span class="p">.</span><span class="n">game</span> <span class="p">=</span> <span class="n">game</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">grass</span> <span class="p">=</span> <span class="n">game</span><span class="p">.</span><span class="n">Content</span><span class="p">.</span><span class="n">Load</span><span class="p">&lt;</span><span class="n">Texture2D</span><span class="p">&gt;(</span><span class="s">&#34;ground_grass_gen_08&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">LoadHeights</span><span class="p">(</span><span class="n">heightmap</span><span class="p">,</span> <span class="n">heightRange</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">InitializeVertices</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">InitializeIndices</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">InitializeEffect</span><span class="p">(</span><span class="n">world</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>It also loads the default grass texture.</p>
<h3 id="drawing-the-terrain">Drawing the Terrain</h3>
<p>Finally, we can turn our attention to drawing the terrain, which is done just like our prior examples:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// Draws the terrain</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param name=&#34;camera&#34;&gt;The camera to use&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="k">void</span> <span class="n">Draw</span><span class="p">(</span><span class="n">ICamera</span> <span class="n">camera</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">effect</span><span class="p">.</span><span class="n">View</span> <span class="p">=</span> <span class="n">camera</span><span class="p">.</span><span class="n">View</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">effect</span><span class="p">.</span><span class="n">Projection</span> <span class="p">=</span> <span class="n">camera</span><span class="p">.</span><span class="n">Projection</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">effect</span><span class="p">.</span><span class="n">CurrentTechnique</span><span class="p">.</span><span class="n">Passes</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Apply</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">game</span><span class="p">.</span><span class="n">GraphicsDevice</span><span class="p">.</span><span class="n">SetVertexBuffer</span><span class="p">(</span><span class="n">vertices</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">game</span><span class="p">.</span><span class="n">GraphicsDevice</span><span class="p">.</span><span class="n">Indices</span> <span class="p">=</span> <span class="n">indices</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">game</span><span class="p">.</span><span class="n">GraphicsDevice</span><span class="p">.</span><span class="n">DrawIndexedPrimitives</span><span class="p">(</span><span class="n">PrimitiveType</span><span class="p">.</span><span class="n">TriangleStrip</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">triangles</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>Next we&rsquo;ll make some changes in our <code>Game</code> class to use our terrain.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="using-the-terrain">Using the Terrain</h1>

<p>Let&rsquo;s see our terrain in action.  First we&rsquo;ll need to make some changes in our <code>ExampleGame</code> class.  We&rsquo;ll add a <code>Terrain</code> field:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// The terrain </span>
</span></span><span class="line"><span class="cl">    <span class="n">Terrain</span> <span class="n">terrain</span><span class="p">;</span></span></span></code></pre></div><p>In our <code>ExampleGame.LoadContent()</code>, we&rsquo;ll load the heightmap and construct our terrain:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// Build the terrain</span>
</span></span><span class="line"><span class="cl">    <span class="n">Texture2D</span> <span class="n">heightmap</span> <span class="p">=</span> <span class="n">Content</span><span class="p">.</span><span class="n">Load</span><span class="p">&lt;</span><span class="n">Texture2D</span><span class="p">&gt;(</span><span class="s">&#34;heightmap&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">terrain</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Terrain</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">heightmap</span><span class="p">,</span> <span class="m">10f</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">Identity</span><span class="p">);</span></span></span></code></pre></div><p>And in our <code>ExampleGame.Draw()</code> we&rsquo;ll render it with the existing camera:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// Draw the terrain</span>
</span></span><span class="line"><span class="cl">    <span class="n">terrain</span><span class="p">.</span><span class="n">Draw</span><span class="p">(</span><span class="n">camera</span><span class="p">);</span></span></span></code></pre></div><p>Now if you run the game, you should see your terrain, and even be able to move around it using the camera controls (WASD + Mouse).</p>
<p><a href="#R-image-ac05bf6040eefab81124915eb1f739e8" class="lightbox-link"><img alt="The rendered terrain" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-4.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ac05bf6040eefab81124915eb1f739e8"><img alt="The rendered terrain" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-4.1.png"></a></p>
<p>You&rsquo;ll probably notice that your camera does not change position as you move over the terrain - in fact, in some parts of the map you can actually end up looking up from underneath!</p>
<p>Clearly we need to do a bit more work.  We need a way to tell the camera what its Y-value should be, based on what part of the terrain it is over.</p>
<h2 id="the-iheightmap-interface">The IHeightMap Interface</h2>
<p>Rather than linking our camera <em>directly</em> to our terrain implementation, let&rsquo;s define an interface that could be used for any surface the player might be walking on.  For lack of a better name, I&rsquo;m calling this interface <code>IHeightMap</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// An interface providing methods for determining the </span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// height at a point in a height map</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="k">interface</span> <span class="nc">IHeightMap</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="cs">/// Gets the height of the map at the specified position</span>
</span></span><span class="line"><span class="cl">        <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="cs">/// &lt;param name=&#34;x&#34;&gt;The x coordinate in the world&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="cs">/// &lt;param name=&#34;z&#34;&gt;The z coordinate in the world&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="cs">/// &lt;returns&gt;The height at the specified position&lt;/returns&gt;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">GetHeightAt</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>The interface defines a single method, <code>GetHeightAt()</code>.  Note that we take the X and Z coordinate - these are <em>world coordinates</em> in the game.  The return value is the Y world coordinate corresponding to the elevation of the terrain at <code>x</code> and <code>z</code>.</p>
<h2 id="refactoring-fpscamera">Refactoring FPSCamera</h2>
<p>We can then use this interface within our <code>FPSCamera</code> class to change its height based on its X and Z.  We&rsquo;ll start by adding a property of type <code>ICamera</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// Gets or sets the heightmap this camera is interacting with</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="n">IHeightMap</span> <span class="n">HeightMap</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span></span></span></code></pre></div><p>We also might want to add a property to say how far above any heightmap we want the camera to be.  Let&rsquo;s call this <code>HeightOffset</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// Gets or sets how high above the heightmap the camera should be</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">float</span> <span class="n">HeightOffset</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span></span></span></code></pre></div><p>And we&rsquo;ll modify our <code>FPSCamera.Update()</code> to use the <code>HeightMap</code> and <code>HeightOffset</code> to determine the camera&rsquo;s Y position:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// Adjust camera height to heightmap </span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">HeightMap</span> <span class="p">!=</span> <span class="kc">null</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">position</span><span class="p">.</span><span class="n">Y</span> <span class="p">=</span> <span class="n">HeightMap</span><span class="p">.</span><span class="n">GetHeightAt</span><span class="p">(</span><span class="n">position</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">position</span><span class="p">.</span><span class="n">Z</span><span class="p">)</span> <span class="p">+</span> <span class="n">HeightOffset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>This should be done <em>before</em> we set the updated <code>View</code> matrix.</p>
<p>Notice that we wrap this in a <code>null</code> check.  If there is no heightmap, we want to keep our default behavior.</p>
<h2 id="refactoring-examplegame">Refactoring ExampleGame</h2>
<p>Since the <code>HeightMap</code> is a property of the <code>FPSCamera</code>, we&rsquo;ll need to set it to our terrain in the <code>ExampleGame.LoadContent()</code> method after both the camera and terrain have been created:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="n">camera</span><span class="p">.</span><span class="n">HeightMap</span> <span class="p">=</span> <span class="n">Terrain</span><span class="p">;</span></span></span></code></pre></div><h2 id="refactoring-terrain">Refactoring Terrain</h2>
<p>Now we need to implement the <code>IHeightMap</code> interface in our <code>Terrain</code> class.  Add it to the class definition:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">class</span> <span class="nc">Terrain</span> <span class="p">:</span> <span class="n">IHeightMap</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>And add the method it calls for:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="cs">/// &lt;summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// Gets the height of the terrain at</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// the supplied world coordinates</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;/summary&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param name=&#34;x&#34;&gt;The x world coordinate&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;param name=&#34;z&#34;&gt;The z world coordinate&lt;/param&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="cs">/// &lt;returns&gt;&lt;/returns&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="kd">public</span> <span class="kt">float</span> <span class="n">GetHeightAt</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{}</span></span></span></code></pre></div><p>Now, let&rsquo;s talk through the process of finding the height.  As our comments suggest, we&rsquo;re using <em>world</em> coordinates, not <em>model</em> coordinates.  As long as the world matrix remains the identity matrix, these are the same.  But as soon as that changes, the world coordinates no longer line up.  So the first thing we need to do is transform them from world coordinates to model coordinates.</p>
<p>Since multiplying a vector in model coordinates by the world matrix transforms them into world coordinates, the inverse should be true.  Specifically, multiplying world coordinates by the <em>inverse of the world matrix</em> should transform them into model coordinates.</p>
<p>The <a href="https://www.monogame.net/documentation/?page=M_Microsoft_Xna_Framework_Matrix_Invert_1" rel="external" target="_blank">Matrix.Invert()</a> method can create this inverse matrix:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="n">Matrix</span> <span class="n">inverseWorld</span> <span class="p">=</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">Invert</span><span class="p">(</span><span class="n">effect</span><span class="p">.</span><span class="n">World</span><span class="p">);</span></span></span></code></pre></div><p>We&rsquo;ll also need the world coordinates as a <code>Vector3</code> to transform:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="n">Vector3</span> <span class="n">worldCoordinates</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Vector3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span></span></span></code></pre></div><p>Here we don&rsquo;t care about the y value, so we&rsquo;ll set it to 0.</p>
<p>Then we can apply the transformation with <a href="https://www.monogame.net/documentation/?page=M_Microsoft_Xna_Framework_Vector3_Transform_7" rel="external" target="_blank">Vector3.Transform()</a>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="n">Vector3</span> <span class="n">modelCoordinates</span> <span class="p">=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">Transform</span><span class="p">(</span><span class="n">worldCoordinates</span><span class="p">,</span> <span class="n">inverseWorld</span><span class="p">);</span></span></span></code></pre></div><p>At this point, <code>modelCoordinates.X</code> and <code>modelCoordinates.Z</code> correspond to the x and -y indices of our <code>heights</code> array, respectively.  The y coordinate needs to be inverted, because our terrain was defined along the negative z-axis (as the positive z-axis is towards the screen).  Let&rsquo;s save them in float variables so we don&rsquo;t have to remember to invert the z as our y coordinate:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">tx</span> <span class="p">=</span> <span class="n">modelCoordinates</span><span class="p">.</span><span class="n">X</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">ty</span> <span class="p">=</span> <span class="p">-</span><span class="n">modelCoordinates</span><span class="p">.</span><span class="n">Z</span><span class="p">;</span></span></span></code></pre></div><p>These <em>should</em> correspond to the x and y indices in the <code>heights</code> array, but it is also possible that they are out-of-bounds.  It&rsquo;s a good idea to check:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">tx</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">ty</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">tx</span> <span class="p">&gt;=</span> <span class="n">width</span> <span class="p">||</span> <span class="n">ty</span> <span class="p">&gt;=</span> <span class="n">height</span><span class="p">)</span> <span class="k">return</span> <span class="m">0</span><span class="p">;</span></span></span></code></pre></div><p>If we&rsquo;re out-of-bounds, we&rsquo;ll just return a height of 0.  Otherwise, we&rsquo;ll return the value in our <code>heights</code> array:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">heights</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span><span class="p">];</span></span></span></code></pre></div><p>Now try running the game and exploring your terrain.  The camera should now move vertically according to the elevation!</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="interpolating-heights">Interpolating Heights</h1>

<p>While you can now walk over your terrain, you probably notice that the camera seems really jittery.  Why isn&rsquo;t it smooth?</p>
<p>Think about how we render our terrain.  The diagram below shows the terrain in one dimension.  At each integral step, we have a height value.  The terrain (represented by green lines) is interpolated between these heights.</p>
<p><a href="#R-image-66e4c159c1bc0a2456df8e81f726f4f7" class="lightbox-link"><img alt="The terrain as rendered" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-5.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-66e4c159c1bc0a2456df8e81f726f4f7"><img alt="The terrain as rendered" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-5.1.png"></a></p>
<p>Now think about what our function transforming world coordinates to heights is doing.  It casts <code>tx</code> to an <code>int</code> to throw away the fractional part of the coordinate in order to get an array index.  Thus, it is a step-like function, as indicated by the red lines in the diagram below:</p>
<p><a href="#R-image-c0ac9fa98fa59ddbdd160a0e7a4ed1df" class="lightbox-link"><img alt="The current height function" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-5.2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c0ac9fa98fa59ddbdd160a0e7a4ed1df"><img alt="The current height function" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-5.2.png"></a></p>
<p>No wonder our movement is jerky!</p>
<p>Instead, we need to <em>interpolate</em> the height between the two coordinates, so we match up with the visual representation.</p>
<h2 id="linear-interpolation">Linear Interpolation</h2>
<p>We could use a method like <a href="https://www.monogame.net/documentation/?page=M_Microsoft_Xna_Framework_MathHelper_Lerp" rel="external" target="_blank">MathHelper.Lerp</a> to interpolate between two height values:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">height1</span> <span class="p">=</span> <span class="n">height</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">height2</span> <span class="p">=</span> <span class="n">height</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">    <span class="kt">var</span> <span class="n">fraction</span> <span class="p">=</span> <span class="n">x</span> <span class="p">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">MathHelper</span><span class="p">.</span><span class="n">Lerp</span><span class="p">(</span><span class="n">fraction</span><span class="p">,</span> <span class="n">height1</span><span class="p">,</span> <span class="n">height2</span><span class="p">);</span></span></span></code></pre></div><p>What does linear interpolation actually do?  Mathematically it&rsquo;s quite simple:</p>
<ol>
<li>Start with the first value at point A (<code>height1</code>)</li>
<li>Calculate the difference between the value at point A and point B (<code>height2 - height1</code>)</li>
<li>Calculate the fraction of the distance between point A and B that  our point of interest lies (<code>x - floor(x)</code>)</li>
<li>Multiply the difference by the fraction, and add it to the height at point A.</li>
</ol>
<p>If we were to write our own linear interpolation implemenation, it might look like:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="kt">float</span> <span class="n">Lerp</span><span class="p">(</span><span class="kt">float</span> <span class="n">fraction</span><span class="p">,</span> <span class="kt">float</span> <span class="n">value1</span><span class="p">,</span> <span class="kt">float</span> <span class="n">value2</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">value1</span> <span class="p">+</span> <span class="n">fraction</span> <span class="p">*</span> <span class="p">(</span><span class="n">value2</span> <span class="p">-</span> <span class="n">value1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>However, we aren&rsquo;t working with just <em>one</em> dimension, we need to consider <em>two</em>.  In other words, we need to use <em>bilinear interpolation</em>.  But XNA does not define a method for this, so we&rsquo;ll have to do it ourselves.</p>
<h2 id="implementing-bilinear-interpolation">Implementing Bilinear Interpolation</h2>
<p>Bilinear interpolation is the extension of linear interpolation into two dimensions.  Instead of interpolating a point on a line (as is the case with linear interpolation), in bilinear interpolation we are interpolating a point on a <em>plane</em>.  But with our terrain, we have <em>two</em> planes per grid cell:</p>
<p><a href="#R-image-0a3decce3bf405b209d83a834c336f82" class="lightbox-link"><img alt="Terrain triangles" class="border lazy lightbox noshadow figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-5.3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-0a3decce3bf405b209d83a834c336f82"><img alt="Terrain triangles" class="border lazy lightbox noshadow lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-5.3.png"></a></p>
<p>In this diagram, <em>n</em> and <em>m</em> are coordinates in our <code>heights</code> array, corresponding to the vertex making up the grid cell.  So if our <code>(x, y)</code> point is in this grid cell,  <code>n &lt; x &lt; n+1</code> and <code>m &lt; y &lt; m+1</code>.</p>
<p>Remember, a triangle defines a plane, and we used <em>two</em> triangles to define each grid cell in our terrain.  So we need to know which triangle our point falls on.</p>
<p>This is why we wanted our diagonals to both face the same way, and also why we wanted them facing the way they do.  If the fractional distance along either the x or y axis is greater than halfway (0.5 in our model coordinates), then we are on the upper-right triangle. The inverse is also true; if both coordinates are less than halfway, we&rsquo;re in the lower left triangle.  Any coordinate falling on line between the two triangles is shared by both.</p>
<p>Let&rsquo;s return to our <code>Terrain.GetHeightAt()</code> method, and start refactoring it.  First, we&rsquo;ll want to change our out-of-bounds test to be slightly more exclusive, as we&rsquo;ll be getting both the height values at both the lower-left corner (tx, ty) and the upper-right corner (tx + 1, ty + 1):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">tx</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">ty</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">||</span> <span class="n">tx</span> <span class="p">&gt;</span> <span class="n">width</span> <span class="p">-</span> <span class="m">2</span> <span class="p">||</span> <span class="n">ty</span> <span class="p">&gt;</span> <span class="n">height</span> <span class="p">-</span> <span class="m">2</span><span class="p">)</span> <span class="k">return</span> <span class="m">0</span><span class="p">;</span></span></span></code></pre></div><p>We can then delete the line <code>return heights[(int)tx, (int)ty];</code>, and replace it with our test to determine which triangle we are in:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">    <span class="c1">// Determine which triangle our coordinate is in</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">tx</span> <span class="p">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span> <span class="p">&lt;</span> <span class="m">0.5</span> <span class="p">&amp;&amp;</span> <span class="n">ty</span> <span class="p">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span> <span class="p">&lt;</span> <span class="m">0.5</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// In the lower-left triangle</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// In the upper-right triangle</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span></code></pre></div><p>Let&rsquo;s finish the lower-left triangle case first.  We&rsquo;ll start with the height at (tx, ty), and add the amount of change along the x-axis as we approach (tx + 1, ty), and the amount of change along the y-axis as we approach (tx, ty + 1).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">        <span class="c1">// In the lower-left triangle</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">xFraction</span> <span class="p">=</span> <span class="n">tx</span> <span class="p">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">yFraction</span> <span class="p">=</span> <span class="n">ty</span> <span class="p">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">xDifference</span> <span class="p">=</span> <span class="n">heights</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span><span class="p">]</span> <span class="p">-</span> <span class="n">heights</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">yDifference</span> <span class="p">=</span> <span class="n">heights</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span> <span class="p">+</span> <span class="m">1</span><span class="p">]</span> <span class="p">-</span> <span class="n">heights</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">heights</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="p">+</span> <span class="n">xFraction</span> <span class="p">*</span> <span class="n">xDifference</span>
</span></span><span class="line"><span class="cl">            <span class="p">+</span> <span class="n">yFraction</span> <span class="p">*</span> <span class="n">yDifference</span><span class="p">;</span></span></span></code></pre></div><p>The upper-right triangle is similar, only we&rsquo;ll start with the height at (tx + 1, ty + 1) and subtract the amount of change along the x-axis as we approach (tx, ty + 1), and the amount of change along the y-axis as we approach (tx + 1, ty).</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl">        <span class="c1">// In the upper-right triangle</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">xFraction</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span> <span class="p">+</span> <span class="m">1</span> <span class="p">-</span> <span class="n">tx</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">yFraction</span> <span class="p">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span> <span class="p">+</span> <span class="m">1</span> <span class="p">-</span> <span class="n">ty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">xDifference</span> <span class="p">=</span> <span class="n">heights</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span> <span class="p">+</span> <span class="m">1</span><span class="p">]</span> <span class="p">-</span> <span class="n">heights</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span> <span class="p">+</span> <span class="m">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="kt">float</span> <span class="n">yDifference</span> <span class="p">=</span> <span class="n">heights</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span> <span class="p">+</span> <span class="m">1</span><span class="p">]</span> <span class="p">-</span> <span class="n">heights</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">heights</span><span class="p">[(</span><span class="kt">int</span><span class="p">)</span><span class="n">tx</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">ty</span> <span class="p">+</span> <span class="m">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">            <span class="p">-</span> <span class="n">xFraction</span> <span class="p">*</span> <span class="n">xDifference</span>
</span></span><span class="line"><span class="cl">            <span class="p">-</span> <span class="n">yFraction</span> <span class="p">*</span> <span class="n">yDifference</span><span class="p">;</span></span></span></code></pre></div><p>Now if you run your code, your camera should smoothly glide over the terrain!</p>
<p>This <code>GetHeightAt()</code> method can be used for other purposes as well.  For example, we could scatter instances of the crates we developed previously across the terrain, using it to determine what their Y-position should be.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

    
    
          <article class="default">
            <header class="headline">
            </header>

<h1 id="summary">Summary</h1>

<p>Now you&rsquo;ve seen the basics of creating a terrain from a heightmap.  Armed with this knowledge, you can create an outdoor game world.  You can find or create additional heightmaps to add new terrains to your game.  You can swap the textures to create different kinds of environments as well.</p>
<p>But you could also create an even <em>larger</em> worlds by using multiple terrains and stitching them together at the edges - a technique often called <em>terrain patches</em>.  With enough of them, you could create an infinite world by looping back to a prior terrain. Or you could rotate a terrain sideways to create a rugged cliff face, or upside down to create a cavern roof.</p>
<p>And you could also change out the <code>BasicEffect</code> for a custom effect that could blend textures based on height changes, or provide a detail texture.  You could also light the terrain realistically if you adjusted the surface normals to be perpendicular to the slope at each vertex.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>

          </section>
        </div>
      </main>
    
<div class="git-footer">
  <p class="theme-version-footer">6.0.0</p>
  <p>Last modified by: 
              <i class='fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cis580/commit/43f194969a638fa4572819da4b31060ad574a9ce">Aug 11, 2023</a>
  </p>
  </div>
  
    
    </div>
    <script src="/cis580/js/clipboard.min.js?1719519539" defer></script>
    <script src="/cis580/js/perfect-scrollbar.min.js?1719519539" defer></script>
    <script src="/cis580/js/theme.js?1719519539" defer></script>
  </body>
</html>
