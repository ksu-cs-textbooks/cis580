<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="We’ll start with the class definition:
/// &lt;summary&gt; /// A class representing terrain /// &lt;/summary&gt; public class Terrain { // The game this Terrain belongs to Game game; } As with most of our classes, we’ll keep a reference to the Game object to access the shared ContentManager and GraphicsDevice.
Class Fields We could store our heightmap directly, but all we really need out of it are the height values, and these need to be scaled.">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="Terrain Class :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="We’ll start with the class definition:
/// &lt;summary&gt; /// A class representing terrain /// &lt;/summary&gt; public class Terrain { // The game this Terrain belongs to Game game; } As with most of our classes, we’ll keep a reference to the Game object to access the shared ContentManager and GraphicsDevice.
Class Fields We could store our heightmap directly, but all we really need out of it are the height values, and these need to be scaled.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/15-heightmap-terrain/03-terrain-class/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Terrain Class :: K-State CIS 580 Textbook">
    <meta property="og:description" content="We’ll start with the class definition:
/// &lt;summary&gt; /// A class representing terrain /// &lt;/summary&gt; public class Terrain { // The game this Terrain belongs to Game game; } As with most of our classes, we’ll keep a reference to the Game object to access the shared ContentManager and GraphicsDevice.
Class Fields We could store our heightmap directly, but all we really need out of it are the height values, and these need to be scaled.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Heightmap Terrain">
    <meta property="article:published_time" content="2020-03-24T10:00:00-05:00">
    <meta property="article:modified_time" content="2023-08-11T11:18:05-05:00">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="Terrain Class :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="We’ll start with the class definition:
/// &lt;summary&gt; /// A class representing terrain /// &lt;/summary&gt; public class Terrain { // The game this Terrain belongs to Game game; } As with most of our classes, we’ll keep a reference to the Game object to access the shared ContentManager and GraphicsDevice.
Class Fields We could store our heightmap directly, but all we really need out of it are the height values, and these need to be scaled.">
    <meta itemprop="datePublished" content="2020-03-24T10:00:00-05:00">
    <meta itemprop="dateModified" content="2023-08-11T11:18:05-05:00">
    <meta itemprop="wordCount" content="1831">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>Terrain Class :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/15-heightmap-terrain/03-terrain-class/index.html" rel="canonical" type="text/html" title="Terrain Class :: K-State CIS 580 Textbook">
    <link href="/cis580/15-heightmap-terrain/03-terrain-class/index.xml" rel="alternate" type="application/rss+xml" title="Terrain Class :: K-State CIS 580 Textbook">
    <link href="/cis580/15-heightmap-terrain/03-terrain-class/index.print.html" rel="alternate" type="text/html" title="Terrain Class :: K-State CIS 580 Textbook">
    <link href="/cis580/15-heightmap-terrain/03-terrain-class/tele.html" rel="alternate" type="text/html" title="Terrain Class :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1756153111" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1756153111" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1756153111" defer></script>
    <script src="/cis580/js/search.min.js?1756153111" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1756153111";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1756153111" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1756153111" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1756153111" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1756153111" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1756153111" rel="stylesheet">
    <link href="/cis580/css/format-html.min.css?1756153111" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/15-heightmap-terrain\/03-terrain-class\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1756153111" rel="stylesheet">
  </head>
  <body class="mobile-support embed html" data-url="/cis580/15-heightmap-terrain/03-terrain-class/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 15-heightmap-terrain" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="terrain-class">Terrain Class</h1>

<p>We&rsquo;ll start with the class definition:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// A class representing terrain</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Terrain</span> 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The game this Terrain belongs to</span>
</span></span><span style="display:flex;"><span>    Game game;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>As with most of our classes, we&rsquo;ll keep a reference to the <code>Game</code> object to access the shared <code>ContentManager</code> and <code>GraphicsDevice</code>.</p>
<h3 id="class-fields">Class Fields</h3>
<p>We could store our heightmap directly, but all we really need out of it are the height values, and these need to be scaled.  So instead, we&rsquo;ll store the result of that computation in a 2D array of floats:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// The height data </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">float</span>[,] heights;</span></span></code></pre></div>
<p>It&rsquo;s also convenient to keep track of the width and height of our terrain (in grid cells), and the total number of triangles in the terrain&rsquo;s mesh:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// The number of cells in the x-axis</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> width;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The number of cells in the z-axis</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> height;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The number of triangles in the mesh</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> triangles;</span></span></code></pre></div>
<p>To render the heightmap, we need a <code>VertexBuffer</code> and <code>IndexBuffer</code> to represent our triangle mesh, and a <code>BasicEffect</code> to render it, and a <code>Texture2D</code> to apply to it:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// The terrain mesh vertices</span>
</span></span><span style="display:flex;"><span>    VertexBuffer vertices;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The terrain mesh indices</span>
</span></span><span style="display:flex;"><span>    IndexBuffer indices;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The effect used to render the terrain</span>
</span></span><span style="display:flex;"><span>    BasicEffect effect;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The texture to apply to the terrain surface</span>
</span></span><span style="display:flex;"><span>    Texture2D texture;</span></span></code></pre></div>
<h3 id="getting-the-height-data">Getting the Height Data</h3>
<p>We&rsquo;ll write a helper method, <code>LoadHeights()</code>, to convert our heightmap from a <code>Texture2D</code> into our 2D array of floats.  As you might expect from our earlier discussion, we&rsquo;ll also need to know the scaling factor for determining the height. We&rsquo;ll take these as parameters to our method:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Converts the supplied Texture2D into height data</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;heightmap&#34;&gt;The heightmap texture&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;scale&#34;&gt;The difference between the highest and lowest elevation&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> LoadHeights(Texture2D heightmap, <span style="color:#66d9ef">float</span> scale)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>An easy way to define the scale is to use the difference between the lowest and highest elevations, in the units of the game world.  If we treat the color of the pixel as a value between 0 and 1, we can just multiply the scale by the color.  Unfortunately, our color channels in a <code>Texture2D</code> are actually represented as a byte with value between 0 and 255.  But we can transform that into our desired range by dividing that value by 256.  Instead of doing that division operation in a loop (causing N*M divisions where N is the width of the heightmap and M is the width), we can pre-divide the scale, and get the same effect with a single division operation:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Convert the scale factor to work with our color</span>
</span></span><span style="display:flex;"><span>   scale /= <span style="color:#ae81ff">256</span>;</span></span></code></pre></div>
<p>We&rsquo;ll also set the <code>width</code> and <code>height</code> properties to match the dimensions of our heightmap:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// The number of grid cells in the x-direction</span>
</span></span><span style="display:flex;"><span>    width = heightmap.Width;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The number of grid cells in the z-direction</span>
</span></span><span style="display:flex;"><span>    height = heightmap.Height;</span></span></code></pre></div>
<p>Which will also be the dimensions of our <code>heights</code> array:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    heights = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">float</span>[width, height];            </span></span></code></pre></div>
<p>Now, we need to get the color data from our heightmap.  We can extract that with the <a href="https://www.monogame.net/documentation/?page=M_Microsoft_Xna_Framework_Graphics_Texture2D_GetData__1_3" rel="external" target="_blank">Texture2D.GetData()</a> method.  This returns the data as a one-dimensional array of <code>Color</code> structures.</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Get the color data from the heightmap</span>
</span></span><span style="display:flex;"><span>    Color[] heightmapColors = <span style="color:#66d9ef">new</span> Color[width * height];
</span></span><span style="display:flex;"><span>    heightmap.GetData&lt;Color&gt;(heightmapColors);</span></span></code></pre></div>
<p>We can then iterate through our <code>heights</code> array, setting each entry to the color value extracted from the heightmap scaled by our scaling factor:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Set the heights</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> y = <span style="color:#ae81ff">0</span>; y &lt; height; y++)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> x = <span style="color:#ae81ff">0</span>; x &lt; width; x++)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            heights[x, y] = heightmapColors[x + y * width].R * scale;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>Remember that we can convert from two-dimensional array indices to a one-dimensional index with the equation <code>index = x + y * width]</code>.</p>
<p>After setting the heights, we&rsquo;ve finished with this method.  Next we&rsquo;ll tackle creating our vertices</p>
<h3 id="creating-the-vertices">Creating the Vertices</h3>
<p>We&rsquo;ll create our vertices in an <code>InitializeVertices()</code> helper method:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Creates the terrain vertex buffer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> InitializeVertices()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>We&rsquo;ll start by creating an array to hold our vertex data.  We&rsquo;ll use the <a href="https://www.monogame.net/documentation/?page=T_Microsoft_Xna_Framework_Graphics_VertexPositionNormalTexture" rel="external" target="_blank">VertexPositionNormalTexture</a> structure as the type of our vertices.  The size of this array will be the same size as the heightmap data:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    VertexPositionNormalTexture[] terrainVertices = <span style="color:#66d9ef">new</span> VertexPositionNormalTexture[width * height];      </span></span></code></pre></div>
<p>We&rsquo;ll also create an index variable to simplify the transition between our 2D heights array and our 1D vertex array:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>;</span></span></code></pre></div>
<p>Now we can iterate through the vertex data, setting the <code>Position</code>, <code>Normal</code>, and <code>Texture</code> properties of each vertex:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> z = <span style="color:#ae81ff">0</span>; z &lt; height; z++)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> x = <span style="color:#ae81ff">0</span>; x &lt; width; x++)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            terrainVertices[i].Position = <span style="color:#66d9ef">new</span> Vector3(x, heights[x, z], -z);
</span></span><span style="display:flex;"><span>            terrainVertices[i].Normal = Vector3.Up;
</span></span><span style="display:flex;"><span>            terrainVertices[i].TextureCoordinate = <span style="color:#66d9ef">new</span> Vector2((<span style="color:#66d9ef">float</span>)x / <span style="color:#ae81ff">50f</span>, (<span style="color:#66d9ef">float</span>)z / <span style="color:#ae81ff">50f</span>);
</span></span><span style="display:flex;"><span>            i++;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>A couple of things to be aware of:</p>
<ol>
<li>We are creating our terrain starting at position (0, 0) and out along the positive x-axis and the negative z-axis.  This would be our <em>model</em> coordinates.</li>
<li>Right now, we&rsquo;re treating the surface normal as always being straight up.  It would be more accurate to calculate this normal based on the terrain slope at that point.</li>
<li>We&rsquo;re setting our texture coordinate to be 1/50th of index value.  This means our terrain texture will cover 50 grid cells.  This might need tweaked depending on what textures we are using.</li>
</ol>
<p>Armed with our vertex data, we can create and populate our  <code>VertexBuffer</code>:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    vertices = <span style="color:#66d9ef">new</span> VertexBuffer(game.GraphicsDevice, <span style="color:#66d9ef">typeof</span>(VertexPositionNormalTexture), terrainVertices.Length, BufferUsage.None);
</span></span><span style="display:flex;"><span>    vertices.SetData&lt;VertexPositionNormalTexture&gt;(terrainVertices);</span></span></code></pre></div>
<h3 id="creating-the-indices">Creating the Indices</h3>
<p>Before we dive into code, let&rsquo;s think about how we want to lay out our triangle mesh.  We could use either a triangle list, or a triangle strip.  With a triangle list, we need to have an index for <em>each</em> of the corners of <em>each</em> triangle.  Since we have two triangles per grid cell, the total number of indices would be <code>indexCount = 3 * width * height</code>.  Conversely, with a triangle strip, we only need <em>one</em> index for each triangle after the first, which needs three.  So its size would be <code>indexCount = width * height + 2</code>.  This is nearly <em>a third</em> of the size!  So naturally, we&rsquo;d like to use a triangle list.  This is pretty straightforward for a single row:</p>
<p><a href="#R-image-9f32accf89ae1eab231c2fa3d029fb8e" class="lightbox-link"><img alt="Single Row Triangle Strip" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-9f32accf89ae1eab231c2fa3d029fb8e"><img alt="Single Row Triangle Strip" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.1.png"></a></p>
<p>The diagram above shows what a row defined as a triangle strip looks like.  Each vertex (the purple circle) is labeled by the order it appears in the indices.  The blue arrows denote the triangle edges defined by successive vertices.  The gray dashed lines denote the side of the triangle inferred from the order of the vertices.  And each triangle is numbered in blue by the order it is defined.</p>
<p>But what about the next row?  You might be tempted to start on the left again, but doing so will result in a triangle that stretches across the breadth of the terrain - which will look terrible!</p>
<p><a href="#R-image-4c9591fa0b44d0bd3a35b704734d46cd" class="lightbox-link"><img alt="Triangle Stretching Across the Row" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-4c9591fa0b44d0bd3a35b704734d46cd"><img alt="Triangle Stretching Across the Row" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.2.png"></a></p>
<p>This triangle is outlined in the above diagram by the ochre lines.  Note that in the game they won&rsquo;t be curved - the triangle will just slice through the terrain.</p>
<p>Or, we can try zig-zagging, by going right-to-left with the second row.</p>
<p><a href="#R-image-72b5e0df1989dc1efedd16ae8e64fae3" class="lightbox-link"><img alt="Zig-zagging Triangle Strip" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-72b5e0df1989dc1efedd16ae8e64fae3"><img alt="Zig-zagging Triangle Strip" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.3.png"></a></p>
<p>Notice that doing so creates a triangle that stretches along the end of the terrain.  This probably wouldn&rsquo;t be a problem as we probably would obscure the edge of our terrain in the game anyway.  But also notice that the diagonals of each terrain row slant the opposite ways.  This <em>does</em> cause a problem for us, which we&rsquo;ll understand in a bit.</p>
<p>Instead, we&rsquo;ll create <em>two</em> extra triangles between each row.</p>
<p><a href="#R-image-25a43e77906d28e02ccab8f102abc113" class="lightbox-link"><img alt="Our Triangle Strip Layout Strategy" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-25a43e77906d28e02ccab8f102abc113"><img alt="Our Triangle Strip Layout Strategy" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/heightmap-terrain-3.4.png"></a></p>
<p>Notice that for the two extra triangles created by this pattern, 6 and 7, two of their vertices are the same.  This means they are actually lines!  And they will be rendered as part of the edge of triangles 5 and 8.  Moreover, all our diagonals are slanting the same direction.</p>
<p>Let&rsquo;s use this pattern as we declare our indices in the helper method <code>InitializeIndices()</code>:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Creates the index buffer</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> InitializeIndices()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>We need to know how many indices are needed to draw our triangles, and use this value to initialize our index array:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// The number of triangles in the triangle strip</span>
</span></span><span style="display:flex;"><span>    triangles = (width) * <span style="color:#ae81ff">2</span> * (height - <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span>[] terrainIndices = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>[triangles];</span></span></code></pre></div>
<p>We&rsquo;ll also need a couple of index variables:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> z = <span style="color:#ae81ff">0</span>;</span></span></code></pre></div>
<p>Now as we iterate over the terrain, we&rsquo;ll need to reverse the direction each row.  So we&rsquo;ll use <em>two</em> inner loops, one for the row running left, and one for the row running right.  Since we don&rsquo;t know which will be our last row, we&rsquo;ll use the same invariant for both (<code>z &lt; height - 1</code>):</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(z &lt; height - <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> x = <span style="color:#ae81ff">0</span>; x &lt; width; x++)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            terrainIndices[i++] = x + z * width;
</span></span><span style="display:flex;"><span>            terrainIndices[i++] = x + (z + <span style="color:#ae81ff">1</span>) * width;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        z++;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(z &lt; height - <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> x = width - <span style="color:#ae81ff">1</span>; x &gt;= <span style="color:#ae81ff">0</span>; x--)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                terrainIndices[i++] = x + (z + <span style="color:#ae81ff">1</span>) * width;
</span></span><span style="display:flex;"><span>                terrainIndices[i++] = x + z * width;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        z++;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>Another slight optimization we can perform is determining if we can get away with using 16-bit indices, or if we need 32-bit indices.  This is determined by size of our vertex buffer - we need to be able to hold its largest index:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    IndexElementSize elementSize = (width * height &gt; <span style="color:#66d9ef">short</span>.MaxValue) ? IndexElementSize.ThirtyTwoBits : IndexElementSize.SixteenBits;</span></span></code></pre></div>
<p>Finally, we can create and populate our index buffer:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    indices = <span style="color:#66d9ef">new</span> IndexBuffer(game.GraphicsDevice, elementSize, terrainIndices.Length, BufferUsage.None);
</span></span><span style="display:flex;"><span>    indices.SetData&lt;<span style="color:#66d9ef">int</span>&gt;(terrainIndices);</span></span></code></pre></div>
<h3 id="creating-the-effect">Creating the Effect</h3>
<p>We&rsquo;ll also initialize our <code>BasicEffect</code>, turning on texture rendering and setting our texture.  We&rsquo;ll also set our world matrix here.</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Initialize the effect used to render the terrain</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;world&#34;&gt;The world matrix&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> InitializeEffect(Matrix world)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        effect = <span style="color:#66d9ef">new</span> BasicEffect(game.GraphicsDevice);
</span></span><span style="display:flex;"><span>        effect.World = world;
</span></span><span style="display:flex;"><span>        effect.Texture = grass;
</span></span><span style="display:flex;"><span>        effect.TextureEnabled = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }   </span></span></code></pre></div>
<p>We can skip setting the view and projection matrices, as these will come from our camera supplied to the <code>Draw()</code> method.</p>
<h3 id="the-constructor">The Constructor</h3>
<p>The constructor will invoke each of the initialization helper methods we just wrote:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Constructs a new Terrain</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;game&#34;&gt;The game this Terrain belongs to&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;heightmap&#34;&gt;The heightmap used to set heights&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;heightRange&#34;&gt;The difference between the lowest and highest elevation in the terrain&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;world&#34;&gt;The terrain&#39;s position and orientation in the world&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Terrain(Game game, Texture2D heightmap, <span style="color:#66d9ef">float</span> heightRange, Matrix world)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.game = game;
</span></span><span style="display:flex;"><span>        grass = game.Content.Load&lt;Texture2D&gt;(<span style="color:#e6db74">&#34;ground_grass_gen_08&#34;</span>);
</span></span><span style="display:flex;"><span>        LoadHeights(heightmap, heightRange);
</span></span><span style="display:flex;"><span>        InitializeVertices();
</span></span><span style="display:flex;"><span>        InitializeIndices();
</span></span><span style="display:flex;"><span>        InitializeEffect(world);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>It also loads the default grass texture.</p>
<h3 id="drawing-the-terrain">Drawing the Terrain</h3>
<p>Finally, we can turn our attention to drawing the terrain, which is done just like our prior examples:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Draws the terrain</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;camera&#34;&gt;The camera to use&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(ICamera camera)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        effect.View = camera.View;
</span></span><span style="display:flex;"><span>        effect.Projection = camera.Projection;
</span></span><span style="display:flex;"><span>        effect.CurrentTechnique.Passes[<span style="color:#ae81ff">0</span>].Apply();
</span></span><span style="display:flex;"><span>        game.GraphicsDevice.SetVertexBuffer(vertices);
</span></span><span style="display:flex;"><span>        game.GraphicsDevice.Indices = indices;
</span></span><span style="display:flex;"><span>        game.GraphicsDevice.DrawIndexedPrimitives(PrimitiveType.TriangleStrip, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, triangles);
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>Next we&rsquo;ll make some changes in our <code>Game</code> class to use our terrain.</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script src="/cis580/js/clipboard/clipboard.min.js?1756153111" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1756153111" defer></script>
    <script src="/cis580/js/theme.min.js?1756153111" defer></script>
  <script src="/cis580/js/embed-iframe.min.js?1756153111" defer></script>
  </body>
</html>
