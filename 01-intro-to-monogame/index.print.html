<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="One Framework to Rule them All">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="Introduction to MonoGame :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="One Framework to Rule them All">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/01-intro-to-monogame/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Introduction to MonoGame :: K-State CIS 580 Textbook">
    <meta property="og:description" content="One Framework to Rule them All">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="Introduction to MonoGame :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="One Framework to Rule them All">
    <meta itemprop="datePublished" content="2018-08-24T10:53:05-05:00">
    <meta itemprop="dateModified" content="2023-08-11T11:18:05-05:00">
    <meta itemprop="wordCount" content="6">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>Introduction to MonoGame :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/01-intro-to-monogame/index.html" rel="canonical" type="text/html" title="Introduction to MonoGame :: K-State CIS 580 Textbook">
    <link href="/cis580/01-intro-to-monogame/index.xml" rel="alternate" type="application/rss+xml" title="Introduction to MonoGame :: K-State CIS 580 Textbook">
    <link href="/cis580/01-intro-to-monogame/tele.html" rel="alternate" type="text/html" title="Introduction to MonoGame :: K-State CIS 580 Textbook">
    <link href="/cis580/01-intro-to-monogame/embed.html" rel="alternate" type="text/html" title="Introduction to MonoGame :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1755628803" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1755628803" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/search.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1755628803";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/format-print.min.css?1755628803" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/01-intro-to-monogame\/index.html';
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1755628803" rel="stylesheet">
  </head>
  <body class="mobile-support print" data-url="/cis580/01-intro-to-monogame/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper"> 
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class="a11y-only"><a itemprop="item" href="/cis580/index.html"><span itemprop="name">CIS 580: Foundations of Game Programming</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">Introduction to MonoGame</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/ksu-cs-textbooks/cis580/edit/master/content/01-intro-to-monogame/_index.md" rel="external" target="_blank" title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/01-intro-to-monogame/index.print.html" title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/00-forward/09-syllabus/index.html" title="Syllabus (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/01-intro-to-monogame/01-introduction/index.html" title="Introduction (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
            <div class="topbar-button topbar-button-embed" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/01-intro-to-monogame/embed.html" title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a>
            </div>
            <div class="topbar-button topbar-button-tele" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/01-intro-to-monogame/tele.html" title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a>
            </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 01-intro-to-monogame" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="introduction-to-monogame">Introduction to MonoGame</h1>

<p>One Framework to Rule them All</p>

  <footer class="footline">
  </footer>
</article>
          <section>
            <h1 class="a11y-only">Subsections of Introduction to MonoGame</h1>
<article class="default">
  <header class="headline">
  </header>

<h1 id="introduction">Introduction</h1>

<p>In this class we are using the MonoGame framework to build our game projects.  MonoGame is an open-source, cross-platform framework built on C# and .NET.  I like to use it for this course because it is truly a framework, not a game engine.  Rather, it supplies tools that provides abstractions for some of the more technically challenging details of developing game software in a non-opinionated manner.</p>
<p>From the developer standpoint, there are several clear benefits:</p>
<ul>
<li>You write code in familiar C#</li>
<li>You have access to all the .NET libraries you are familiar with</li>
<li>Memory is managed (i.e. you don&rsquo;t need to write allocation/de-allocation code as you would in C/C++)</li>
<li>Access and configuration of the graphics hardware is simplified (if you&rsquo;ve ever written raw DirectX initializers, you&rsquo;ll appreciate this)</li>
</ul>
<h2 id="xna-roots">XNA Roots</h2>
<p>MonoGame is the open-source descendant of Microsoft&rsquo;s XNA.  In fact, the first builds of MonoGame were direct ports of XNA, and MonoGame still uses the <code>Microsoft.Xna</code> namespaces.  XNA was created by Microsoft to encourage indie and community game development for the Xbox 360, Windows PCs, and the Windows Phone.  From the developer perspective, it was an extremely successful program; many classic games were developed using XNA, and the XBox 360 had a thriving marketplace for independent games.  Moreover, if you owned an XBox 360, you could deploy your XNA game directly to it using only a network cable; effectively any XBox 360 could be used as a dev kit!</p>
<p>However, the Windows phone was not a market success, and as the XBox One neared development, Microsoft chose not to spend the resources necessary to adapt XNA to it, instead encouraging the indie developer community to adopt the Unity Game Engine.  Eventually, Microsoft announced the official retirement of XNA related technologies on April 1, 2014.</p>
<p>MonoGame was one of several attempts to re-implement the XNA 4 API and provide a successor to the XNA platform.  Thus it has most of the XNA functionality, plus a few additions.  Moreover, it can be targeted at a wide range of platforms, though for this class we&rsquo;ll stick with Windows.</p>
<h2 id="website-and-documentation">Website and Documentation</h2>
<p>You can find the documentation for MonoGame at <a href="https://docs.monogame.net/" rel="external" target="_blank">https://docs.monogame.net/</a>.  This includes <strong>Articles</strong> discussing MonoGame and the published <strong>API</strong>.</p>
<p>See the <strong>Getting Started</strong> section for details on installing MonoGame and starting your first project.</p>

<details open class=" box cstyle notices warning">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-exclamation-triangle"></i> 
    Warning
  </summary>
  <div class="box-content">
<p>MonoGame&rsquo;s libraries are now loaded <em>as a Nuget package</em>, which means the first time you create a MonoGame app on your computer, it will need to download these packages.  This happens automatically, but takes a moment.  Until they finish downloading, your game will report that items in the <code>Microsoft.XNA.Framework</code> namespace cannot be found.</p>
<p>Additionally, MonoGame uses the dotnet mgcb command-line tool to build content.  As Nuget downloads its packages under your user account, and Visual Studio places projects in your user account, this means your user account will be in the path to both.  <strong>If your user folder has spaces in the name, i.e. &ldquo;C:/Users/Bob Test&rdquo;, the space will cause an error when the build process attempts to build the content</strong>.  The only fix I am aware of for this is to create another user account that does not contain spaces, and run your builds from there.</p>
  </div>
</details>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="the-game-class">The Game Class</h1>

<p>At the heart of an XNA project is a class that inherits from <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Game.html" rel="external" target="_blank">Game</a>.  This class handles initializing the graphics device, manages components, and most importantly, implements the game loop.</p>
<h3 id="the-monogame-game-loop">The MonoGame Game Loop</h3>
<p>As you saw in the <a href="https://gameprogrammingpatterns.com/game-loop.html" rel="external" target="_blank">Game Loop Chapter</a> of <em>Game Programming Patterns</em>:</p>
<blockquote>
<p>A <strong>game loop</strong> runs continuously during gameplay. Each turn of the loop, it <strong>processes user input</strong> without blocking, <strong>updates the game state</strong>, and <strong>renders</strong> the game. It tracks the passage of time to <strong>control the rate of gameplay</strong>.</p>
</blockquote>
<p>This is precisely what the <code>Game</code> class implements for us - a loop that 1) processes user input, 2) updates the game state, and 3) renders the game.</p>
<p>As a MonoGame developer, you create a new class that inherits from <code>Game</code> (if you use one of the MonoGame templates, this class will probably be named <code>Game1</code>, but feel free to rename it).  Then, you can write code to execute during steps 2 and 3 of the loop by overriding the virtual methods: <code>Update(GameTime gameTime)</code> and <code>Draw(GameTime gameTime)</code>.  These methods are invoked by <code>Game</code> each time it executes the game loop.  In software engineering parlance, we call this kind of method a &ldquo;hook,&rdquo; as we can use it to pull new functionality into the existing class.</p>
<h3 id="time-and-the-game-loop">Time and the Game Loop</h3>
<p>Time in the MonoGame framework is typically measured using <a href="https://docs.microsoft.com/en-us/dotnet/api/system.timespan?view=net-5.0" rel="external" target="_blank">System.TimeSpan</a> struct.  While this struct has many general uses, for games we almost totally rely on the <code>TimeSpan.TotalSeconds</code> property, which is a double representing the full length of time the TimeSpan represents as a <code>double</code> measured in seconds.</p>
<p>You probably noticed that both methods have a <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.GameTime.html" rel="external" target="_blank">GameTime</a> object as a parameter.  This is a class used to store measurements of time in the game.  It is basically a data object with three properties:</p>
<ul>
<li><code>GameTime.ElapsedGameTime</code> is a <code>TimeSpan</code> measuring the time that elapsed between this and the previous call to <code>Update(GameTime)</code>.  In other words, it is the time between passes in the game loop.</li>
<li><code>GameTime.TotalGameTime</code> is a <code>TimeSpan</code> measuring the total time since the game was started.</li>
<li><code>IsRunningSlowly</code> is a <code>Boolean</code> indicating that the game is lagging (more on this shortly)</li>
</ul>
<p>As you saw in the <em>Game Programming Patterns</em>, the game loop can be clamped (fixed), or run as fast as possible.  MonoGame allows you to choose either strategy.  You can specify the strategy you want by changing the <code>Game.IsFixedTimeStep</code> boolean property.  When using a fixed time step, you can specify the desired time step (the time between game loop passes) by setting the <code>Game.TargetElapsedTime</code> property to a <code>TimeSpan</code> of the desired duration.</p>
<p>By default, MonoGame adopts the <strong>fixed update time step, variable rendering</strong> strategy from <em>Game Programming Patterns</em>.  If a pass through the game loop takes too long, it skips rendering (the <code>Game.Draw()</code> is not invoked), and the <code>TimeSpan</code> provided to the <code>Game.Update()</code> method has its <code>IsRunningSlowly</code> property set to <code>true</code>.  The game will continue to drop rendering frames until the <code>Game.MaximumElapsedTime</code> value is reached, at which point it will invoke <code>Game.Draw()</code>. <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>Setting the <code>Game.IsFixedTimeStep</code> property to <code>false</code> instead runs the game loop as fast as possible.</p>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>You might be wondering what timestep you should use.  It&rsquo;s a tricky question, but there are some easy parameters you can use to frame it:</p>
<p><strong>Fast enough to provide the illusion of motion</strong>  The human brain begins to translate quickly changing images to motion around 16 frames per second.  That&rsquo;s a timestep of <span class="math align-center">$ 0.0625 $</span></p>
<p><strong>At a multiple of 30 frames per second</strong>  At least, in the Americas and parts of Asia televisions and monitors refresh at a multiple of 30, as AC power is delivered at 60 hertz cycles (other parts of the world use 50 hertz).  Cheaper monitors run at 30 frames per second (a timestep of <span class="math align-center">$ 0.03\overline{3333} $</span>), while most modern monitors and televisions run at 60 frames per second (a timestep of <span class="math align-center">$ 0.01\overline{6666} $</span>) and high-end devices might run at 120 frames per second (a timestep of <span class="math align-center">$ 0.008\overline{3333} $</span>).</p>
<p><strong>Slow enough your game doesn&rsquo;t lag</strong>  This speed will vary depending on the hardware in question.  But if your game is consistently slow, you need to either increase the timestep or optimize your code.</p>
<p>By default, the <code>Game.TargetElapsedTime</code> is set to the refresh rate of your monitor - which in most cases will be the ideal rate (as drawing frames more often gives no benefit).</p>
  </div>
</details>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://www.shawnhargreaves.com/blog/understanding-gametime.html" rel="external" target="_blank">Hargreaves, Shawn (7/15/2007) Understanding Game Time</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="the-game-window">The Game Window</h1>

<p>While MonoGame does support 3D rendering, we&rsquo;re going to start with 2D games.  When working in 2D, MonoGame uses a coordinate system similar to the screen coordinates you&rsquo;ve seen in your earlier classes.  The origin of the coordinate system <span class="math align-center">$ (0, 0) $</span>, is the upper-left corner of the game window&rsquo;s client area, and the X-axis increases to the right and the Y-axis increases downward.</p>
<p>The part of the game world that appears on-screen is determined by the active <em>viewport</em>, represented by a <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Graphics.Viewport.html" rel="external" target="_blank">Viewport</a> struct - basically a rectangle plus a minimum and maximum depth.  From the <code>game</code> class, the active viewport is normally reached with <code>GraphicsDevice.Viewport</code>.  It defines the portion of the game world drawn on-screen with four measurements:</p>
<ul>
<li><code>Viewport.X</code> the farthest left range of the viewport along the X-axis</li>
<li><code>Viewport.Y</code> the upper range of the viewport along the Y-axis</li>
<li><code>Viewport.Width</code> the farthest right range of the viewport along the X-Axis</li>
<li><code>Viewport.Height</code> the lower range of the viewport along the Y-axis</li>
</ul>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>You can set the viewport to a subsection of the screen to render into only a portion of the screen - useful for split-screen games, radar systems, missile cameras etc.  We&rsquo;ll explore this technique in a later chapter.</p>
  </div>
</details>
<h2 id="aspect-ratios-and-the-titlesafe-region">Aspect Ratios and the TitleSafe Region</h2>
<p>In addition to these measurements, the <code>Viewport</code> class has a <code>AspectRatio</code> property which returns the <a href="https://en.wikipedia.org/wiki/Aspect_ratio_(image)" rel="external" target="_blank">aspect ratio</a> (the width/height) of the window (or full screen).  XNA was originally developed during the transition from the old 3:1 television standard to the newer 16:9 widescreen television resolution, so aspect ratio was an important consideration.</p>
<p>Along with this is the idea of a <em>title safe</em> region - a part of the screen that you could expect to be visible on any device (where titles and credits should be displayed, hence the name).  Televisions often have a bit of <em>overscan</em>, where the edges of the displayed image are cut off.  Further, if a 3:1 aspect ratio video is displayed on a 16:9 screen, and the player doesn&rsquo;t want to have black bars on the left and right edges of the screen, one of the possible settings will scale the image to fill the space, pushing the top and bottom of the scene into the overscan regions.  Filling a 3:1 screen with a 16:9 image works similarly, except the sides are pushed into the overscan area.</p>
<p>Thus, the <code>Viewport</code> also has a <code>TitleSafeArea</code> which is a <code>Rectangle</code> defining the area that should always be shown on a television.  It is a good idea to make sure that any UI elements the player <em>needs</em> to see fall within this region.</p>
<h2 id="the-game-window">The Game Window</h2>
<p>The window itself is exposed through the <code>GameWindow</code> class.  There should ever only be one instance of the <code>GameWindow</code> class for a given game.  It is created by the <code>Game</code> and assigned to the <code>Game.Window</code> property during initialization.  It exposes properties for working with the window.  For example, you can set your game title with:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Window.Title = <span style="color:#e6db74">&#34;My Cool Game Title&#34;</span>;</span></span></code></pre></div>
<p>This will update what Windows displays in the title bar of the window, as well as when hovering over the icon in the start bar, in the task manager, etc.</p>
<p>The <code>GameWindow</code> class handles much of the work of embedding the game within the host operating system.  For example, when the game looses focus, the <code>Window.Active</code> property is false, and the game loop stops updating (effectively pausing the game).</p>
<p>You shouldn&rsquo;t need to use most of its properties.</p>
<h2 id="setting-the-game-window-size">Setting the Game Window Size</h2>
<p>If you want to specify the size of the window for your game, you can do so by setting the <code>BackBufferWidth</code> and <code>BackBufferHeight</code> properties of the <code>Graphics</code> object.  For example to set the window to 760 x 480, you would add the following code to the <code>Game.Initialize()</code> method (assuming you used the latest MonoGame project template):</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    _graphics.PreferredBackBufferWidth = <span style="color:#ae81ff">760</span>;
</span></span><span style="display:flex;"><span>    _graphics.PreferredBackBufferHeight = <span style="color:#ae81ff">480</span>;
</span></span><span style="display:flex;"><span>    _graphics.ApplyChanges();</span></span></code></pre></div>
<p>You can make the window any size you like - but if it is larger than your screen resolution, you won&rsquo;t be able to see all of it.  To make your game fullscreen and <em>exactly</em>  the size of your monitor, use:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    _graphics.PreferredBackBufferWidth = GraphicsDevice.DisplayMode.Width;
</span></span><span style="display:flex;"><span>    _graphics.PreferredBackBufferHeight = GraphicsDevice.DisplayMode.Height;
</span></span><span style="display:flex;"><span>    _graphics.IsFullScreen = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    _graphics.ApplyChanges();</span></span></code></pre></div>

<details open class=" box cstyle notices warning">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-exclamation-triangle"></i> 
    Warning
  </summary>
  <div class="box-content">
<p>Be sure that you have a means to exit full screen before you run a game in debug mode!  Otherwise, you may not be able to reach VisualStudio&rsquo;s window to stop the debugger.  The default template includes code to close the game window when <code>ESC</code> is pressed.  Also, the default <code>GameWindow</code> configuration uses <code>ALT</code>+ <code>F4</code> to close the window.</p>
  </div>
</details>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="game-initialization">Game Initialization</h1>

<p>Before we actually move into the game loop, we need to <em>initialize</em> the game - load all of its needed parts and set all initial values.  The MonoGame <code>Game</code> class provides two virtual <em>hook</em> methods for doing this: <code>Game.Initialize()</code> and <code>Game.LoadContent()</code>.</p>
<p>You might be wondering why we have <em>two</em> methods, or asking why the constructor is not included in this count.  These are all good questions. First, in the documentation we see that <code>Initialize()</code>:</p>
<blockquote>
<p>Initializes attached GameComponent instances and calls LoadContent().</p>
</blockquote>
<p>And, if we look at the template-generated <code>Game.Initialize()</code> method:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Initialize()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Add your initialization logic here</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">base</span>.Initialize();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We can see that the <code>Game.Initialize()</code> is only invoked <em>after</em> our own initialization logic.  Thus, it is largely a matter of controlling timing.  We only want content (i.e. sounds, textures, etc.) to be loaded once the game is fully initialized.</p>
<p>This is largely because we are using the 3D hardware, which has its own RAM (video memory).  Ideally, textures should be stored there for the fastest and most efficient rendering.  So we want to delay loading our graphics until we have finished configuring the graphics device.  Thus, we do any graphics card configuration in the <code>Initialize()</code> method, <em>before</em> invoking <code>base.Initialize()</code>.</p>
<p>And why not the constructor?  What if we want the player to be able to, upon loosing, immediately restart the game?  If our initialization logic is in <code>Initialize()</code>, we can simply re-invoke that method.  We can&rsquo;t re-construct the <code>Game</code> class though, as it is tied to the life of our application.</p>
<p>Finally, the <code>Game.LoadContent()</code> is invoked after both our <code>Initialze()</code> and the <code>base.Initialize()</code> methods have finished. This means the graphics card is fully initialized, and we can now transfer graphics assets into its memory.</p>
<h3 id="a-simple-example">A Simple Example</h3>
<p>Let&rsquo;s look at a super-simple example demonstrating the game loop.  We&rsquo;ll have a ball that moves a bit each frame and bounces off the sides of the window.</p>
<h4 id="variable-declarations">Variable Declarations</h4>
<p>First, we need to know the ball&rsquo;s position and velocity.  In a two-dimensional game, we would probably use a <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Vector2.html" rel="external" target="_blank">Vector2</a> Struct to represent these.  We also need a <code>Texture2D</code> to be the image of the ball:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// The ball&#39;s information</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Vector2 _ballPosition;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Vector2 _ballVelocity;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span> Texture2D _ballTexture;</span></span></code></pre></div>
<p>Add these lines to the top of the <code>Game1</code> class definition, along with the other field declarations.</p>
<h4 id="initialize-additions">Initialize() Additions</h4>
<p>Then, in our <code>Initialize()</code> method, let&rsquo;s center the ball on the screen:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Position the ball in the center of the screen</span>
</span></span><span style="display:flex;"><span>    _ballPosition.X = GraphicsDevice.Viewport.Width / <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>    _ballPosition.Y = GraphicsDevice.Viewport.Height / <span style="color:#ae81ff">2</span>;</span></span></code></pre></div>
<p>We&rsquo;ll also give it a random velocity:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Give the ball a random velocity</span>
</span></span><span style="display:flex;"><span>    System.Random rand = <span style="color:#66d9ef">new</span> System.Random();
</span></span><span style="display:flex;"><span>    _ballVelocity.X = (<span style="color:#66d9ef">float</span>)rand.NextDouble();
</span></span><span style="display:flex;"><span>    _ballVelocity.Y = (<span style="color:#66d9ef">float</span>)rand.NextDouble();
</span></span><span style="display:flex;"><span>    _ballVelocity.Normalize();
</span></span><span style="display:flex;"><span>    _ballVelocity *= <span style="color:#ae81ff">100</span>;</span></span></code></pre></div>
<p>For now we&rsquo;ll use the <code>System.Random</code> class you are used to.  For some game purposes, it is sufficient, though its randomness is not as random as we&rsquo;ll need for some kinds of games.  Also, note that because <code>Random.NextDouble()</code> returns a double, and <code>Vector2</code> uses floats, we need to implicitly cast the result.  Finally, <code>Vector2.Normalize()</code> will shorten our velocity vector to be of length <span class="math align-center">$ 1 $</span>, which the <code>_ballVelocity *= 100;</code> line scales up to a length of <span class="math align-center">$ 100 $</span>.  Eventually this will mean our ball will be traveling 100 pixels per second.</p>
<h4 id="adding-the-image-to-the-project">Adding the Image to the Project</h4>
<p>As we said above, <code>LoadContent()</code> is where we load our assets.  For now, we just need an image of a ball.  However, getting this image into our game takes a bit of doing.</p>
<p>First, we need to find an image to use - a .jpeg, .gif, or .png will work fine. Feel free to use this one <a href="#R-image-ce8239d26071d2c523bbb2c14dd47cfd" class="lightbox-link"><img alt="a golden ball" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/ball.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-ce8239d26071d2c523bbb2c14dd47cfd"><img alt="a golden ball" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/ball.png"></a>.</p>
<p>Look in the <em>Content</em> folder of your <strong>solution explorer</strong> in Visual Studio.  You should also notice a file, <em>Content.mgcb</em> in the same folder.  This is a listing of all content to bring into the game.  Go ahead and open it; it will look something like:</p>
<p><a href="#R-image-733d63b80a4819468f923c05dcfbd84d" class="lightbox-link"><img alt="The MGCB Editor" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/1.4.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-733d63b80a4819468f923c05dcfbd84d"><img alt="The MGCB Editor" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/1.4.1.png"></a></p>

<details open class=" box cstyle notices tip">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-lightbulb"></i> 
    Tip
  </summary>
  <div class="box-content">
<p>If instead of the editor program a text file is loaded in your VisualStudio instance, try right-click the file and choose &ldquo;open with&rdquo;.  From the dialog, choose the <strong>mgcb-editor-wpf</strong>.  If it is not listed, you may need to install it.  From the command line:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; dotnet tool install --global dotnet-mgcb-editor 
</span></span><span style="display:flex;"><span>&gt; mgcb-editor --register</span></span></code></pre></div>
  </div>
</details>
<p>Click the &ldquo;Add Existing Item&rdquo; toolbar button:</p>
<p><a href="#R-image-543a96da074708523321be314131153d" class="lightbox-link"><img alt="Add Existing Item toolbar button" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/1.4.2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-543a96da074708523321be314131153d"><img alt="Add Existing Item toolbar button" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/1.4.2.png"></a></p>
<p>In the Open dialog that appears, select the ball image and click &ldquo;Open&rdquo;.  Then in the next dialog, choose &ldquo;Copy the file to the directory&rdquo;:</p>
<p><a href="#R-image-350dd4632d5fa9bc4dc0510e425a5e6f" class="lightbox-link"><img alt="Add File Dialog" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/1.4.3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-350dd4632d5fa9bc4dc0510e425a5e6f"><img alt="Add File Dialog" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/1.4.3.png"></a></p>
<p>Finally, save the .mgcb file:</p>
<p><a href="#R-image-6061f6053b68246965e0a74dc92a393e" class="lightbox-link"><img alt="Save the .mgcb file" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/1.4.4.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-6061f6053b68246965e0a74dc92a393e"><img alt="Save the .mgcb file" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/1.4.4.png"></a></p>
<p>Now the image will be built into a game-specific binary format as part of the build process.  We&rsquo;ll delve deeper into how this works in the chapter on the Content Pipeline.</p>
<h4 id="loadcontent-additions">LoadContent() Additions</h4>
<p>To bring the ball texture into the game, we need to load it with a <code>ContentManager</code> class by invoking the <code>ContentManager.Load&lt;T&gt;()</code> method with the name of our content.  The <code>Game</code> class has one already created and ready in the <code>Game.Content</code> property; we&rsquo;ll use it:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>_ballTexture = Content.Load&lt;Texture2D&gt;(<span style="color:#e6db74">&#34;ball&#34;</span>);</span></span></code></pre></div>
<p>Add this line just below the <code>#TODO: use this.Content to load your game content here</code> line in the <code>LoadContent()</code> method.</p>
<p>Note that we use the filename (sans extension) to identify the content file to load, and that we also specify the type of object it should be loaded as (in this case, <code>Texture2D</code>).</p>
<p>At this point, if we were to run the game everything would be initialized.  Now we need to handle updating and rendering the game world.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="the-update-method">The Update Method</h1>

<p>As we mentioned before, the virtual <code>Game.Update(GameTime gameTime)</code> method is a hook for adding your game&rsquo;s logic.  By overriding this method, and adding your own game logic code, you fulfill the update step of the game loop.</p>
<p>This is where you place the <em>simulation</em> code for your game - where the world the game is representing is updated.  Here, all your actors (the parts of the game world that move and interact) are updated.</p>
<p>Note the <code>GameTime</code> parameter - it provides us with both the total time the game has been running, <em>and</em> the time that has elapsed between this and the previous step through the game loop (the frame).  We can use this in our physics calculations.</p>
<h3 id="our-simple-example">Our Simple Example</h3>
<p>So in our example, we want the ball to move around the screen, according to its velocity.  If you remember your physics, the velocity is the change in position over time, i.e.:</p>
<span class="math align-center">$ 
\overrightarrow{p'} = \overrightarrow{p} + \overrightarrow{v} * t
$</span>
<p>We can express this in C# easily:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>_ballPosition += _ballVelocity * (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalSeconds;</span></span></code></pre></div>
<p>Add this code to the <code>Update()</code> method, just below the <code>// TODO</code> statement.  Note that MonoGame provides operator overrides for performing algebraic operations on <code>Vector2</code> structs, which makes writing expressions involving vectors very much like the mathematical notation.  Also, note again that we have to cast the double <code>TotalSeconds</code> into a float as we are loosing some precision in the operation.</p>
<p>Also, note that because we multiply the velocity by the elapsed time, it does not matter <em>what</em> our timestep is - the ball will always move at the same speed.  Had we simply added the velocity to the position, a game running with a 60fps timestep would be twice as fast as one running at 30fps.</p>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>You may encounter advocates of using a hard-coded fixed time step to avoid calculations with elapsed time.  While it is true this approach makes those calculations unnecessary (and thus, makes your code more efficient), you are trading off the ability of your game to adjust to different monitor refresh rates.  In cases where your hardware is constant (i.e. the Nintendo Entertainment System), this was an easy choice.  But with computer games, I would advocate for always calculating with the elapsed time.</p>
  </div>
</details>
<h4 id="keeping-the-ball-on-screen">Keeping the Ball on-screen</h4>
<p>We need to handle when the ball moves off-screen.  We said we wanted to make it <em>bounce</em> off the edges, which is pretty straightforward.  First, we need to determine if the ball is moving off-screen.  To know when this would happen, we need to know two things:</p>
<ol>
<li>The coordinates of the ball</li>
<li>The coordinates of the edges of the screen</li>
</ol>
<p>For 1, we have <code>_ballPosition</code>.  Let&rsquo;s assume this is the upper-right corner of the ball image.  We&rsquo;ll also need to factor in the size of the ball.  The image linked above is 64 pixels, so I&rsquo;ll assume that is the size of the ball we&rsquo;re using.  Feel free to change it to match your asset.</p>
<p>For 2, we can use <code>GraphicsDevice.Viewport</code> to get a rectangle defining the screen.</p>
<p>It can be very helpful to draw a diagram of this kind of setup <em>before</em> you try to derive the necessary calculations, i.e.:</p>
<p><a href="#R-image-11d8728b2f9881a3dcab0de409c5d245" class="lightbox-link"><img alt="A diagram of the game" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/1.5.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-11d8728b2f9881a3dcab0de409c5d245"><img alt="A diagram of the game" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/1.5.1.png"></a></p>
<p>To check if the ball is moving off the left of the screen, we could use an <code>if</code> statement:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(_ballPosition.X &lt; GraphicsDevice.Viewport.X) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Bounce ball</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We could then reverse the direction of the ball by multiplying its velocity in the horizontal plane by <span class="math align-center">$ -1 $</span>:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    _ballVelocity.X *= -<span style="color:#ae81ff">1</span>;</span></span></code></pre></div>
<p>Moving off-screen to the right would be almost identical, so we could actually combine the two into a single if-statement:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Moving offscreen horizontally</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_ballPosition.X &lt; GraphicsDevice.Viewport.X || _ballPosition.X &gt; GraphicsDevice.Viewport.Width - <span style="color:#ae81ff">64</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _ballVelocity.X *= -<span style="color:#ae81ff">1</span>;    
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>Note that we need to shorten the width by 64 pixels to keep the ball on-screen.</p>
<p>The vertical bounce is almost identical:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Moving offscreen vertically</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_ballPosition.Y &lt; GraphicsDevice.Viewport.Y || _ballPosition.Y &gt; GraphicsDevice.Viewport.Height - <span style="color:#ae81ff">64</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _ballVelocity.Y *= -<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>Our bounce here is not quite accurate, as the ball may have moved some pixels off-screen <em>before</em> we reverse the direction.<br>
In the worst case, it will actually so far off screen that with floating point error, it might be off-screen next frame as well (which will result in it getting stuck).  But as long as our ball is traveling less than its dimensions each frame, we should be okay.</p>
  </div>
</details>
<p>Now we just need to draw our bouncy ball.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="the-draw-method">The Draw Method</h1>

<p>The <code>Game.Draw(Game.Update(GameTime gameTime)</code> method is a another hook, this one for adding your game&rsquo;s rendering code.  By overriding this method, and adding your own rendering code, you fulfill the draw step of the game loop.</p>
<p>MonoGame uses the graphics hardware to render the scene, along with <a href="https://gameprogrammingpatterns.com/double-buffer.html" rel="external" target="_blank">double buffering</a>.  Thus, when we render, we are drawing into a back buffer, and once that drawing is complete, we <em>flip</em> the buffers so that the one we just finished is what ends up being rendered on-screen, and we now can start drawing into the next back buffer.</p>
<p>This is why we request a certain window size by setting <code>Game.PreferredBackBufferWidth</code> and <code>Game.PreferredBackBufferHeight</code>.  It is an acknowledgement that we are working with the back buffer (all buffers end up this size).  If our window&rsquo;s client area is a different size, then the texture the back buffer contains is scaled to fit the client dimensions.  If this is not the same aspect ratio, our game will appear squished in one dimension and stretched in the other.</p>
<p>This is why resizing the window is disabled by default in MonoGame.  If you let the user resize the window, you&rsquo;ll want to also adjust your buffers to compensate.</p>
<h3 id="our-simple-example">Our Simple Example</h3>
<p>Our game is two-dimensional. Since MonoGame uses the 3D rendering hardware, this means we&rsquo;re really pretending a 3D scene is two-dimensional.  You might think of it as a bunch of cardboard cut-outs all facing the audience.  To make life easier for us, MonoGame provides the <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Graphics.SpriteBatch.html" rel="external" target="_blank">SpriteBatch</a> class to manage all of those cut-outs.</p>
<p>We&rsquo;ll dig deeper into how it works in a later chapter.  But for now, know that we can render any number of images on-screen by invoking <code>SpriteBatch.Draw()</code> between a <code>SpriteBatch.Begin()</code> and a <code>SpriteBatch.End()</code> invocation.</p>
<p>For our simple ball, this breaks down to:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    _spriteBatch.Begin();            
</span></span><span style="display:flex;"><span>    _spriteBatch.Draw(_ballTexture, _ballPosition, Color.White);
</span></span><span style="display:flex;"><span>    _spriteBatch.End();</span></span></code></pre></div>
<p>Effectively, we&rsquo;re saying we want to draw our texture <code>_ballTexture</code> at <code>_ballPosition</code>, and apply a white color to the image (i.e. leave it the color it already is).</p>
<p>This should be placed after the <code>// TODO</code> in the <code>Base We're going to be rendering with the </code>SpriteBatch` class.</p>
<p>That wraps up our simple exercise.  You should be able to run the game now, and see the ball bounce around the screen.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="summary">Summary</h1>

<p>In this chapter we looked at how MonoGame implements the <a href="/cis580/01-intro-to-monogame/07-summary/index.html">Game Loop</a> pattern within its <code>Game</code> class.  We also saw how the <code>Game</code> class interacts with the <code>GameWindow</code> class, which provides an abstraction of the operating system&rsquo;s window representation.  We saw how we can add our own custom code into the MonoGame game loop by overriding the <code>Game.Update()</code> and <code>Game.Draw()</code> methods, as well as the overriding <code>Game.Initialize()</code> and <code>Game.LoadContent()</code> to set up the game world.</p>
<p>We briefly explored ideas about performing physics calculations within that game world, as well as representing position and velocity of game actors with <code>Vector2</code> objects.  We also touched on how MonoGame renders 2D games with 3D hardware, and used a <code>SpriteBatch</code> instance to render a <code>Texture2D</code> to the screen.  Finally, we animated a bouncing ball using all of these ideas.  The one aspect of the game loop we did <em>not</em> cover though, is input, which we&rsquo;ll take a look at in the next chapter.</p>

  <footer class="footline">
  </footer>
</article>
          </section>
        </div>
      </main>
<div class="git-footer">
  <p class="theme-version-footer">8.0.0</p>
<p>Last modified by:
              <i class='fa-fw fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cis580/commit/43f194969a638fa4572819da4b31060ad574a9ce">Aug 11, 2023</a>
</p>

</div>
    </div>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cis580/js/mathjax/tex-mml-chtml.js?1755628803"></script>
    <script src="/cis580/js/clipboard/clipboard.min.js?1755628803" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1755628803" defer></script>
    <script src="/cis580/js/theme.min.js?1755628803" defer></script>
  </body>
</html>
