<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="The Game.Draw(Game.Update(GameTime gameTime) method is a another hook, this one for adding your game’s rendering code. By overriding this method, and adding your own rendering code, you fulfill the draw step of the game loop.
MonoGame uses the graphics hardware to render the scene, along with double buffering. Thus, when we render, we are drawing into a back buffer, and once that drawing is complete, we flip the buffers so that the one we just finished is what ends up being rendered on-screen, and we now can start drawing into the next back buffer.">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="The Draw Method :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="The Game.Draw(Game.Update(GameTime gameTime) method is a another hook, this one for adding your game’s rendering code. By overriding this method, and adding your own rendering code, you fulfill the draw step of the game loop.
MonoGame uses the graphics hardware to render the scene, along with double buffering. Thus, when we render, we are drawing into a back buffer, and once that drawing is complete, we flip the buffers so that the one we just finished is what ends up being rendered on-screen, and we now can start drawing into the next back buffer.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/01-intro-to-monogame/06-the-draw-method/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="The Draw Method :: K-State CIS 580 Textbook">
    <meta property="og:description" content="The Game.Draw(Game.Update(GameTime gameTime) method is a another hook, this one for adding your game’s rendering code. By overriding this method, and adding your own rendering code, you fulfill the draw step of the game loop.
MonoGame uses the graphics hardware to render the scene, along with double buffering. Thus, when we render, we are drawing into a back buffer, and once that drawing is complete, we flip the buffers so that the one we just finished is what ends up being rendered on-screen, and we now can start drawing into the next back buffer.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Introduction to MonoGame">
    <meta property="article:published_time" content="2018-08-24T10:53:26-05:00">
    <meta property="article:modified_time" content="2021-01-18T14:10:59-06:00">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="The Draw Method :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="The Game.Draw(Game.Update(GameTime gameTime) method is a another hook, this one for adding your game’s rendering code. By overriding this method, and adding your own rendering code, you fulfill the draw step of the game loop.
MonoGame uses the graphics hardware to render the scene, along with double buffering. Thus, when we render, we are drawing into a back buffer, and once that drawing is complete, we flip the buffers so that the one we just finished is what ends up being rendered on-screen, and we now can start drawing into the next back buffer.">
    <meta itemprop="datePublished" content="2018-08-24T10:53:26-05:00">
    <meta itemprop="dateModified" content="2021-01-18T14:10:59-06:00">
    <meta itemprop="wordCount" content="373">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>The Draw Method :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/01-intro-to-monogame/06-the-draw-method/index.html" rel="canonical" type="text/html" title="The Draw Method :: K-State CIS 580 Textbook">
    <link href="/cis580/01-intro-to-monogame/06-the-draw-method/index.xml" rel="alternate" type="application/rss+xml" title="The Draw Method :: K-State CIS 580 Textbook">
    <link href="/cis580/01-intro-to-monogame/06-the-draw-method/index.print.html" rel="alternate" type="text/html" title="The Draw Method :: K-State CIS 580 Textbook">
    <link href="/cis580/01-intro-to-monogame/06-the-draw-method/embed.html" rel="alternate" type="text/html" title="The Draw Method :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1755628803" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1755628803" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/search.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1755628803";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/format-html.min.css?1755628803" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/01-intro-to-monogame\/06-the-draw-method\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1755628803" rel="stylesheet">
  </head>
  <body class="mobile-support html" data-url="/cis580/01-intro-to-monogame/06-the-draw-method/index.html">
    
    <div id="tele" class="tele mirror">
    
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 01-intro-to-monogame" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="the-draw-method">The Draw Method</h1>

<p>The <code>Game.Draw(Game.Update(GameTime gameTime)</code> method is a another hook, this one for adding your game&rsquo;s rendering code.  By overriding this method, and adding your own rendering code, you fulfill the draw step of the game loop.</p>
<p>MonoGame uses the graphics hardware to render the scene, along with <a href="https://gameprogrammingpatterns.com/double-buffer.html" rel="external" target="_blank">double buffering</a>.  Thus, when we render, we are drawing into a back buffer, and once that drawing is complete, we <em>flip</em> the buffers so that the one we just finished is what ends up being rendered on-screen, and we now can start drawing into the next back buffer.</p>
<p>This is why we request a certain window size by setting <code>Game.PreferredBackBufferWidth</code> and <code>Game.PreferredBackBufferHeight</code>.  It is an acknowledgement that we are working with the back buffer (all buffers end up this size).  If our window&rsquo;s client area is a different size, then the texture the back buffer contains is scaled to fit the client dimensions.  If this is not the same aspect ratio, our game will appear squished in one dimension and stretched in the other.</p>
<p>This is why resizing the window is disabled by default in MonoGame.  If you let the user resize the window, you&rsquo;ll want to also adjust your buffers to compensate.</p>
<h3 id="our-simple-example">Our Simple Example</h3>
<p>Our game is two-dimensional. Since MonoGame uses the 3D rendering hardware, this means we&rsquo;re really pretending a 3D scene is two-dimensional.  You might think of it as a bunch of cardboard cut-outs all facing the audience.  To make life easier for us, MonoGame provides the <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Graphics.SpriteBatch.html" rel="external" target="_blank">SpriteBatch</a> class to manage all of those cut-outs.</p>
<p>We&rsquo;ll dig deeper into how it works in a later chapter.  But for now, know that we can render any number of images on-screen by invoking <code>SpriteBatch.Draw()</code> between a <code>SpriteBatch.Begin()</code> and a <code>SpriteBatch.End()</code> invocation.</p>
<p>For our simple ball, this breaks down to:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    _spriteBatch.Begin();            
</span></span><span style="display:flex;"><span>    _spriteBatch.Draw(_ballTexture, _ballPosition, Color.White);
</span></span><span style="display:flex;"><span>    _spriteBatch.End();</span></span></code></pre></div>
<p>Effectively, we&rsquo;re saying we want to draw our texture <code>_ballTexture</code> at <code>_ballPosition</code>, and apply a white color to the image (i.e. leave it the color it already is).</p>
<p>This should be placed after the <code>// TODO</code> in the <code>Base We're going to be rendering with the </code>SpriteBatch` class.</p>
<p>That wraps up our simple exercise.  You should be able to run the game now, and see the ball bounce around the screen.</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script src="/cis580/js/clipboard/clipboard.min.js?1755628803" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1755628803" defer></script>
    <script src="/cis580/js/theme.min.js?1755628803" defer></script>
      
      
      
    </div> 
  <script src="/cis580/js/tele-scroll.min.js?1755628803" defer></script>
  </body>
</html>
