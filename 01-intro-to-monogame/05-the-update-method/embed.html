<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="As we mentioned before, the virtual Game.Update(GameTime gameTime) method is a hook for adding your game’s logic. By overriding this method, and adding your own game logic code, you fulfill the update step of the game loop.
This is where you place the simulation code for your game - where the world the game is representing is updated. Here, all your actors (the parts of the game world that move and interact) are updated.">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="The Update Method :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="As we mentioned before, the virtual Game.Update(GameTime gameTime) method is a hook for adding your game’s logic. By overriding this method, and adding your own game logic code, you fulfill the update step of the game loop.
This is where you place the simulation code for your game - where the world the game is representing is updated. Here, all your actors (the parts of the game world that move and interact) are updated.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/01-intro-to-monogame/05-the-update-method/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="The Update Method :: K-State CIS 580 Textbook">
    <meta property="og:description" content="As we mentioned before, the virtual Game.Update(GameTime gameTime) method is a hook for adding your game’s logic. By overriding this method, and adding your own game logic code, you fulfill the update step of the game loop.
This is where you place the simulation code for your game - where the world the game is representing is updated. Here, all your actors (the parts of the game world that move and interact) are updated.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Introduction to MonoGame">
    <meta property="article:published_time" content="2018-08-24T10:53:26-05:00">
    <meta property="article:modified_time" content="2023-08-14T11:41:07-05:00">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="The Update Method :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="As we mentioned before, the virtual Game.Update(GameTime gameTime) method is a hook for adding your game’s logic. By overriding this method, and adding your own game logic code, you fulfill the update step of the game loop.
This is where you place the simulation code for your game - where the world the game is representing is updated. Here, all your actors (the parts of the game world that move and interact) are updated.">
    <meta itemprop="datePublished" content="2018-08-24T10:53:26-05:00">
    <meta itemprop="dateModified" content="2023-08-14T11:41:07-05:00">
    <meta itemprop="wordCount" content="740">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>The Update Method :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/01-intro-to-monogame/05-the-update-method/index.html" rel="canonical" type="text/html" title="The Update Method :: K-State CIS 580 Textbook">
    <link href="/cis580/01-intro-to-monogame/05-the-update-method/index.xml" rel="alternate" type="application/rss+xml" title="The Update Method :: K-State CIS 580 Textbook">
    <link href="/cis580/01-intro-to-monogame/05-the-update-method/index.print.html" rel="alternate" type="text/html" title="The Update Method :: K-State CIS 580 Textbook">
    <link href="/cis580/01-intro-to-monogame/05-the-update-method/tele.html" rel="alternate" type="text/html" title="The Update Method :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1755628803" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1755628803" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/search.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1755628803";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/format-html.min.css?1755628803" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/01-intro-to-monogame\/05-the-update-method\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1755628803" rel="stylesheet">
  </head>
  <body class="mobile-support embed html" data-url="/cis580/01-intro-to-monogame/05-the-update-method/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 01-intro-to-monogame" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="the-update-method">The Update Method</h1>

<p>As we mentioned before, the virtual <code>Game.Update(GameTime gameTime)</code> method is a hook for adding your game&rsquo;s logic.  By overriding this method, and adding your own game logic code, you fulfill the update step of the game loop.</p>
<p>This is where you place the <em>simulation</em> code for your game - where the world the game is representing is updated.  Here, all your actors (the parts of the game world that move and interact) are updated.</p>
<p>Note the <code>GameTime</code> parameter - it provides us with both the total time the game has been running, <em>and</em> the time that has elapsed between this and the previous step through the game loop (the frame).  We can use this in our physics calculations.</p>
<h3 id="our-simple-example">Our Simple Example</h3>
<p>So in our example, we want the ball to move around the screen, according to its velocity.  If you remember your physics, the velocity is the change in position over time, i.e.:</p>
<span class="math align-center">$ 
\overrightarrow{p'} = \overrightarrow{p} + \overrightarrow{v} * t
$</span>
<p>We can express this in C# easily:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>_ballPosition += _ballVelocity * (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalSeconds;</span></span></code></pre></div>
<p>Add this code to the <code>Update()</code> method, just below the <code>// TODO</code> statement.  Note that MonoGame provides operator overrides for performing algebraic operations on <code>Vector2</code> structs, which makes writing expressions involving vectors very much like the mathematical notation.  Also, note again that we have to cast the double <code>TotalSeconds</code> into a float as we are loosing some precision in the operation.</p>
<p>Also, note that because we multiply the velocity by the elapsed time, it does not matter <em>what</em> our timestep is - the ball will always move at the same speed.  Had we simply added the velocity to the position, a game running with a 60fps timestep would be twice as fast as one running at 30fps.</p>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>You may encounter advocates of using a hard-coded fixed time step to avoid calculations with elapsed time.  While it is true this approach makes those calculations unnecessary (and thus, makes your code more efficient), you are trading off the ability of your game to adjust to different monitor refresh rates.  In cases where your hardware is constant (i.e. the Nintendo Entertainment System), this was an easy choice.  But with computer games, I would advocate for always calculating with the elapsed time.</p>
  </div>
</details>
<h4 id="keeping-the-ball-on-screen">Keeping the Ball on-screen</h4>
<p>We need to handle when the ball moves off-screen.  We said we wanted to make it <em>bounce</em> off the edges, which is pretty straightforward.  First, we need to determine if the ball is moving off-screen.  To know when this would happen, we need to know two things:</p>
<ol>
<li>The coordinates of the ball</li>
<li>The coordinates of the edges of the screen</li>
</ol>
<p>For 1, we have <code>_ballPosition</code>.  Let&rsquo;s assume this is the upper-right corner of the ball image.  We&rsquo;ll also need to factor in the size of the ball.  The image linked above is 64 pixels, so I&rsquo;ll assume that is the size of the ball we&rsquo;re using.  Feel free to change it to match your asset.</p>
<p>For 2, we can use <code>GraphicsDevice.Viewport</code> to get a rectangle defining the screen.</p>
<p>It can be very helpful to draw a diagram of this kind of setup <em>before</em> you try to derive the necessary calculations, i.e.:</p>
<p><a href="#R-image-11d8728b2f9881a3dcab0de409c5d245" class="lightbox-link"><img alt="A diagram of the game" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/1.5.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-11d8728b2f9881a3dcab0de409c5d245"><img alt="A diagram of the game" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/1.5.1.png"></a></p>
<p>To check if the ball is moving off the left of the screen, we could use an <code>if</code> statement:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(_ballPosition.X &lt; GraphicsDevice.Viewport.X) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Bounce ball</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We could then reverse the direction of the ball by multiplying its velocity in the horizontal plane by <span class="math align-center">$ -1 $</span>:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    _ballVelocity.X *= -<span style="color:#ae81ff">1</span>;</span></span></code></pre></div>
<p>Moving off-screen to the right would be almost identical, so we could actually combine the two into a single if-statement:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Moving offscreen horizontally</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_ballPosition.X &lt; GraphicsDevice.Viewport.X || _ballPosition.X &gt; GraphicsDevice.Viewport.Width - <span style="color:#ae81ff">64</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _ballVelocity.X *= -<span style="color:#ae81ff">1</span>;    
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>Note that we need to shorten the width by 64 pixels to keep the ball on-screen.</p>
<p>The vertical bounce is almost identical:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    <span style="color:#75715e">// Moving offscreen vertically</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_ballPosition.Y &lt; GraphicsDevice.Viewport.Y || _ballPosition.Y &gt; GraphicsDevice.Viewport.Height - <span style="color:#ae81ff">64</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _ballVelocity.Y *= -<span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>Our bounce here is not quite accurate, as the ball may have moved some pixels off-screen <em>before</em> we reverse the direction.<br>
In the worst case, it will actually so far off screen that with floating point error, it might be off-screen next frame as well (which will result in it getting stuck).  But as long as our ball is traveling less than its dimensions each frame, we should be okay.</p>
  </div>
</details>
<p>Now we just need to draw our bouncy ball.</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cis580/js/mathjax/tex-mml-chtml.js?1755628803"></script>
    <script src="/cis580/js/clipboard/clipboard.min.js?1755628803" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1755628803" defer></script>
    <script src="/cis580/js/theme.min.js?1755628803" defer></script>
  <script src="/cis580/js/embed-iframe.min.js?1755628803" defer></script>
  </body>
</html>
