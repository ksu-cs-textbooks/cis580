<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="Reorganizing your code…">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="Game Architecture :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="Reorganizing your code…">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/07-game-architecture/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Game Architecture :: K-State CIS 580 Textbook">
    <meta property="og:description" content="Reorganizing your code…">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="Game Architecture :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="Reorganizing your code…">
    <meta itemprop="datePublished" content="2020-03-20T10:53:05-05:00">
    <meta itemprop="dateModified" content="2023-08-11T11:18:05-05:00">
    <meta itemprop="wordCount" content="3">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>Game Architecture :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/07-game-architecture/index.html" rel="canonical" type="text/html" title="Game Architecture :: K-State CIS 580 Textbook">
    <link href="/cis580/07-game-architecture/index.xml" rel="alternate" type="application/rss+xml" title="Game Architecture :: K-State CIS 580 Textbook">
    <link href="/cis580/07-game-architecture/tele.html" rel="alternate" type="text/html" title="Game Architecture :: K-State CIS 580 Textbook">
    <link href="/cis580/07-game-architecture/embed.html" rel="alternate" type="text/html" title="Game Architecture :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1755628803" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1755628803" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/search.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1755628803";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/format-print.min.css?1755628803" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/07-game-architecture\/index.html';
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1755628803" rel="stylesheet">
  </head>
  <body class="mobile-support print" data-url="/cis580/07-game-architecture/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper"> 
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class="a11y-only"><a itemprop="item" href="/cis580/index.html"><span itemprop="name">CIS 580: Foundations of Game Programming</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">Game Architecture</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/ksu-cs-textbooks/cis580/edit/master/content/07-game-architecture/_index.md" rel="external" target="_blank" title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/07-game-architecture/index.print.html" title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/06-physics/05-physics-engines/index.html" title="Physics Engines (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/07-game-architecture/01-introduction/index.html" title="Introduction (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
            <div class="topbar-button topbar-button-embed" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/07-game-architecture/embed.html" title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a>
            </div>
            <div class="topbar-button topbar-button-tele" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/07-game-architecture/tele.html" title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a>
            </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 07-game-architecture" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="game-architecture">Game Architecture</h1>

<p>Reorganizing your code&hellip;</p>
<img src="https://media.giphy.com/media/caVdtPeN83dza/giphy.gif"/>
  <footer class="footline">
  </footer>
</article>
          <section>
            <h1 class="a11y-only">Subsections of Game Architecture</h1>
<article class="default">
  <header class="headline">
  </header>

<h1 id="introduction">Introduction</h1>

<p>Now that you&rsquo;ve moved through much of the foundations of building games, let&rsquo;s take a step back and talk about how to best <em>organize</em> that task.  After all, games are one of the most complex software systems you can build.  In the words of Jason Gregory, a game is:</p>
<blockquote>
<p>A soft real-time interactive agent-based simulation</p>
</blockquote>
<p>This means that not only do you need to process user input, update a simulated world, and then render that simulated world, you <em>also</em> have to do this in realtime (i.e. within 1/60th of a second)!  This is not a trivial challenge!</p>
<p>As with any software system, organization can go a long way to managing this complexity.  Consider this diagram of a AAA game engine&rsquo;s software architecture:</p>
<p><a href="#R-image-c862479cb942ec49d167304e44838575" class="lightbox-link"><img alt="Software Engine Architecture" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/7.1.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c862479cb942ec49d167304e44838575"><img alt="Software Engine Architecture" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/7.1.1.png"></a></p>
<p>Note how the engine is broken into systems and organized into layers.  Building an engine like this is outside the scope of this book (I encourage you to read Jason Gregory&rsquo;s <em>Game Engine Architecture</em> if you&rsquo;d like to delve into it), but the idea of loosely coupled systems is certainly something we can adapt.  Moreover, it is already explicitly supported by the MonoGame framework.  We&rsquo;ll explore how in this chapter.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="game-services">Game Services</h1>

<p>A common approach in software architecture for loose coupling of systems is the use of <em>services</em>.  Services are implemented with 1) a <em>service provider</em> - essentially a collection of services that can be searched for a service, and new services can be registered with, 2) interfaces that define specific services how to work with the service, and 3) classes that implement these interfaces. This is the <a href="https://gameprogrammingpatterns.com/service-locator.html" rel="external" target="_blank">Service Locator Pattern</a> as implemented in C#.</p>
<p>For a Service Provider, MonoGame provides the <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.GameServiceContainer.html" rel="external" target="_blank"><code>GameServiceContainer</code></a> class, and the <code>Game</code> class has one as its <code>Service</code> property.  The default game class adds at least two services: an <code>IGraphicsDeviceService</code> and an <code>IGraphicsDeviceManager</code>.  If we need to retrieve the graphics device for some reason we could use the code:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> gds = game.Services.GetService(<span style="color:#66d9ef">typeof</span>(IGraphicDeviceService));
</span></span><span style="display:flex;"><span>GraphicsDevice gd = gds.GraphicsDevice;</span></span></code></pre></div>
<p>We can add any service we want to with the <code>GameServicesContainer.AddService(Type type, object provider)</code>.  In effect, the <code>GameServicesContainer</code> acts as a dictionary for finding initialized instances of services you would use across the game.  For example, we might want to have a custom service for reporting achievements in the game.  Because the implementation would be different for the Xbox than the Playstation, we could define an interface to represent our type:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">IAchievementService</span> 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> RegisterAchievement(Achievement achievement);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Then we could author <em>two</em> classes implementing this interface, one for the Xbox and one for the Playstation.  We would initalize and register the appropriate one for the build of our program:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>game.Services.AddService(IAchievementService, <span style="color:#66d9ef">new</span> XBoxAchievementService());</span></span></code></pre></div>
<p>This provides us with that desirable &ldquo;loose coupling&rdquo;, where the only change we&rsquo;d need to make between the two builds is what achievement service we initialize.  A second common use for the <code>GameServicesContainer</code> is it can be passed to a constructor to provide multiple services as a single parameter, instead of having to pass each one separately.  It can also be held onto to retrieve the service at a later point in the execution, as is the case with the <code>ContentManager</code> constructor.</p>
<p>Game services are a good replacement for systems that you might otherwise use the <a href="https://gameprogrammingpatterns.com/singleton.html" rel="external" target="_blank">Singleton Pattern</a> to implement.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="game-components">Game Components</h1>

<p>A second useful decoupling pattern in MonoGame is the use of <em>game components</em>.  You&rsquo;ve probably noticed that many of the classes you have written have a similar pattern: they each have a <code>LoadContent()</code>, <code>Update()</code>, and <code>Draw()</code> method, and these often take the same arguments.  In your game class, you probably mostly invoke these methods for each class in turn.  MonoGame provides the concept of game components to help manage this task.  This involves: 1) a <code>GameComponentCollection</code> which game components are registered with, and components are implemented by extending the <code>GameComponent</code> or <code>DrawableGameComponent</code> base classes.</p>
<p>The <code>Game</code> implements a <code>GameCollection</code> in its <code>Components</code> property.  It will iterate through all components it holds, invoking the <code>Update()</code> and <code>Draw()</code> methods within the game loop.</p>
<h3 id="gamecomponent">GameComponent</h3>
<p>The <code>GameComponent</code> base class implements <code>IGameComponent</code>, <code>IUpdatable</code>, and <code>IDisposable</code> interfaces.  It has the following properties:</p>
<ul>
<li><code>Enabled</code> - this boolean indicates if the component will be updated</li>
<li><code>Game</code> - the game this component belongs to</li>
<li><code>UpdateOrder</code> - an integer used to sort the order in which game component&rsquo;s <code>Update()</code> method is invoked</li>
</ul>
<p>It also has the following virtual methods, which can be overridden:</p>
<ul>
<li><code>Dispose(bool disposing)</code> - Disposes of the component</li>
<li><code>Initialize()</code> - Initializes the component; used to set/load any non-graphical content; invoked during the game&rsquo;s initialization step</li>
<li><code>Update(GameTime gameTime)</code> - Invoked every pass through the game loop</li>
</ul>
<p>Finally, it also implements the following events:</p>
<ul>
<li><code>EnabledChanged</code> - triggered when the <code>Enabled</code> property changes</li>
<li><code>UpdateOrderChanged</code> - triggered when the <code>UpdateOrder</code> property changes</li>
</ul>
<h3 id="drawablegamecomponent">DrawableGameComponent</h3>
<p>The <code>DrawableGameComponent</code> inherits from the <code>GameComponent</code> base class, and additionally implements the <code>IDrawable</code> interface.  In addition to its inherited properties, it declares:</p>
<ul>
<li><code>DrawOrder</code> - an integer that determines the order game components are drawn in</li>
<li><code>GraphicsDevice</code> - the graphics device used to draw the game component</li>
<li><code>Visible</code> - a boolean that determines if the game component should be drawn</li>
</ul>
<p>It also has the additional virtual methods:</p>
<ul>
<li><code>LoadContent()</code> - Loads graphical content, invoked by the game during its content loading step</li>
<li><code>Draw(GameTime gameTime)</code> - Draws the game component, invoked during the game loop</li>
</ul>
<p>Finally, it implements the additional properties:</p>
<ul>
<li><code>DrawOrderChanged</code> - triggered when the <code>DrawOrder</code> property changes</li>
<li><code>VisibleChanged</code> - triggered when the <code>Visible</code> property changes</li>
</ul>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>The concept of Game Component espoused by MonoGame is <em>not</em> the same one defined by the <a href="https://gameprogrammingpatterns.com/component.html" rel="external" target="_blank">Component Pattern</a>, though it could potentially be leveraged to implement that pattern.</p>
  </div>
</details>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="game-screens">Game Screens</h1>

<p>XNA offered a sample building with these ideas that further organized a game into <em>screens</em> that has been <a href="https://github.com/tomizechsterson/game-state-management-monogame" rel="external" target="_blank">ported to MonoGame</a>.This was heavily influenced by Windows Phone, and includes gestures and &ldquo;tombstoning&rdquo; support.  A more simplified form is presented here.  It organizes a game into &ldquo;screens&rdquo;, each with its own logic and rendering, such as a menu, puzzle, cutscene, etc.</p>
<p>A scene manager game component manages a stack of these screens, and updates and renders the topmost.  Thus, from a gameplay screen, if we trigger a cutscene it would be pushed onto the stack, play, and then pop itself from the stack.  Similarly, pressing the &ldquo;menu&rdquo; button would push the menu screen onto the stack, leaving the player to interact with the menu instead of the game.  Screens manage their transition on and off this stack - and can incorporate visual effects into the transition.</p>
<h3 id="screenstate-enum">ScreenState Enum</h3>
<p>This enumeration represents the states a GameScreen can be in.</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Enumerations of the possible screen states</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> ScreenState
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    TransitionOn,
</span></span><span style="display:flex;"><span>    Active,
</span></span><span style="display:flex;"><span>    TransitionOff,
</span></span><span style="display:flex;"><span>    Hidden
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="gamescreen">GameScreen</h3>
<p>The <code>GameScreen</code> class is an abstract base class that represents a single screen.</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// A screen is a single layer of game content that has</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// its own update and draw logic and can be combined </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// with other layers to create complex menus or game</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// experiences</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">GameScreen</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Indicates if this screen is a popup</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;remarks&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Normally when a new screen is brought over another, </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// the covered screen will transition off.  However, this</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// bool indicates the covering screen is only a popup, and </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// the covered screen will remain partially visible</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/remarks&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsPopup { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The amount of time taken for this screen to transition on</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> TimeSpan TransitionOnTime {<span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>;} = TimeSpan.Zero;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The amount of time taken for this screen to transition off</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> TimeSpan TransitionOffTime {<span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>;} = TimeSpan.Zero;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The screen&#39;s position in the transition</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;value&gt;Ranges from 0 to 1 (fully on to fully off)&lt;/value&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">float</span> TransitionPosition { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; } = <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The alpha value based on the current transition position</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">float</span> TransitionAlpha =&gt; <span style="color:#ae81ff">1f</span> - TransitionPosition;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The current state of the screen</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ScreenState ScreenState { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; } = ScreenState.TransitionOn;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Indicates the screen is exiting for good (not simply obscured)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;remarks&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// There are two possible reasons why a screen might be transitioning</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// off. It could be temporarily going away to make room for another</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// screen that is on top of it, or it could be going away for good.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// This property indicates whether the screen is exiting for real:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// if set, the screen will automatically remove itself as soon as the</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// transition finishes.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/remarks&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsExiting { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Indicates if this screen is active</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsActive =&gt; !_otherScreenHasFocus &amp;&amp; (
</span></span><span style="display:flex;"><span>        ScreenState == ScreenState.TransitionOn ||
</span></span><span style="display:flex;"><span>        ScreenState == ScreenState.Active);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">bool</span> _otherScreenHasFocus;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The ScreenManager in charge of this screen</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ScreenManager ScreenManager { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">internal</span> <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Gets the index of the player who is currently controlling this screen,</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// or null if it is accepting input from any player. </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;remarks&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// This is used to lock the game to a specific player profile. The main menu </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// responds to input from any connected gamepad, but whichever player makes </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// a selection from this menu is given control over all subsequent screens, </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// so other gamepads are inactive until the controlling player returns to the </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// main menu.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/remarks&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> PlayerIndex? ControllingPlayer { <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Activates the screen.  Called when the screen is added to the screen manager </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// or the game returns from being paused.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Activate() { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Deactivates the screen.  Called when the screen is removed from the screen manager </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// or when the game is paused.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Deactivate() { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Unloads content for the screen. Called when the screen is removed from the screen manager</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Unload() { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Updates the screen. Unlike HandleInput, this method is called regardless of whether the screen</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// is active, hidden, or in the middle of a transition.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime, <span style="color:#66d9ef">bool</span> otherScreenHasFocus, <span style="color:#66d9ef">bool</span> coveredByOtherScreen)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _otherScreenHasFocus = otherScreenHasFocus;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (IsExiting)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// If the screen is going away forever, it should transition off</span>
</span></span><span style="display:flex;"><span>            ScreenState = ScreenState.TransitionOff;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (!UpdateTransitionPosition(gameTime, TransitionOffTime, <span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>                ScreenManager.RemoveScreen(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(coveredByOtherScreen)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// if the screen is covered by another, it should transition off</span>
</span></span><span style="display:flex;"><span>            ScreenState = UpdateTransitionPosition(gameTime, TransitionOffTime, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                ? ScreenState.TransitionOff
</span></span><span style="display:flex;"><span>                : ScreenState.Hidden;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Otherwise the screen should transition on and become active.</span>
</span></span><span style="display:flex;"><span>            ScreenState = UpdateTransitionPosition(gameTime, TransitionOnTime, -<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>                ? ScreenState.TransitionOn
</span></span><span style="display:flex;"><span>                : ScreenState.Active;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Updates the TransitionPosition property based on the time</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;gameTime&#34;&gt;an object representing time in the game&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;time&#34;&gt;The amount of time the transition should take&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;direction&#34;&gt;The direction of the transition&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;returns&gt;true if still transitioning, false if the transition is done&lt;/returns&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">bool</span> UpdateTransitionPosition(GameTime gameTime, TimeSpan time, <span style="color:#66d9ef">int</span> direction)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// How much should we move by?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">float</span> transitionDelta = (time == TimeSpan.Zero)
</span></span><span style="display:flex;"><span>            ? <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            : (<span style="color:#66d9ef">float</span>)(gameTime.ElapsedGameTime.TotalMilliseconds / time.TotalMilliseconds);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Update the transition time</span>
</span></span><span style="display:flex;"><span>        TransitionPosition += transitionDelta * direction;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Did we reach the end of the transition?</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(direction &lt; <span style="color:#ae81ff">0</span> &amp;&amp; TransitionPosition &lt;= <span style="color:#ae81ff">0</span> || direction &gt; <span style="color:#ae81ff">0</span> &amp;&amp; TransitionPosition &gt;= <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            TransitionPosition = MathHelper.Clamp(TransitionPosition, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// if not, we are still transitioning</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Handles input for this screen.  Only called when the screen is active,</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// and not when another screen has taken focus.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;gameTime&#34;&gt;An object representing time in the game&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;input&#34;&gt;An object representing input&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> HandleInput(GameTime gameTime, InputState input) { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Draws the GameScreen.  Only called with the screen is active, and not </span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// when another screen has taken the focus.</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;gameTime&#34;&gt;An object representing time in the game&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime) { }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// This method tells the screen to exit, allowing it time to transition off</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> ExitScreen()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (TransitionOffTime == TimeSpan.Zero)
</span></span><span style="display:flex;"><span>            ScreenManager.RemoveScreen(<span style="color:#66d9ef">this</span>);    <span style="color:#75715e">// If the screen has a zero transition time, remove it immediately</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            IsExiting = <span style="color:#66d9ef">true</span>;    <span style="color:#75715e">// Otherwise flag that it should transition off and then exit.</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h4 id="screenmanager">ScreenManager</h4>
<p>The <code>ScreenManager</code> class manages the screens, updating and drawing only when appropriate.</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// The ScreenManager is a component which manages one or more GameScreen instance.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// It maintains a stack of screens, calls their Update and Draw methods when </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// appropriate, and automatically routes input to the topmost screen.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ScreenManager</span> : DrawableGameComponent
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> List&lt;GameScreen&gt; _screens = <span style="color:#66d9ef">new</span> List&lt;GameScreen&gt;();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> List&lt;GameScreen&gt; _tmpScreensList = <span style="color:#66d9ef">new</span> List&lt;GameScreen&gt;();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> ContentManager _content;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> InputState _input = <span style="color:#66d9ef">new</span> InputState();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">bool</span> _isInitialized;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// A SpriteBatch shared by all GameScreens</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> SpriteBatch SpriteBatch { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// A SpriteFont shared by all GameScreens</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> SpriteFont MenuFont { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Constructs a new ScreenManager</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;game&#34;&gt;The game this ScreenManager belongs to&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> ScreenManager(Game game) : <span style="color:#66d9ef">base</span>(game) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        _content = <span style="color:#66d9ef">new</span> ContentManager(game.Services, <span style="color:#e6db74">&#34;Content&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Initializes the ScreenManager</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Initialize()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">base</span>.Initialize();
</span></span><span style="display:flex;"><span>        _isInitialized = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Loads content for the ScreenManager and its screens</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> LoadContent()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        SpriteBatch = <span style="color:#66d9ef">new</span> SpriteBatch(GraphicsDevice);
</span></span><span style="display:flex;"><span>        MenuFont = _content.Load&lt;SpriteFont&gt;(<span style="color:#e6db74">&#34;MenuFont&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Tell each of the screens to load thier content </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">foreach</span>(<span style="color:#66d9ef">var</span> screen <span style="color:#66d9ef">in</span> _screens)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            screen.Activate();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Unloads content for the ScreenManager&#39;s screens</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> UnloadContent()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">foreach</span>(<span style="color:#66d9ef">var</span> screen <span style="color:#66d9ef">in</span> _screens)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            screen.Unload();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Updates all screens managed by the ScreenManager</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;gameTime&#34;&gt;An object representing time in the game&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Read in the keyboard and gamepad</span>
</span></span><span style="display:flex;"><span>        _input.Update();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Make a copy of the screen list, to avoid confusion if </span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// the process of updating a screen adds or removes others</span>
</span></span><span style="display:flex;"><span>        _tmpScreensList.Clear();
</span></span><span style="display:flex;"><span>        _tmpScreensList.AddRange(_screens);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> otherScreenHasFocus = !Game.IsActive;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">bool</span> coveredByOtherScreen = <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(_tmpScreensList.Count &gt; <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// Pop the topmost screen </span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">var</span> screen = _tmpScreensList[_tmpScreensList.Count - <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>            _tmpScreensList.RemoveAt(_tmpScreensList.Count - <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            screen.Update(gameTime, otherScreenHasFocus, coveredByOtherScreen);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (screen.ScreenState == ScreenState.TransitionOn || screen.ScreenState == ScreenState.Active)
</span></span><span style="display:flex;"><span>            {
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// if this is the first active screen, let it handle input </span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (!otherScreenHasFocus)
</span></span><span style="display:flex;"><span>                {
</span></span><span style="display:flex;"><span>                    screen.HandleInput(gameTime, _input);
</span></span><span style="display:flex;"><span>                    otherScreenHasFocus = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// if this is an active non-popup, all subsequent </span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">// screens are covered </span>
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (!screen.IsPopup) coveredByOtherScreen = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Draws the appropriate screens managed by the SceneManager</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;gameTime&#34;&gt;An object representing time in the game&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">foreach</span>(<span style="color:#66d9ef">var</span> screen <span style="color:#66d9ef">in</span> _screens)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (screen.ScreenState == ScreenState.Hidden) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            screen.Draw(gameTime);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Adds a screen to the ScreenManager</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;param name=&#34;screen&#34;&gt;The screen to add&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> AddScreen(GameScreen screen)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        screen.ScreenManager = <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        screen.IsExiting = <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If we have a graphics device, tell the screen to load content</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (_isInitialized) screen.Activate();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        _screens.Add(screen);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> RemoveScreen(GameScreen screen)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If we have a graphics device, tell the screen to unload its content </span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (_isInitialized) screen.Unload();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        _screens.Remove(screen);
</span></span><span style="display:flex;"><span>        _tmpScreensList.Remove(screen);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// Exposes an array holding all the screens managed by the ScreenManager</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;returns&gt;An array containing references to all current screens&lt;/returns&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> GameScreen[] GetScreens()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> _screens.ToArray();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="other-changes">Other Changes</h3>
<p>This sample also uses the <code>InputState</code> class <a href="https://textbooks.cs.ksu.edu/cis580/02-player-input/07-input-state/" rel="external" target="_blank">introduced in chapter 7</a>.  In your game class, you need to create the <code>ScreenManager</code>, and then add your custom screen classes, which can be done in your constructor or <code>Initialize()</code> method:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> screenManager = <span style="color:#66d9ef">new</span> ScreenManager(<span style="color:#66d9ef">this</span>);
</span></span><span style="display:flex;"><span>screenManager.AddScreen(<span style="color:#66d9ef">new</span> ExampleScreenA());
</span></span><span style="display:flex;"><span>screenManager.AddScreen(<span style="color:#66d9ef">new</span> ExampleScreenB());
</span></span><span style="display:flex;"><span>...</span></span></code></pre></div>
<p>Once added, the screen&rsquo;s <code>Initialize</code>, <code>LoadContent()</code>, <code>Update()</code>, and <code>Draw()</code> methods will all be invoked automatically as appropriate by the <code>Game</code> class.</p>
<p>It might also make sense to register the <code>ScreenManager</code> as a service, especially if you expect to add additional screens as the game is running:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// From within your Game class</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">this</span>.Services.AddService(<span style="color:#66d9ef">typeof</span>(ScreenManager), screenManager);</span></span></code></pre></div>
<p>Screens can be added at any time, which pushes them to the top of the stack - a common use would be to open a menu or submenu.</p>
<p>You can also stack as many screens as you like at the start of the game - you might arrange a multilevel game this way:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>screenManager.AddScreen(<span style="color:#66d9ef">new</span> CreditsScreen());
</span></span><span style="display:flex;"><span>screenManager.AddScreen(<span style="color:#66d9ef">new</span> Level8Screen());
</span></span><span style="display:flex;"><span>screenManager.AddScreen(<span style="color:#66d9ef">new</span> Level7Screen());
</span></span><span style="display:flex;"><span>screenManager.AddScreen(<span style="color:#66d9ef">new</span> Level6Screen());
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>screenManager.AddScreen(<span style="color:#66d9ef">new</span> Level1Screen());
</span></span><span style="display:flex;"><span>screenManager.AddScreen(<span style="color:#66d9ef">new</span> OpeningScreen());</span></span></code></pre></div>
<p>And invoke each screen&rsquo;s <code>ExitScreen()</code> when the level is completed.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="summary">Summary</h1>

<p>In this chapter we explored some new tools for organizing our game code.  We learned about how MonoGame utilizes services to provide loosely-coupled access between a service provider and consumer.  We also saw how the MonoGame concept of Game Components works, and how we can define custom game components and add them to the <code>Game.Component</code> collection.  Finally, we explored one further organization tool in the Game Screen concept from the XNA GameStateManagement sample.  Each of these can help make larger games easier to build and maintain.</p>

  <footer class="footline">
  </footer>
</article>
          </section>
        </div>
      </main>
<div class="git-footer">
  <p class="theme-version-footer">8.0.0</p>
<p>Last modified by:
              <i class='fa-fw fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cis580/commit/43f194969a638fa4572819da4b31060ad574a9ce">Aug 11, 2023</a>
</p>

</div>
    </div>
    <script src="/cis580/js/clipboard/clipboard.min.js?1755628803" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1755628803" defer></script>
    <script src="/cis580/js/theme.min.js?1755628803" defer></script>
  </body>
</html>
