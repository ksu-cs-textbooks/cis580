




	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Collisions on K-State CIS 580 Textbook</title>
    <link>https://ksu-cs-textbooks.github.io/cis580/04-collisions/index.html</link>
    <description>Recent content in Collisions on K-State CIS 580 Textbook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Aug 2018 10:53:05 -0500</lastBuildDate><atom:link href="https://ksu-cs-textbooks.github.io/cis580/04-collisions/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/04-collisions/01-introduction/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/04-collisions/01-introduction/index.html</guid>
      <description>At the heart of every game design is interaction - interaction between the player and a simulated game world. This simulation imposes rules about how interaction is allowed to unfold, and in nearly all cases is built upon the mechanism of collision detection - detecting when one sprite touches or overlaps another within the game world.
Consider the basic mechanics of many classic games:
In Space Invaders, bullets from the player’s turret destroy invading aliens, while alien’s bullets chew away the player’s shields and kill the player if they strike him or her.</description>
    </item>
    <item>
      <title>Collision Shapes</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/04-collisions/02-collision-shapes/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/04-collisions/02-collision-shapes/index.html</guid>
      <description>Perhaps the most straightforward approach is the use of a collision shape (also called a collision primitive or bounding area). This is a simplified representation of the sprite - simplified in a way that allows for easy mathematical detection of collision events. The collision shape mimics the shape of the overall sprite:
For a good visualization of collision shapes and the mathematics behind the collision detection, visit Jeffrey Thompson&amp;rsquo;s Collision Detection Page Thus, circular sprites are represented by circles, and rectangular sprites by rectangles.</description>
    </item>
    <item>
      <title>Collision Helper</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/04-collisions/03-collision-helper/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/04-collisions/03-collision-helper/index.html</guid>
      <description>There are many ways we could organize the methods we saw in the previous section, but one particularly apt one is to organize them into a static helper class, much like our Math and MathHelper classes, i.e. CollisionHelper:
/// &amp;lt;summary&amp;gt; /// A class containing collision detection methods /// &amp;lt;/summary&amp;gt; public static class CollisionHelper { /// &amp;lt;summary&amp;gt; /// Detects a collision between two points /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&amp;#34;p1&amp;#34;&amp;gt;the first point&amp;lt;/param&amp;gt; /// &amp;lt;param name=&amp;#34;p2&amp;#34;&amp;gt;the second point&amp;lt;/param&amp;gt; /// &amp;lt;returns&amp;gt;true when colliding, false otherwise&amp;lt;/returns&amp;gt; public static bool Collides(BoundingPoint p1, BoundingPoint p2) { return p1.</description>
    </item>
    <item>
      <title>Separating Axis Theorem</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/04-collisions/04-separating-axis-theorem/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/04-collisions/04-separating-axis-theorem/index.html</guid>
      <description>But what about sprites with shapes don&amp;rsquo;t map to a circle or rectangle, such as this spaceship sprite:
We could represent this sprite with a bounding polygon:
The polygon can be represented as a data structure using a collection of vectors from its origin (the same origin we use in rendering the sprite) to the points defining its corners:
/// &amp;lt;summary&amp;gt; /// A struct representing a convex bounding polygon /// &amp;lt;/summary&amp;gt; public struct BoundingPolygon { /// &amp;lt;summary&amp;gt; /// The corners of the bounding polygon, /// in relation to its origin /// &amp;lt;/summary&amp;gt; public IEnumerable&amp;lt;Vector2&amp;gt; Corners; /// &amp;lt;summary&amp;gt; /// The center of the polygon in the game world /// &amp;lt;/summary&amp;gt; public Vector2 Center; }But can we detect collisions between arbitrary polygons?</description>
    </item>
    <item>
      <title>Per-Pixel Collision Detection</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/04-collisions/05-per-pixel/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/04-collisions/05-per-pixel/index.html</guid>
      <description>Another brute-force approach that can be used with raster graphics when a high degree of accuracy is needed is per-pixel collision detection. This process assumes that a portion of the raster graphics being examined are composed of transparent pixels (i.e. not a part of the object portrayed).
Consider the figure above - there are two raster graphics that overlap. To determine if they collide on a per-pixel basis, we must compare every overlapping pixel between the two images (the purple area).</description>
    </item>
    <item>
      <title>Multiphase Collision Detection</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/04-collisions/06-multiphase/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/04-collisions/06-multiphase/index.html</guid>
      <description>It should be clear that the per-pixel and SAT-based approaches can become very computationally expensive. For this reason, games that need fine-grained collision detection often resort to a multi-phase approach, which utilizes two or more processing passes. Each pass uses an increasingly sophisticated (and therefore costly) collision detection algorithm to find collisions, but only tests those objects that previous passes identified as “possibly colliding”. The more simple methods employed in the first few passes typically can reject a great deal of possible collisions, reducing the number of more expensive comparisons that will be tried later.</description>
    </item>
    <item>
      <title>Summary</title>
      <link>https://ksu-cs-textbooks.github.io/cis580/04-collisions/07-summary/index.html</link>
      <pubDate>Fri, 24 Aug 2018 10:53:26 -0500</pubDate>
      <guid>https://ksu-cs-textbooks.github.io/cis580/04-collisions/07-summary/index.html</guid>
      <description>In this chapter we looked at implementing collision detection using bounding shapes, the separating axis theorem, and per-pixel evaluation. We discussed the merits of the different approaches, and saw how multiphase collision detection can avoid expensive collision detection tests.
There are other techniques we can use to avoid unneeded collision tests as well. We&amp;rsquo;ll talk about one of these, spatial partitioning in an upcoming chapter.</description>
    </item>
  </channel>
</rss>