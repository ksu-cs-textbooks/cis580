<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="Perhaps the most common use of transforms with the sprite batch is to support screen scrolling, i.e. shifting the viewport (the visible part of the game world) around to allow for larger game worlds.
Consider what it would take to shift the game world using just what we’ve learned about sprites. We’d need to keep track of an offset for where the viewport begins relative to the world:
Then, when we draw our game objects (like sprites), we’d need to add this offset vector to the position of each as we draw them:">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="Screen Scrolling :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="Perhaps the most common use of transforms with the sprite batch is to support screen scrolling, i.e. shifting the viewport (the visible part of the game world) around to allow for larger game worlds.
Consider what it would take to shift the game world using just what we’ve learned about sprites. We’d need to keep track of an offset for where the viewport begins relative to the world:
Then, when we draw our game objects (like sprites), we’d need to add this offset vector to the position of each as we draw them:">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/03-screen-scrolling/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Screen Scrolling :: K-State CIS 580 Textbook">
    <meta property="og:description" content="Perhaps the most common use of transforms with the sprite batch is to support screen scrolling, i.e. shifting the viewport (the visible part of the game world) around to allow for larger game worlds.
Consider what it would take to shift the game world using just what we’ve learned about sprites. We’d need to keep track of an offset for where the viewport begins relative to the world:
Then, when we draw our game objects (like sprites), we’d need to add this offset vector to the position of each as we draw them:">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="SpriteBatch Transforms">
    <meta property="article:published_time" content="2020-03-20T10:53:05-05:00">
    <meta property="article:modified_time" content="2023-08-11T11:18:05-05:00">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="Screen Scrolling :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="Perhaps the most common use of transforms with the sprite batch is to support screen scrolling, i.e. shifting the viewport (the visible part of the game world) around to allow for larger game worlds.
Consider what it would take to shift the game world using just what we’ve learned about sprites. We’d need to keep track of an offset for where the viewport begins relative to the world:
Then, when we draw our game objects (like sprites), we’d need to add this offset vector to the position of each as we draw them:">
    <meta itemprop="datePublished" content="2020-03-20T10:53:05-05:00">
    <meta itemprop="dateModified" content="2023-08-11T11:18:05-05:00">
    <meta itemprop="wordCount" content="744">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>Screen Scrolling :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/03-screen-scrolling/index.html" rel="canonical" type="text/html" title="Screen Scrolling :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/03-screen-scrolling/index.xml" rel="alternate" type="application/rss+xml" title="Screen Scrolling :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/03-screen-scrolling/index.print.html" rel="alternate" type="text/html" title="Screen Scrolling :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/03-screen-scrolling/tele.html" rel="alternate" type="text/html" title="Screen Scrolling :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1756153111" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1756153111" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1756153111" defer></script>
    <script src="/cis580/js/search.min.js?1756153111" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1756153111";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1756153111" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1756153111" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1756153111" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1756153111" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1756153111" rel="stylesheet">
    <link href="/cis580/css/format-html.min.css?1756153111" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/08-spritebatch-transforms\/03-screen-scrolling\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1756153111" rel="stylesheet">
  </head>
  <body class="mobile-support embed html" data-url="/cis580/08-spritebatch-transforms/03-screen-scrolling/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 08-spritebatch-transforms" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="screen-scrolling">Screen Scrolling</h1>

<p>Perhaps the most common use of transforms with the sprite batch is to support <em>screen scrolling</em>, i.e. shifting the viewport (the visible part of the game world) around to allow for larger game worlds.</p>
<p>Consider what it would take to shift the game world using just what we&rsquo;ve learned about sprites.  We&rsquo;d need to keep track of an offset for where the viewport begins relative to the world:</p>
<p><a href="#R-image-21db9d732136d84300615cb5c15d7be4" class="lightbox-link"><img alt="The Game World and Viewport" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/8.3.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-21db9d732136d84300615cb5c15d7be4"><img alt="The Game World and Viewport" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/8.3.1.png"></a></p>
<p>Then, when we draw our game objects (like sprites), we&rsquo;d need to add this offset vector to the position of <em>each</em> as we draw them:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    spriteBatch.Begin();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">foreach</span>(<span style="color:#66d9ef">var</span> sprite <span style="color:#66d9ef">in</span> Sprites)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        spriteBatch.Draw(sprite.Texture, sprite.Position + offset, Color.White);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>This doesn&rsquo;t look too bad&hellip; but what about when we use a different <code>SpriteBatch.Draw()</code> override?  Or we position some sprites with a <code>Rectangle</code> instead of a <code>Vector2</code>?  We now need to start handling special cases, which can make our code quite a bit more complex and difficult to read.</p>
<p>However, the <code>SpriteBatch.Begin()</code> call takes an optional transformation matrix as a parameter, and applies its transform to <em>all</em> sprites drawn within the batch.  Thus, we can create a single transformation matrix to represent our offset, and apply it to the <code>SpriteBatch</code>.  Then we can use whatever <code>SpriteBatch.Draw()</code> override we want, and we don&rsquo;t need to worry about adjusting positioning of sprites - we just draw them where they go in the world, and the <code>SpriteBatch</code> only draws the portion of the world we want to show:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw game sprites within the world, however you need to.</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="auto-scrolling">Auto-Scrolling</h3>
<p>To build an auto-scrolling game (one where the screen is constantly scrolling at a set speed), you simply need to update the offset vector every frame, just as you would any moving object.  For example, to auto-scroll the screen vertically at a constant speed, we could use:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Vertical auto-scrolling</span>
</span></span><span style="display:flex;"><span>    offset.Y += Vector2.UnitY * (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalSeconds * SCROLL_SPEED;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw game sprites within the world, however you need to.</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>You can of course vary the scrolling speed as well - perhaps scrolling faster as the game progresses, or varying scrolling speed based on some player state (like firing thrusters).</p>
<h3 id="player-synched-scrolling">Player-Synched Scrolling</h3>
<p>A second possibility is to keep the player centered in the screen by scrolling the world around them.  For this, you need to know a vector from the player to the origin of the screen (<code>PlayerOffset</code>) and the position of the player in the world (<code>PlayerPosition</code>).  The <code>ViewportOffset</code> is the difference of these:</p>
<p><a href="#R-image-1eaeb0d0a818f974cfb718e2c1a496dd" class="lightbox-link"><img alt="Player-synched Scrolling" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/8.3.2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1eaeb0d0a818f974cfb718e2c1a496dd"><img alt="Player-synched Scrolling" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/8.3.2.png"></a></p>
<p>Thus, each frame you update the offset vector based on the offset and the player&rsquo;s current position in the world:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Player-synched scrolling</span>
</span></span><span style="display:flex;"><span>    offset = PlayerOffset - Player.Position;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw game sprites within the world, however you need to.</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>If we want our player to be able to reach the edge of the screen without the &ldquo;blank space&rdquo; at the edge of the game world showing, we can clamp the offset vector to a region defined by a <code>MinScroll</code> and <code>MaxScroll</code> vector:</p>
<p><a href="#R-image-662be1817b009a8fe9882ca7daa6f770" class="lightbox-link"><img alt="Clamped Player-Synched Scrolling" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/8.3.3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-662be1817b009a8fe9882ca7daa6f770"><img alt="Clamped Player-Synched Scrolling" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/8.3.3.png"></a></p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Player-synched scrolling</span>
</span></span><span style="display:flex;"><span>    offset = Player.Position - PlayerOffset;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Clamp the resulting vector to the visible region</span>
</span></span><span style="display:flex;"><span>    offset = Vector2.Clamp(offset, MinScroll, MaxScroll);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw game sprites within the world, however you need to.</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="visibility-culling">Visibility Culling</h3>
<p>Regardless of how we determine what part of the game world is visible, we only need to draw the content (i.e. sprites) that fall within that region.  If we invoke <code>SpriteBatch.Draw()</code> for items that fall off-screen, we create extra, unnecessary work.  It can be helpful to use some form of the <a href="https://gameprogrammingpatterns.com/spatial-partition.html" rel="external" target="_blank">Spatial Partition Pattern</a> to identify the objects that fall on-screen, and only attempt to draw those.</p>
<p>Once we have spatial partitioning set up, we may also choose to only <em>update</em> game objects that fall on-screen (or near to the screen) as a further optimization.</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script src="/cis580/js/clipboard/clipboard.min.js?1756153111" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1756153111" defer></script>
    <script src="/cis580/js/theme.min.js?1756153111" defer></script>
  <script src="/cis580/js/embed-iframe.min.js?1756153111" defer></script>
  </body>
</html>
