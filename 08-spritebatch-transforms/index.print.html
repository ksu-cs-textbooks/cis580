<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="Moving in placeâ€¦">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="SpriteBatch Transforms :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="Moving in placeâ€¦">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="SpriteBatch Transforms :: K-State CIS 580 Textbook">
    <meta property="og:description" content="Moving in placeâ€¦">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="SpriteBatch Transforms :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="Moving in placeâ€¦">
    <meta itemprop="datePublished" content="2020-03-20T10:53:05-05:00">
    <meta itemprop="dateModified" content="2023-08-11T11:18:05-05:00">
    <meta itemprop="wordCount" content="3">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>SpriteBatch Transforms :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/index.html" rel="canonical" type="text/html" title="SpriteBatch Transforms :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/index.xml" rel="alternate" type="application/rss+xml" title="SpriteBatch Transforms :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/tele.html" rel="alternate" type="text/html" title="SpriteBatch Transforms :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/embed.html" rel="alternate" type="text/html" title="SpriteBatch Transforms :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1755628803" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1755628803" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/search.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1755628803";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/format-print.min.css?1755628803" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/08-spritebatch-transforms\/index.html';
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1755628803" rel="stylesheet">
  </head>
  <body class="mobile-support print" data-url="/cis580/08-spritebatch-transforms/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper"> 
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class="a11y-only"><a itemprop="item" href="/cis580/index.html"><span itemprop="name">CIS 580: Foundations of Game Programming</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">SpriteBatch Transforms</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/ksu-cs-textbooks/cis580/edit/master/content/08-spritebatch-transforms/_index.md" rel="external" target="_blank" title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/08-spritebatch-transforms/index.print.html" title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/07-game-architecture/05-summary/index.html" title="Summary (ðŸ¡)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/08-spritebatch-transforms/01-introduction/index.html" title="Introduction (ðŸ¡’)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
            <div class="topbar-button topbar-button-embed" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/08-spritebatch-transforms/embed.html" title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a>
            </div>
            <div class="topbar-button topbar-button-tele" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/08-spritebatch-transforms/tele.html" title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a>
            </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 08-spritebatch-transforms" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="spritebatch-transforms">SpriteBatch Transforms</h1>

<p>Moving in place&hellip;</p>
<img src="https://media.giphy.com/media/3o85xzkvl1siB2rHSo/giphy.gif"/>
  <footer class="footline">
  </footer>
</article>
          <section>
            <h1 class="a11y-only">Subsections of SpriteBatch Transforms</h1>
<article class="default">
  <header class="headline">
  </header>

<h1 id="introduction">Introduction</h1>

<p>When we introduced the <code>SpriteBatch</code>, we mentioned that the <code>SpriteBatch.Begin()</code> had some additional arguments we could take advantage of.  One of these is for a <em>transformation matrix</em>.   This is a matrix that represents the transformation applied to convert the 3D world representation into two dimensions (remember, in MonoGame we&rsquo;re using 3D hardware to render a 2D game).  For many games, the default setting for this transformation matrix is fine - but if we override this, we can create many powerful effects, including:</p>
<ul>
<li>Adding scrolling to our game world with minimal disruption to our current code</li>
<li>Adding <em>parallax scrolling</em> to our game world (where different layers scroll at different speeds, simulating depth)</li>
<li>Creating interesting visual effects like zooming, spinning, or shaking our game scene</li>
<li>Automatically scaling our game for full-screen presentation</li>
</ul>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="transforms">Transforms</h1>

<p>Before we delve into using the SpriteBatch, let&rsquo;s quickly revisit the concept of Transformations using Matrices.  Our MonoGame games use 3D hardware to render 2D scenes, and the individual sprites are represented as textured quads - a polygon consisting of two triangles arranged in a rectangle.  The SpriteBatch computes the coordinates of the corners of this quad from the <code>SpriteBatch.Draw()</code> parameters.  These vectors are then <em>transformed</em> for the final drawing process by multiplying them by a matrix specified in the <code>SpriteBatch.Begin()</code> method.</p>
<p>By default, the matrix used by the <code>SpriteBatch</code> is the <em>identity</em> matrix:</p>
<span class="math align-center">$$ 
I = \begin{vmatrix} 1 & 0 & 0 & 0 \\\ 0 & 1 & 0 & 0 \\\ 0 & 0 & 1 & 0 \\\ 0 & 0 & 0 & 1 \end{vmatrix}
 $$</span>
<p>Any vector multiplied by this matrix will be the same vector (This is why it is called the identity matrix, by the way):</p>
<span class="math align-center">$$ 
V_i = V_0 * I = \begin{vmatrix} 4 \\\ 3 \\\ 8 \\\ 1\end{vmatrix} * \begin{vmatrix} 1 & 0 & 0 & 0 \\\ 0 & 1 & 0 & 0 \\\ 0 & 0 & 1 & 0 \\\ 0 & 0 & 0 & 1 \end{vmatrix} = \begin{vmatrix}4 \\\ 3 \\\ 8 \\\ 1 \end{vmatrix}
 $$</span>
<p>But we can substitute a <em>different</em> matrix for the identity matrix.  The most common includes <em>scaling</em>, <em>translation</em>, and <em>rotation</em> matrices.  While it is possible to define the transformation matrices by hand by calling the <code>Matrix</code> constructor, MonoGame provides several methods for creating specific transformation matrices.</p>
<h3 id="scale">Scale</h3>
<p>A Scale matrix is similar to the Identity matrix, but instead of 1s on the diagonal, it provides scaling values:</p>
<span class="math align-center">$$ 
S = \begin{vmatrix} x & 0 & 0 & 0 \\\ 0 & y & 0 & 0 \\\ 0 & 0 & z & 0 \\\ 0 & 0 & 0 & 1 \end{vmatrix}
 $$</span>
<p>Any vector multiplied by this matrix will have its components scaled correspondingly:</p>
<span class="math align-center">$$ 
V_s = V_0 * S = \begin{vmatrix} 4\\\ 3\\\ 8\\\ 1\end{vmatrix} * \begin{vmatrix} x & 0 & 0 & 0\\\ 0 & y & 0 & 0 \\\ 0 & 0 & z & 0 \\\ 0 & 0 & 0 & 1 \end{vmatrix} = \begin{vmatrix}4x\\\ 3y\\\ 8z\\\ 1\end{vmatrix}
 $$</span>
<p>In MonoGame, a scale matrix can be created with one of the following methods:</p>
<ul>
<li><code>Matrix.CreateScale(float x, float y, float z)</code> - A scaling matrix using x, y, and z to scale in the corresponding axes</li>
<li><code>Matrix.CreateScale(Vector3 scale)</code> - A scaling matrix using the x, y, and z components of the Vector3 to scale in the corresponding axes</li>
<li><code>Matrix.CreateScale(float scale)</code> - A scaling matrix that scales equally along the x, y, and z axis by the scale provided</li>
</ul>
<h3 id="translation">Translation</h3>
<p>A Translation matrix also begins with an identity matrix, and adds translation values in the x, y, and z in the fourth row (which is why transforms for 3D math use 4x4 matrices):</p>
<span class="math align-center">$$ 
T = \begin{vmatrix} 1 & 0 & 0 & 0\\\ 0 & 1 & 0 & 0 \\\ 0 & 0 & 1 & 0 \\\ t_x & t_y & t_z & 1 \end{vmatrix}
 $$</span>
<p>Any vector multiplied by this matrix will have its components translated accordingly:</p>
<span class="math align-center">$$ 
V_t = V_0 * T = \begin{vmatrix}4\\\ 3\\\ 8\\\ 1\end{vmatrix} * \begin{vmatrix} 1 & 0 & 0 & 0\\\ 0 & 1 & 0 & 0 \\\ 0 & 0 & 1 & 0 \\\ t_x & t_y & t_z & 1 \end{vmatrix} = \begin{vmatrix}4+t_x\\\ 3+t_y\\\ 8+t_z\\\ 1\end{vmatrix}
 $$</span>
<h3 id="rotation">Rotation</h3>
<p>A rotation matrix is a bit more involved, and there are separate matrices for each primary axis.  In a 2D game, we typically only rotate around the z-axis, whose rotation matrix is:</p>
<span class="math align-center">$$ 
R_z = \begin{vmatrix} \cos{\theta} & \sin{\theta} & 0 & 0\\\ -\sin{\theta} & \cos{\theta} & 0 & 0 \\\ 0 & 0 & 1 & 0 \\\ 0 & 0 & 0 & 1 \end{vmatrix}
 $$</span>
<p>Here <span class="math align-center">$ \theta $</span> is the rotation measured in radians in the clockwise direction.</p>
<p>In MonoGame, a z-Rotation matrix can be created with one of the following method:</p>
<ul>
<li><code>Matrix.CreateRotationZ(float angle)</code> - A rotation matrix about the z-axis using the supplied angle</li>
</ul>
<p>Additionally, rotations about the x and y axes can be created with:</p>
<ul>
<li><code>Matrix.CreateRotationX(float angle)</code> - A rotation matrix about the x-axis using the supplied angle</li>
<li><code>Matrix.CreateRotationY(float angle)</code> - A rotation matrix about the y-axis using the supplied angle</li>
</ul>
<h3 id="composite-transformations">Composite Transformations</h3>
<p>Moreover, we can <em>combine</em> multiple operations by multiplying their matrices together.  I.e. given the translation matrix <span class="math align-center">$ T $</span> and the rotation matrix <span class="math align-center">$ R $</span>, we could apply the translation followed by the rotation by computing a composite matrix <span class="math align-center">$ C $</span> that combines the operations:</p>
<span class="math align-center">$$ 
C = T * R
 $$</span>
<p>In MonoGame we can multiply matrices with <code>Matrix.Multiply()</code> or by using the <code>*</code> operator.  I.e. to perform the translation described above we could use either:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> compositeTransform = Matrix.Multiply(Matrix.CreateTranslation(x, y, z), Matrix.CreateRotation(angle));</span></span></code></pre></div>
<p>or</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> translation = Matrix.CreateTranslation(x, y, z);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> rotation = Matrix.CreateRotation(angle);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> compositeTransform = translation * rotation;</span></span></code></pre></div>

<details open class=" box cstyle notices warning">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-exclamation-triangle"></i> 
    Warning
  </summary>
  <div class="box-content">
<p>The order the matrices are concatenated in determines the order in which the operations are performed!  DirectX (and hence, MonoGame) uses left-to-right order, i.e. the leftmost matrix effect happens <em>first</em>, and the rightmost <em>last</em>.</p>
  </div>
</details>
<p>Now let&rsquo;s put this knowledge of transforms to practical use.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="screen-scrolling">Screen Scrolling</h1>

<p>Perhaps the most common use of transforms with the sprite batch is to support <em>screen scrolling</em>, i.e. shifting the viewport (the visible part of the game world) around to allow for larger game worlds.</p>
<p>Consider what it would take to shift the game world using just what we&rsquo;ve learned about sprites.  We&rsquo;d need to keep track of an offset for where the viewport begins relative to the world:</p>
<p><a href="#R-image-db2f196a1b6515b48679aa121ed01a25" class="lightbox-link"><img alt="The Game World and Viewport" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/8.3.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-db2f196a1b6515b48679aa121ed01a25"><img alt="The Game World and Viewport" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/8.3.1.png"></a></p>
<p>Then, when we draw our game objects (like sprites), we&rsquo;d need to add this offset vector to the position of <em>each</em> as we draw them:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    spriteBatch.Begin();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">foreach</span>(<span style="color:#66d9ef">var</span> sprite <span style="color:#66d9ef">in</span> Sprites)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        spriteBatch.Draw(sprite.Texture, sprite.Position + offset, Color.White);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>This doesn&rsquo;t look too bad&hellip; but what about when we use a different <code>SpriteBatch.Draw()</code> override?  Or we position some sprites with a <code>Rectangle</code> instead of a <code>Vector2</code>?  We now need to start handling special cases, which can make our code quite a bit more complex and difficult to read.</p>
<p>However, the <code>SpriteBatch.Begin()</code> call takes an optional transformation matrix as a parameter, and applies its transform to <em>all</em> sprites drawn within the batch.  Thus, we can create a single transformation matrix to represent our offset, and apply it to the <code>SpriteBatch</code>.  Then we can use whatever <code>SpriteBatch.Draw()</code> override we want, and we don&rsquo;t need to worry about adjusting positioning of sprites - we just draw them where they go in the world, and the <code>SpriteBatch</code> only draws the portion of the world we want to show:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw game sprites within the world, however you need to.</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="auto-scrolling">Auto-Scrolling</h3>
<p>To build an auto-scrolling game (one where the screen is constantly scrolling at a set speed), you simply need to update the offset vector every frame, just as you would any moving object.  For example, to auto-scroll the screen vertically at a constant speed, we could use:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Vertical auto-scrolling</span>
</span></span><span style="display:flex;"><span>    offset.Y += Vector2.UnitY * (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalSeconds * SCROLL_SPEED;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw game sprites within the world, however you need to.</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>You can of course vary the scrolling speed as well - perhaps scrolling faster as the game progresses, or varying scrolling speed based on some player state (like firing thrusters).</p>
<h3 id="player-synched-scrolling">Player-Synched Scrolling</h3>
<p>A second possibility is to keep the player centered in the screen by scrolling the world around them.  For this, you need to know a vector from the player to the origin of the screen (<code>PlayerOffset</code>) and the position of the player in the world (<code>PlayerPosition</code>).  The <code>ViewportOffset</code> is the difference of these:</p>
<p><a href="#R-image-1f5842d3aa980aa78841edcf967298a1" class="lightbox-link"><img alt="Player-synched Scrolling" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/8.3.2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-1f5842d3aa980aa78841edcf967298a1"><img alt="Player-synched Scrolling" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/8.3.2.png"></a></p>
<p>Thus, each frame you update the offset vector based on the offset and the player&rsquo;s current position in the world:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Player-synched scrolling</span>
</span></span><span style="display:flex;"><span>    offset = PlayerOffset - Player.Position;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw game sprites within the world, however you need to.</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>If we want our player to be able to reach the edge of the screen without the &ldquo;blank space&rdquo; at the edge of the game world showing, we can clamp the offset vector to a region defined by a <code>MinScroll</code> and <code>MaxScroll</code> vector:</p>
<p><a href="#R-image-a2af5fc2e559ff0d3894d1b690f1bc70" class="lightbox-link"><img alt="Clamped Player-Synched Scrolling" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/8.3.3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a2af5fc2e559ff0d3894d1b690f1bc70"><img alt="Clamped Player-Synched Scrolling" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/8.3.3.png"></a></p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Player-synched scrolling</span>
</span></span><span style="display:flex;"><span>    offset = Player.Position - PlayerOffset;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Clamp the resulting vector to the visible region</span>
</span></span><span style="display:flex;"><span>    offset = Vector2.Clamp(offset, MinScroll, MaxScroll);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw game sprites within the world, however you need to.</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="visibility-culling">Visibility Culling</h3>
<p>Regardless of how we determine what part of the game world is visible, we only need to draw the content (i.e. sprites) that fall within that region.  If we invoke <code>SpriteBatch.Draw()</code> for items that fall off-screen, we create extra, unnecessary work.  It can be helpful to use some form of the <a href="https://gameprogrammingpatterns.com/spatial-partition.html" rel="external" target="_blank">Spatial Partition Pattern</a> to identify the objects that fall on-screen, and only attempt to draw those.</p>
<p>Once we have spatial partitioning set up, we may also choose to only <em>update</em> game objects that fall on-screen (or near to the screen) as a further optimization.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="parallax-scrolling">Parallax Scrolling</h1>

<p>A further refinement of screen scrolling is <em>parallax scrolling</em>, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/3/34/Parallax_scrolling_example_scene.gif">
<p>This mimics our perceptions of the world - think to the last time you took a long car trip.  How quickly did objects in the distance seem to move relative to your car?  How about nearer objects (i.e. fenceposts or power poles)?  And how large did each seem?</p>
<p>Essentially, objects in the distance seem both <em>smaller</em> and to move slower relative to our position than nearer objects.  To accomplish parallax scrolling we break our game sprites into different <em>layers</em>, and render each layer using a different <code>SpriteBatch</code> batch, i.e.:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">2</span>].X, offset[<span style="color:#ae81ff">2</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the second layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">1</span>].X, offset[<span style="color:#ae81ff">1</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">0</span>].X, offset[<span style="color:#ae81ff">0</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Unless we are using a <code>SpriteSortMode</code> that sorts sprites by depth values (i.e. <code>SpriteSort.BackToFront</code> or <code>SpriteSort.FrontToBack</code>), it is important that we draw the rearmost layer first, and then the layers in front.  The above example assumes that layer 0 is the front-most layer.</p>
<h3 id="determining-the-offset-vectors">Determining the Offset Vectors</h3>
<p>The offset vector for the layer in which the player is drawn is determined similarly to the offset for regular screen scrolling.  The remaining offset vectors are scaled from this vector.  Layers <em>behind</em> the player are scrolled at a slower speed, and hence scaled to be <em>smaller</em>.  So if in our example the player is in layer 0, we would update our offsets accordingly - maybe the second layer scrolls at 2/3 speed, and the rearmost at 1/3 speed:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// assuming offset is the calculated offset</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    offsets[<span style="color:#ae81ff">0</span>] = offset;
</span></span><span style="display:flex;"><span>    offsets[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">0.666f</span> * offset; <span style="color:#75715e">// 1/3 the main layer&#39;s speed</span>
</span></span><span style="display:flex;"><span>    offsets[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">0.333f</span> * offset; <span style="color:#75715e">// 2/3 the main layer&#39;s speed</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">2</span>].X, offset[<span style="color:#ae81ff">2</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the second layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">1</span>].X, offset[<span style="color:#ae81ff">1</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">0</span>].X, offset[<span style="color:#ae81ff">0</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Similarly, if you add layers  <em>in front of</em> the player are scrolled faster, and hence should be <em>larger</em>.</p>
<h3 id="scaling-layers">Scaling Layers</h3>
<p>If your art is not drawn pre-scaled for the layer we are using it on, we can combine the translation operation with a scaling operation by concatenating two matrices.  This also has the practical benefit of scaling the scrolling speed in the same operation (and thus, you only need a single offset vector).  Thus, the above example would be refactored as:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// assuming offset is the calculated offset</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the third layer&#39;s offset and resizing</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>) * Matrix.CreateScale(<span style="color:#ae81ff">0.333f</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation and scale matrix representing the second layer&#39;s offset and resizing</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">1</span>].X, offset[<span style="color:#ae81ff">1</span>].Y, <span style="color:#ae81ff">0</span>) * Matrix.CreateScale(<span style="color:#ae81ff">0.666f</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Note that <em>this</em> approach assumes all art is drawn to the same scale, thus, a background that is scaled in half <em>needs to be twice as big as the foreground</em>!  For this reason, we don&rsquo;t normally see this version used outside of tile maps.  However, with tiles it can maximize the use of tile resources at little extra cost.  We&rsquo;ll explore the use of tile maps in an upcoming chapter.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="scaling-to-the-screen">Scaling to the Screen</h1>

<p>One of the challenges of creating a computer game in the modern day is deciding the resolution you will display the game at.  We discussed this previously in our <a href="https://textbooks.cs.ksu.edu/cis580/01-intro-to-monogame/03-the-game-window/" rel="external" target="_blank">coverage of the game window</a>.  But instead of forcing a single resolution, we can instead use a scaling matrix with our <code>SpriteBatch.Begin()</code> call to adapt to the monitor resolution.</p>
<p>Let&rsquo;s begin by assuming we want to display our game full-screen using the monitor&rsquo;s default resolution.  We can get this from the <code>GraphicsAdapter</code> class (which represents the graphics hardware), and then use that as our preferred back buffer width and height.  This code in the constructor will accomplish this goal:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// Use full-screen at screen resolution</span>
</span></span><span style="display:flex;"><span>DisplayMode screen = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode;
</span></span><span style="display:flex;"><span>_graphics.IsFullScreen = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>_graphics.PreferredBackBufferWidth = screen.Width;
</span></span><span style="display:flex;"><span>_graphics.PreferredBackBufferHeight = screen.Height;</span></span></code></pre></div>
<p>Note that if you do this later (i.e. not in your <code>Game</code> class constructor), you&rsquo;ll need to also apply your changes with:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>_graphics.ApplyChanges();</span></span></code></pre></div>
<p>This is because as the game is constructed, the graphics device has not yet been initialized.  But once it <em>is</em> initialized, it will have to be reset.</p>
<h3 id="deciding-a-design-resolution">Deciding a Design Resolution</h3>
<p>Next you need to decide at what resolution you will <em>design</em> the game for.  This resolution is the size of your viewport <em>as you are calculating it relative to the game world</em>.  So if your entire world should be displayed on-screen, this is the size of the world.  This also determines the ideal dimensions of your sprites and other art in the game - these should all be drawn based on the design resolution.</p>
<p>Ideally, you want your design resolution to be close to the resolution you expect your game to be displayed most commonly, as the game will be scaled to account for any difference between the monitor and game resolution.  You might consider one of the common television resolutions:</p>
<ul>
<li>XVGA (1024x768) is a 4:3 ratio (the same as old TVs), and was once the most common monitor size.</li>
<li>WXVGA (1280x800) is a 16:10 aspect ratio, and displaced XVGA in the mid-2000&rsquo;s.  It is a common resolution for notebook and smartphone screens</li>
<li>720P (1280x720) is a 16:9 aspect ratio, and matches the 720p HDTV standard</li>
<li>1080P (1920x1080) is a 16:9 aspect ratio, and matches the 1020p HDTV standard, used for broadcast television and Blu-ray</li>
<li>4K (3840x2160) is a 16:9 aspect ratio, and is commonly used by 4K consumer electronics</li>
</ul>
<p>You probably want to pick a resolution equal or smaller than your lower-end target devices, as this means your assets will also be designed at a smaller resolution (and therefore require less memory to store).  When rendering your game, you will scale the game up to the actual device resolution.</p>
<p>Now, there are two primary strategies we might want to use for this scaling - scaling our game so that it <em>fits</em> or <em>fills</em> the available screen real estate.  If we are fitting to the screen, and our game uses a different aspect ratio than the monitor, we will have <em>letterboxing</em> (black bars on either the top and bottom or left and right sides of the screen).  Alternatively, if we are filling the screen and the aspect ratios don&rsquo;t match, then part of the game scene will not appear on-screen.</p>
<h3 id="fitting-the-screen">Fitting the Screen</h3>
<p>To fit the screen, we need to scale the game until the bigger dimension matches the corresponding screen dimension.  Then we need to translate our game so it is centered in the other dimension.  Which dimension is bigger depends on the aspect ratios of both your game and screen.  Once we know the larger dimension (our <em>primary</em> dimension), we determine a scaling factor by dividing the corresponding screen dimension by the corresponding game dimension:</p>
<span class="math align-center">$$ scale = \frac{screen_{primary}}{game_{primary}} $$</span>
<p>We will scale both game dimensions using this scaling factor, so that our game maintains its aspect ratio.  If we wish our screen to be centered in the other dimension, we&rsquo;ll need to calculate an offset based on the other dimension (accounting for the scaling of the game screen):</p>
<span class="math align-center">$$ offset_{other} = \frac{(screen_{other} - game_{other} * scale)}{2} $$</span>
<p>We divide the leftover space in half, which determines how far down or over on the screen we need to start rendering our game.</p>
<p>To accomplish this in MonoGame, we might use:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (screen.AspectRatio &lt; game.AspectRatio)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// letterbox vertically</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Scale game to screen width</span>
</span></span><span style="display:flex;"><span>    _gameScale = (<span style="color:#66d9ef">float</span>)screen.Width / game.Width;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// translate vertically</span>
</span></span><span style="display:flex;"><span>    _gameOffset.Y = (screen.Height - game.Height * _gameScale) / <span style="color:#ae81ff">2f</span>;
</span></span><span style="display:flex;"><span>    _gameOffset.X = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// letterbox horizontally</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Scale game to screen height </span>
</span></span><span style="display:flex;"><span>    _gameScale = (<span style="color:#66d9ef">float</span>)screen.Height / game.Height;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// translate horizontally</span>
</span></span><span style="display:flex;"><span>    _gameOffset.X = (screen.Width - game.Width * _gameScale) / <span style="color:#ae81ff">2f</span>;
</span></span><span style="display:flex;"><span>    _gameOffset.Y = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="filling-the-screen">Filling the Screen</h3>
<p>If instead we wish to fill all available screen space, and our aspect ratios of the game and screen do not match, some of the game will fall off-screen and not be visible.  The process is very similar - first we determine our primary dimension (which is now the <em>smaller</em> dimension - opposite of the scale to fill approach).  Once we know it, we calculate the scale the same way:</p>
<span class="math align-center">$$ scale = \frac{screen_{primary}}{game_{primary}} $$</span>
<p>And we calculate the offset in the other dimension the same way as well:</p>
<span class="math align-center">$$ offset_{other} = \frac{(screen_{other} - game_{other} * scale)}{2} $$</span>
<p>Note that in this case, because the scaled game is larger in the other dimension, this offset is negative.</p>
<p>Example code for MonoGame:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// 1. Determine which dimension must overflow screen </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(screen.AspectRatio &lt; game.AspectRatio)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// overflow horizontally</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Scale game to screen height </span>
</span></span><span style="display:flex;"><span>    _gameScale = (<span style="color:#66d9ef">float</span>)screen.Height / game.Height;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// translate horizontally </span>
</span></span><span style="display:flex;"><span>    _gameOffset.X = (screen.Width - game.Width * _gameScale) / <span style="color:#ae81ff">2f</span>;
</span></span><span style="display:flex;"><span>    _gameOffset.Y = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// overflow vertically</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Scale game to screen width </span>
</span></span><span style="display:flex;"><span>    _gameScale = (<span style="color:#66d9ef">float</span>)screen.Width / game.Width;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// translate vertically</span>
</span></span><span style="display:flex;"><span>    _gameOffset.Y = (screen.Height - game.Height * _gameScale) / <span style="color:#ae81ff">2f</span>;
</span></span><span style="display:flex;"><span>    _gameOffset.X = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h3 id="transforming-the-spritebatch">Transforming the SpriteBatch</h3>
<p>Once we&rsquo;ve calculated our scale and offset, we can use these when invoking <code>SpriteBatch.Begin()</code> to automatically scale and position the game within the available screen real estate.  We first must create a scaling matrix, which will scale up the game scene to our screen, and then we must translate based on our calculated offset to position the game screen within the screen:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span> <span style="color:#75715e">// Determine the necessary transform to scale and position game on-screen</span>
</span></span><span style="display:flex;"><span>Matrix transform =                 
</span></span><span style="display:flex;"><span>    Matrix.CreateScale(_gameScale) * <span style="color:#75715e">// Scale the game to screen size </span>
</span></span><span style="display:flex;"><span>    Matrix.CreateTranslation(_gameOffset.X, _gameOffset.Y, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Translate game to letterbox position</span></span></span></code></pre></div>
<p>Then we can apply this transformation to any <code>SpriteBatch.Begin()</code> call used to render game sprites:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// Draw the game using SpriteBatch</span>
</span></span><span style="display:flex;"><span>_spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//TODO: Draw Calls</span>
</span></span><span style="display:flex;"><span>_spriteBatch.End();</span></span></code></pre></div>
<h3 id="variations">Variations</h3>
<p>Note that you may choose to <em>not</em> transform and scale some <code>SpriteBatch</code> operations - such as when drawing your GUI.  You can use a separate batch for those (but remember, the bounds of the screen viewport may be different depending on your screen resolution, so you may want to position elements relative to the available space).  Or, you could use the scale-to-fill strategy for your game and the scale-to-fit strategy for your GUI.</p>
<p>Another alternative is that instead of determining the resolution based on the graphics adapter default, you can allow the user to select resolutions from a menu.</p>
<h3 id="github-example">GitHub Example</h3>
<p>I&rsquo;ve posted an example project that allows you to explore these concepts on GitHub: <a href="https://github.com/zombiepaladin/scale-to-screen" rel="external" target="_blank">https://github.com/zombiepaladin/scale-to-screen</a></p>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>While the discussion here focused on games which are sized to the screen, it can <em>also</em> apply to games in which the world is <em>larger</em> than the screen, and the displayed portions of the game scroll with the player.  In those cases, you still need to define your game&rsquo;s design resolution, which determines how much of the game will appear on-screen at any given time.</p>
<p>You just need to combine the ideas from this approach with those handling scrolling, which we&rsquo;ll talk about next.</p>
  </div>
</details>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="special-effects">Special Effects</h1>

<p>In addition to the more practical uses like scrolling, combining matrix transformations with the <code>SpriteBatch</code> can be used to create a variety of special effects, i.e. zooming into and out of the scene, rotating game worlds, screen shaking, and probably many others.</p>
<h3 id="zooming">Zooming</h3>
<p>To zoom into the scene, we simply scale up all the elements.  However, we need this scaling to occur <em>from the center of the viewport (the part of the game we see)</em>.  If we simply used a scale matrix, the scaling would be centered on the world origin, so we would end up displaying a different part of the world.</p>
<p>Consider two maps - one at twice the scale of the first.  If you laid the two maps so that the the two upper-left hand corners were aligned, and then put a pin through a city in the smaller map, the corresponding city in the larger map would actually be to the right and below the pin.  Instead of lining up the corners, you would need to line up the two cities.</p>
<p>We can do the same thing in MonoGame by <em>translating</em> everything in our world so that the origin is now at the center of our screen.  Consider the case where our game&rsquo;s viewport is 760x480, and the distance it&rsquo;s top-left corner is from the origin of the world is represented by the <code>offset</code> vector.  We can create a translation matrix that would move the center of that viewport to the origin with:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Matrix zoomTranslation = Matrix.CreateTranslation(-offset.X - <span style="color:#ae81ff">760f</span>/<span style="color:#ae81ff">2</span>, -offset.Y - <span style="color:#ae81ff">480f</span>/<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>);</span></span></code></pre></div>
<p>And our scale matrix with:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Matrix zoomScale = Matrix.CreateScale(zoom);</span></span></code></pre></div>
<p>Where <code>zoom</code> is our zoom factor (<code>1.0f</code> indicating no zoom, &gt; 1 indicating zooming in, and &lt; 1 indicating zooming out).</p>
<p>The transformation matrix we would use to zoom would then be the translation matrix multiplied by our scale matrix, then multiplied by the <em>inverse</em> of the translation matrix.  Basically, we move the world to the origin, scale, and then move it back:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Matrix zoomTransform = zoomTranslation * zoomScale * Matrix.Invert(zoomTranslation);</span></span></code></pre></div>
<p>We can then plug this matrix into our <code>SpriteBatch.Begin()</code> method as the <code>transformMatrix</code> parameter:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>_spriteBatch.Draw(transformMatrix: zoomTransform);</span></span></code></pre></div>
<h3 id="spinning-the-world">Spinning the World</h3>
<p>Another interesting technique is to <em>spin</em> the game world.  For example, we might have a platform-style game where the player walks around a rotating planetoid.  For this, we simply use a rotation matrix.  But, as with scaling, we need to first translate the world to the origin of our rotation (the center of our planetoid), rotate, and translate back:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Matrix spinTranslation = Matrix.CreateTranslation(-<span style="color:#ae81ff">860</span>, -<span style="color:#ae81ff">908</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>Matrix spinRotation = Matrix.CreateRotationZ(_rotation);
</span></span><span style="display:flex;"><span>Matrix spinTransform = spinTranslation * spinRotation * Matrix.Invert(spinTranslation);</span></span></code></pre></div>
<h3 id="screen-shake">Screen Shake</h3>
<p>A third technique that can create an interesting effect is to <em>shake</em> the game world.  This could be used to visually represent an earthquake, rocket launch, or other intense action.  Basically we want to create small changes in the position of the viewport each frame.  This could be done completely randomly, but using a function like <span class="math align-center">$ sine $</span> or <span class="math align-center">$ cosine $</span> yields more predictable results (remember, the output of these functions falls the range <span class="math align-center">$ (-1 .. 1) $</span> and are the inverse of the other).</p>
<p>We can combine those functions with a timer to create a shaking effect, i.e.:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Matrix shakeTransform = Matrix.Identity;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (_shaking)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    _shakeTime += (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalMilliseconds;
</span></span><span style="display:flex;"><span>    shakeTransform = Matrix.CreateTranslation(<span style="color:#ae81ff">10</span> * MathF.Sin(_shakeTime), <span style="color:#ae81ff">10</span> * MathF.Cos(_shakeTime), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_shakeTime &gt; <span style="color:#ae81ff">3000</span>) _shaking = <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Will create a three-second shaking of the screen, when the resulting translation matrix is use with the <code>SpriteBatch</code>.  This results in a 20-pixel variation on the position items are rendered in the game world.  You could elaborate upon this simple technique by applying easing (making the magnitude of the shake grow and fall during the shake duration).</p>
<h3 id="github-example">GitHub Example</h3>
<p>You can of course combine these effects into a composite operation.  I&rsquo;ve posted an example project doing just that on GitHub: <a href="https://github.com/zombiepaladin/spritebatch-transform-special-effects" rel="external" target="_blank">https://github.com/zombiepaladin/spritebatch-transform-special-effects</a> for your perusal.  And this is just a small sampling of what you could possibly do.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="summary">Summary</h1>

<p>In this chapter we explored using the <code>transformMatrix</code> parameter of <code>SpriteBatch.Begin()</code> to apply a transformation matrix to an entire batch of sprites we are rendering.  This provides us with an easy mechanism for implementing a scrolling world in our games.  We also looked at how we could clamp that scrolling to keep the edges of the game world on-screen.</p>
<p>Building upon the scrolling idea, we also examined parallax scrolling, where we create the illusion of depth by scrolling multiple layers at different speeds.  When implemented with <code>SpriteBatch</code>, each layer used a different batch of sprites and its own transform matrix.</p>
<p>We also explored other ideas for manipulating the <code>SpriteBatch</code> transform, including effects like zooming, spinning the game world, and shaking the scene.  We saw how these could be combined through simple matrix multiplication to create composite effects.</p>
<p>Finally, we saw how we could use scaling to adapt our game to any monitor resolution while preserving our games&rsquo; designed aspect ratio.</p>

  <footer class="footline">
  </footer>
</article>
          </section>
        </div>
      </main>
<div class="git-footer">
  <p class="theme-version-footer">8.0.0</p>
<p>Last modified by:
              <i class='fa-fw fas fa-user'></i> Russell Feldhausen
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cis580/commit/43f194969a638fa4572819da4b31060ad574a9ce">Aug 11, 2023</a>
</p>

</div>
    </div>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cis580/js/mathjax/tex-mml-chtml.js?1755628803"></script>
    <script src="/cis580/js/clipboard/clipboard.min.js?1755628803" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1755628803" defer></script>
    <script src="/cis580/js/theme.min.js?1755628803" defer></script>
  </body>
</html>
