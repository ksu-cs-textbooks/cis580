<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="In addition to the more practical uses like scrolling, combining matrix transformations with the SpriteBatch can be used to create a variety of special effects, i.e. zooming into and out of the scene, rotating game worlds, screen shaking, and probably many others.
Zooming To zoom into the scene, we simply scale up all the elements. However, we need this scaling to occur from the center of the viewport (the part of the game we see).">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="Special Effects :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="In addition to the more practical uses like scrolling, combining matrix transformations with the SpriteBatch can be used to create a variety of special effects, i.e. zooming into and out of the scene, rotating game worlds, screen shaking, and probably many others.
Zooming To zoom into the scene, we simply scale up all the elements. However, we need this scaling to occur from the center of the viewport (the part of the game we see).">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/05-special-effects/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Special Effects :: K-State CIS 580 Textbook">
    <meta property="og:description" content="In addition to the more practical uses like scrolling, combining matrix transformations with the SpriteBatch can be used to create a variety of special effects, i.e. zooming into and out of the scene, rotating game worlds, screen shaking, and probably many others.
Zooming To zoom into the scene, we simply scale up all the elements. However, we need this scaling to occur from the center of the viewport (the part of the game we see).">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="SpriteBatch Transforms">
    <meta property="article:published_time" content="2020-03-20T10:53:05-05:00">
    <meta property="article:modified_time" content="2023-08-14T11:41:07-05:00">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="Special Effects :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="In addition to the more practical uses like scrolling, combining matrix transformations with the SpriteBatch can be used to create a variety of special effects, i.e. zooming into and out of the scene, rotating game worlds, screen shaking, and probably many others.
Zooming To zoom into the scene, we simply scale up all the elements. However, we need this scaling to occur from the center of the viewport (the part of the game we see).">
    <meta itemprop="datePublished" content="2020-03-20T10:53:05-05:00">
    <meta itemprop="dateModified" content="2023-08-14T11:41:07-05:00">
    <meta itemprop="wordCount" content="661">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>Special Effects :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/05-special-effects/index.html" rel="canonical" type="text/html" title="Special Effects :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/05-special-effects/index.xml" rel="alternate" type="application/rss+xml" title="Special Effects :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/05-special-effects/index.print.html" rel="alternate" type="text/html" title="Special Effects :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/05-special-effects/tele.html" rel="alternate" type="text/html" title="Special Effects :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1755628803" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1755628803" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/search.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1755628803";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/format-html.min.css?1755628803" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/08-spritebatch-transforms\/05-special-effects\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1755628803" rel="stylesheet">
  </head>
  <body class="mobile-support embed html" data-url="/cis580/08-spritebatch-transforms/05-special-effects/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 08-spritebatch-transforms" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="special-effects">Special Effects</h1>

<p>In addition to the more practical uses like scrolling, combining matrix transformations with the <code>SpriteBatch</code> can be used to create a variety of special effects, i.e. zooming into and out of the scene, rotating game worlds, screen shaking, and probably many others.</p>
<h3 id="zooming">Zooming</h3>
<p>To zoom into the scene, we simply scale up all the elements.  However, we need this scaling to occur <em>from the center of the viewport (the part of the game we see)</em>.  If we simply used a scale matrix, the scaling would be centered on the world origin, so we would end up displaying a different part of the world.</p>
<p>Consider two maps - one at twice the scale of the first.  If you laid the two maps so that the the two upper-left hand corners were aligned, and then put a pin through a city in the smaller map, the corresponding city in the larger map would actually be to the right and below the pin.  Instead of lining up the corners, you would need to line up the two cities.</p>
<p>We can do the same thing in MonoGame by <em>translating</em> everything in our world so that the origin is now at the center of our screen.  Consider the case where our game&rsquo;s viewport is 760x480, and the distance it&rsquo;s top-left corner is from the origin of the world is represented by the <code>offset</code> vector.  We can create a translation matrix that would move the center of that viewport to the origin with:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Matrix zoomTranslation = Matrix.CreateTranslation(-offset.X - <span style="color:#ae81ff">760f</span>/<span style="color:#ae81ff">2</span>, -offset.Y - <span style="color:#ae81ff">480f</span>/<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">0</span>);</span></span></code></pre></div>
<p>And our scale matrix with:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Matrix zoomScale = Matrix.CreateScale(zoom);</span></span></code></pre></div>
<p>Where <code>zoom</code> is our zoom factor (<code>1.0f</code> indicating no zoom, &gt; 1 indicating zooming in, and &lt; 1 indicating zooming out).</p>
<p>The transformation matrix we would use to zoom would then be the translation matrix multiplied by our scale matrix, then multiplied by the <em>inverse</em> of the translation matrix.  Basically, we move the world to the origin, scale, and then move it back:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Matrix zoomTransform = zoomTranslation * zoomScale * Matrix.Invert(zoomTranslation);</span></span></code></pre></div>
<p>We can then plug this matrix into our <code>SpriteBatch.Begin()</code> method as the <code>transformMatrix</code> parameter:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>_spriteBatch.Draw(transformMatrix: zoomTransform);</span></span></code></pre></div>
<h3 id="spinning-the-world">Spinning the World</h3>
<p>Another interesting technique is to <em>spin</em> the game world.  For example, we might have a platform-style game where the player walks around a rotating planetoid.  For this, we simply use a rotation matrix.  But, as with scaling, we need to first translate the world to the origin of our rotation (the center of our planetoid), rotate, and translate back:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Matrix spinTranslation = Matrix.CreateTranslation(-<span style="color:#ae81ff">860</span>, -<span style="color:#ae81ff">908</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>Matrix spinRotation = Matrix.CreateRotationZ(_rotation);
</span></span><span style="display:flex;"><span>Matrix spinTransform = spinTranslation * spinRotation * Matrix.Invert(spinTranslation);</span></span></code></pre></div>
<h3 id="screen-shake">Screen Shake</h3>
<p>A third technique that can create an interesting effect is to <em>shake</em> the game world.  This could be used to visually represent an earthquake, rocket launch, or other intense action.  Basically we want to create small changes in the position of the viewport each frame.  This could be done completely randomly, but using a function like <span class="math align-center">$ sine $</span> or <span class="math align-center">$ cosine $</span> yields more predictable results (remember, the output of these functions falls the range <span class="math align-center">$ (-1 .. 1) $</span> and are the inverse of the other).</p>
<p>We can combine those functions with a timer to create a shaking effect, i.e.:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>Matrix shakeTransform = Matrix.Identity;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (_shaking)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    _shakeTime += (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalMilliseconds;
</span></span><span style="display:flex;"><span>    shakeTransform = Matrix.CreateTranslation(<span style="color:#ae81ff">10</span> * MathF.Sin(_shakeTime), <span style="color:#ae81ff">10</span> * MathF.Cos(_shakeTime), <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (_shakeTime &gt; <span style="color:#ae81ff">3000</span>) _shaking = <span style="color:#66d9ef">false</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Will create a three-second shaking of the screen, when the resulting translation matrix is use with the <code>SpriteBatch</code>.  This results in a 20-pixel variation on the position items are rendered in the game world.  You could elaborate upon this simple technique by applying easing (making the magnitude of the shake grow and fall during the shake duration).</p>
<h3 id="github-example">GitHub Example</h3>
<p>You can of course combine these effects into a composite operation.  I&rsquo;ve posted an example project doing just that on GitHub: <a href="https://github.com/zombiepaladin/spritebatch-transform-special-effects" rel="external" target="_blank">https://github.com/zombiepaladin/spritebatch-transform-special-effects</a> for your perusal.  And this is just a small sampling of what you could possibly do.</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cis580/js/mathjax/tex-mml-chtml.js?1755628803"></script>
    <script src="/cis580/js/clipboard/clipboard.min.js?1755628803" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1755628803" defer></script>
    <script src="/cis580/js/theme.min.js?1755628803" defer></script>
  <script src="/cis580/js/embed-iframe.min.js?1755628803" defer></script>
  </body>
</html>
