<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="A further refinement of screen scrolling is parallax scrolling, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:
This mimics our perceptions of the world - think to the last time you took a long car trip. How quickly did objects in the distance seem to move relative to your car? How about nearer objects (i.">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="Parallax Scrolling :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="A further refinement of screen scrolling is parallax scrolling, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:
This mimics our perceptions of the world - think to the last time you took a long car trip. How quickly did objects in the distance seem to move relative to your car? How about nearer objects (i.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Parallax Scrolling :: K-State CIS 580 Textbook">
    <meta property="og:description" content="A further refinement of screen scrolling is parallax scrolling, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:
This mimics our perceptions of the world - think to the last time you took a long car trip. How quickly did objects in the distance seem to move relative to your car? How about nearer objects (i.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="SpriteBatch Transforms">
    <meta property="article:published_time" content="2020-03-20T10:53:05-05:00">
    <meta property="article:modified_time" content="2021-03-11T13:44:31-06:00">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="Parallax Scrolling :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="A further refinement of screen scrolling is parallax scrolling, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:
This mimics our perceptions of the world - think to the last time you took a long car trip. How quickly did objects in the distance seem to move relative to your car? How about nearer objects (i.">
    <meta itemprop="datePublished" content="2020-03-20T10:53:05-05:00">
    <meta itemprop="dateModified" content="2021-03-11T13:44:31-06:00">
    <meta itemprop="wordCount" content="745">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>Parallax Scrolling :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.html" rel="canonical" type="text/html" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.xml" rel="alternate" type="application/rss+xml" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.print.html" rel="alternate" type="text/html" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/04-parallax-scrolling/tele.html" rel="alternate" type="text/html" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1755628803" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1755628803" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/search.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1755628803";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/format-html.min.css?1755628803" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/08-spritebatch-transforms\/04-parallax-scrolling\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1755628803" rel="stylesheet">
  </head>
  <body class="mobile-support embed html" data-url="/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 08-spritebatch-transforms" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="parallax-scrolling">Parallax Scrolling</h1>

<p>A further refinement of screen scrolling is <em>parallax scrolling</em>, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/3/34/Parallax_scrolling_example_scene.gif">
<p>This mimics our perceptions of the world - think to the last time you took a long car trip.  How quickly did objects in the distance seem to move relative to your car?  How about nearer objects (i.e. fenceposts or power poles)?  And how large did each seem?</p>
<p>Essentially, objects in the distance seem both <em>smaller</em> and to move slower relative to our position than nearer objects.  To accomplish parallax scrolling we break our game sprites into different <em>layers</em>, and render each layer using a different <code>SpriteBatch</code> batch, i.e.:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">2</span>].X, offset[<span style="color:#ae81ff">2</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the second layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">1</span>].X, offset[<span style="color:#ae81ff">1</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">0</span>].X, offset[<span style="color:#ae81ff">0</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Unless we are using a <code>SpriteSortMode</code> that sorts sprites by depth values (i.e. <code>SpriteSort.BackToFront</code> or <code>SpriteSort.FrontToBack</code>), it is important that we draw the rearmost layer first, and then the layers in front.  The above example assumes that layer 0 is the front-most layer.</p>
<h3 id="determining-the-offset-vectors">Determining the Offset Vectors</h3>
<p>The offset vector for the layer in which the player is drawn is determined similarly to the offset for regular screen scrolling.  The remaining offset vectors are scaled from this vector.  Layers <em>behind</em> the player are scrolled at a slower speed, and hence scaled to be <em>smaller</em>.  So if in our example the player is in layer 0, we would update our offsets accordingly - maybe the second layer scrolls at 2/3 speed, and the rearmost at 1/3 speed:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// assuming offset is the calculated offset</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    offsets[<span style="color:#ae81ff">0</span>] = offset;
</span></span><span style="display:flex;"><span>    offsets[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">0.666f</span> * offset; <span style="color:#75715e">// 1/3 the main layer&#39;s speed</span>
</span></span><span style="display:flex;"><span>    offsets[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">0.333f</span> * offset; <span style="color:#75715e">// 2/3 the main layer&#39;s speed</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">2</span>].X, offset[<span style="color:#ae81ff">2</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the second layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">1</span>].X, offset[<span style="color:#ae81ff">1</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">0</span>].X, offset[<span style="color:#ae81ff">0</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Similarly, if you add layers  <em>in front of</em> the player are scrolled faster, and hence should be <em>larger</em>.</p>
<h3 id="scaling-layers">Scaling Layers</h3>
<p>If your art is not drawn pre-scaled for the layer we are using it on, we can combine the translation operation with a scaling operation by concatenating two matrices.  This also has the practical benefit of scaling the scrolling speed in the same operation (and thus, you only need a single offset vector).  Thus, the above example would be refactored as:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// assuming offset is the calculated offset</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the third layer&#39;s offset and resizing</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>) * Matrix.CreateScale(<span style="color:#ae81ff">0.333f</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation and scale matrix representing the second layer&#39;s offset and resizing</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">1</span>].X, offset[<span style="color:#ae81ff">1</span>].Y, <span style="color:#ae81ff">0</span>) * Matrix.CreateScale(<span style="color:#ae81ff">0.666f</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Note that <em>this</em> approach assumes all art is drawn to the same scale, thus, a background that is scaled in half <em>needs to be twice as big as the foreground</em>!  For this reason, we don&rsquo;t normally see this version used outside of tile maps.  However, with tiles it can maximize the use of tile resources at little extra cost.  We&rsquo;ll explore the use of tile maps in an upcoming chapter.</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script src="/cis580/js/clipboard/clipboard.min.js?1755628803" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1755628803" defer></script>
    <script src="/cis580/js/theme.min.js?1755628803" defer></script>
  <script src="/cis580/js/embed-iframe.min.js?1755628803" defer></script>
  </body>
</html>
