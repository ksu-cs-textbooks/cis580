




  
	
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
	  

  
	
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
	  

  
	
		
		
<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 6.0.0">
    <meta name="description" content="A further refinement of screen scrolling is parallax scrolling, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:
This mimics our perceptions of the world - think to the last time you took a long car trip. How quickly did objects in the distance seem to move relative to your car? How about nearer objects (i.">
    <meta name="author" content="Nathan Bean">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Parallax Scrolling :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="A further refinement of screen scrolling is parallax scrolling, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:
This mimics our perceptions of the world - think to the last time you took a long car trip. How quickly did objects in the distance seem to move relative to your car? How about nearer objects (i.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/04-parallax-scrolling/embed.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Parallax Scrolling :: K-State CIS 580 Textbook">
    <meta property="og:description" content="A further refinement of screen scrolling is parallax scrolling, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:
This mimics our perceptions of the world - think to the last time you took a long car trip. How quickly did objects in the distance seem to move relative to your car? How about nearer objects (i.">
    <meta property="og:locale" content="en-us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="SpriteBatch Transforms">
    <meta property="article:published_time" content="2020-03-20T10:53:05-05:00">
    <meta property="article:modified_time" content="2021-03-11T13:44:31-06:00">
    <meta itemprop="name" content="Parallax Scrolling :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="A further refinement of screen scrolling is parallax scrolling, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:
This mimics our perceptions of the world - think to the last time you took a long car trip. How quickly did objects in the distance seem to move relative to your car? How about nearer objects (i.">
    <meta itemprop="datePublished" content="2020-03-20T10:53:05-05:00">
    <meta itemprop="dateModified" content="2021-03-11T13:44:31-06:00">
    <meta itemprop="wordCount" content="742">
    <title>Parallax Scrolling :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/04-parallax-scrolling/" rel="canonical" type="text/html" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.xml" rel="alternate" type="application/rss+xml" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.print.html" rel="alternate" type="text/html" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/04-parallax-scrolling/tele.html" rel="alternate" type="text/html" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    
  <link href="/cis580/css/fontawesome-all.min.css?1723670677" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/fontawesome-all.min.css?1723670677" rel="stylesheet"></noscript>
  <link href="/cis580/css/nucleus.css?1723670677" rel="stylesheet">
  <link href="/cis580/css/auto-complete.css?1723670677" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/auto-complete.css?1723670677" rel="stylesheet"></noscript>
  <link href="/cis580/css/perfect-scrollbar.min.css?1723670677" rel="stylesheet">
  <link href="/cis580/css/fonts.css?1723670677" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/css/fonts.css?1723670677" rel="stylesheet"></noscript>
  <link href="/cis580/css/theme.css?1723670677" rel="stylesheet">
  
  
  
  <link href="/cis580/css/theme-light-theme.css?1723670677" rel="stylesheet" id="R-variant-style">
  <link href="/cis580/css/chroma-relearn-light.css?1723670677" rel="stylesheet" id="R-variant-chroma-style">
  <link href="/cis580/css/variant.css?1723670677" rel="stylesheet">
  <link href="/cis580/css/print.css?1723670677" rel="stylesheet" media="print">
  
  
  
  <script>
    window.relearn = window.relearn || {};
    window.relearn.relBasePath='..\/..';
    window.relearn.relBaseUri='..\/..\/..';
    window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
    window.index_js_url="/cis580/index.search.js";
    // variant stuff
    window.variants && variants.init( [ 'light-theme' ] );
    // translations
    window.T_Copy_to_clipboard = `Copy to clipboard`;
    window.T_Copied_to_clipboard = `Copied to clipboard!`;
    window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
    window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
    window.T_Reset_view = `Reset view`;
    window.T_View_reset = `View reset!`;
    window.T_No_results_found = `No results found for "{0}"`;
    window.T_N_results_found = `{1} results found for "{0}"`;
  </script>
  
  <link href="/cis580/css/custom.css?1723670677" rel="stylesheet">
    
  </head>
  <body class="mobile-support embed disableInlineCopyToClipboard" data-url="/cis580/08-spritebatch-transforms/04-parallax-scrolling/embed.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
    
    
    

<p>A further refinement of screen scrolling is <em>parallax scrolling</em>, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/3/34/Parallax_scrolling_example_scene.gif">
<p>This mimics our perceptions of the world - think to the last time you took a long car trip.  How quickly did objects in the distance seem to move relative to your car?  How about nearer objects (i.e. fenceposts or power poles)?  And how large did each seem?</p>
<p>Essentially, objects in the distance seem both <em>smaller</em> and to move slower relative to our position than nearer objects.  To accomplish parallax scrolling we break our game sprites into different <em>layers</em>, and render each layer using a different <code>SpriteBatch</code> batch, i.e.:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">Draw</span><span class="p">(</span><span class="n">GameTime</span> <span class="n">gameTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span class="line"><span class="cl">    <span class="n">Matrix</span> <span class="n">transform</span> <span class="p">=</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateTranslation</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">X</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">Y</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Draw the transformed game world</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">Begin</span><span class="p">(</span><span class="n">transformMatrix</span><span class="p">:</span> <span class="n">transform</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">End</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Create the translation matrix representing the second layer&#39;s offset</span>
</span></span><span class="line"><span class="cl">    <span class="n">Matrix</span> <span class="n">transform</span> <span class="p">=</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateTranslation</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">X</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Y</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Draw the transformed game world</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">Begin</span><span class="p">(</span><span class="n">transformMatrix</span><span class="p">:</span> <span class="n">transform</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">End</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span class="line"><span class="cl">    <span class="n">Matrix</span> <span class="n">transform</span> <span class="p">=</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateTranslation</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">X</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Y</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Draw the transformed game world</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">Begin</span><span class="p">(</span><span class="n">transformMatrix</span><span class="p">:</span> <span class="n">transform</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">End</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Unless we are using a <code>SpriteSortMode</code> that sorts sprites by depth values (i.e. <code>SpriteSort.BackToFront</code> or <code>SpriteSort.FrontToBack</code>), it is important that we draw the rearmost layer first, and then the layers in front.  The above example assumes that layer 0 is the front-most layer.</p>
<h3 id="determining-the-offset-vectors">Determining the Offset Vectors</h3>
<p>The offset vector for the layer in which the player is drawn is determined similarly to the offset for regular screen scrolling.  The remaining offset vectors are scaled from this vector.  Layers <em>behind</em> the player are scrolled at a slower speed, and hence scaled to be <em>smaller</em>.  So if in our example the player is in layer 0, we would update our offsets accordingly - maybe the second layer scrolls at 2/3 speed, and the rearmost at 1/3 speed:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">Draw</span><span class="p">(</span><span class="n">GameTime</span> <span class="n">gameTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// assuming offset is the calculated offset</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">offsets</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">offset</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">offsets</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="m">0.666f</span> <span class="p">*</span> <span class="n">offset</span><span class="p">;</span> <span class="c1">// 1/3 the main layer&#39;s speed</span>
</span></span><span class="line"><span class="cl">    <span class="n">offsets</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="m">0.333f</span> <span class="p">*</span> <span class="n">offset</span><span class="p">;</span> <span class="c1">// 2/3 the main layer&#39;s speed</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span class="line"><span class="cl">    <span class="n">Matrix</span> <span class="n">transform</span> <span class="p">=</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateTranslation</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">X</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="n">Y</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Draw the transformed game world</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">Begin</span><span class="p">(</span><span class="n">transformMatrix</span><span class="p">:</span> <span class="n">transform</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">End</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Create the translation matrix representing the second layer&#39;s offset</span>
</span></span><span class="line"><span class="cl">    <span class="n">Matrix</span> <span class="n">transform</span> <span class="p">=</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateTranslation</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">X</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Y</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Draw the transformed game world</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">Begin</span><span class="p">(</span><span class="n">transformMatrix</span><span class="p">:</span> <span class="n">transform</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">End</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span class="line"><span class="cl">    <span class="n">Matrix</span> <span class="n">transform</span> <span class="p">=</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateTranslation</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">X</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">Y</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Draw the transformed game world</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">Begin</span><span class="p">(</span><span class="n">transformMatrix</span><span class="p">:</span> <span class="n">transform</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">End</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Similarly, if you add layers  <em>in front of</em> the player are scrolled faster, and hence should be <em>larger</em>.</p>
<h3 id="scaling-layers">Scaling Layers</h3>
<p>If your art is not drawn pre-scaled for the layer we are using it on, we can combine the translation operation with a scaling operation by concatenating two matrices.  This also has the practical benefit of scaling the scrolling speed in the same operation (and thus, you only need a single offset vector).  Thus, the above example would be refactored as:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-csharp" data-lang="csharp"><span class="line"><span class="cl"><span class="kd">public</span> <span class="k">void</span> <span class="n">Draw</span><span class="p">(</span><span class="n">GameTime</span> <span class="n">gameTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// assuming offset is the calculated offset</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Create the translation matrix representing the third layer&#39;s offset and resizing</span>
</span></span><span class="line"><span class="cl">    <span class="n">Matrix</span> <span class="n">transform</span> <span class="p">=</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateTranslation</span><span class="p">(</span><span class="n">offset</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">offset</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span> <span class="p">*</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateScale</span><span class="p">(</span><span class="m">0.333f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Draw the transformed game world</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">Begin</span><span class="p">(</span><span class="n">transformMatrix</span><span class="p">:</span> <span class="n">transform</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">End</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Create the translation and scale matrix representing the second layer&#39;s offset and resizing</span>
</span></span><span class="line"><span class="cl">    <span class="n">Matrix</span> <span class="n">transform</span> <span class="p">=</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateTranslation</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">X</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="n">Y</span><span class="p">,</span> <span class="m">0</span><span class="p">)</span> <span class="p">*</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateScale</span><span class="p">(</span><span class="m">0.666f</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Draw the transformed game world</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">Begin</span><span class="p">(</span><span class="n">transformMatrix</span><span class="p">:</span> <span class="n">transform</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">End</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span class="line"><span class="cl">    <span class="n">Matrix</span> <span class="n">transform</span> <span class="p">=</span> <span class="n">Matrix</span><span class="p">.</span><span class="n">CreateTranslation</span><span class="p">(</span><span class="n">offset</span><span class="p">.</span><span class="n">X</span><span class="p">,</span> <span class="n">offset</span><span class="p">.</span><span class="n">Y</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// Draw the transformed game world</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">Begin</span><span class="p">(</span><span class="n">transformMatrix</span><span class="p">:</span> <span class="n">transform</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span class="line"><span class="cl">    <span class="n">spriteBatch</span><span class="p">.</span><span class="n">End</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>Note that <em>this</em> approach assumes all art is drawn to the same scale, thus, a background that is scaled in half <em>needs to be twice as big as the foreground</em>!  For this reason, we don&rsquo;t normally see this version used outside of tile maps.  However, with tiles it can maximize the use of tile resources at little extra cost.  We&rsquo;ll explore the use of tile maps in an upcoming chapter.</p>

            <footer class="footline">
              
              
              
              
            </footer>
          </article>
</div>
</main>
</div>



<script src="/cis580/js/clipboard.min.js?1723670677" defer></script>
<script src="/cis580/js/perfect-scrollbar.min.js?1723670677" defer></script>
<script src="/cis580/js/theme.js?1723670677" defer></script>

<script src="/cis580/js/embed-iframe.js?1723670677" defer></script>
</body>
</html>
