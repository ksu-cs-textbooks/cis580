




	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="K-State CIS 580 Textbook">
    <meta name="author" content="Nathan H. Bean">
    <title>Parallax Scrolling :: K-State CIS 580 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.html" rel="canonical" type="text/html" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.xml" rel="alternate" type="application/rss+xml" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.print.html" rel="alternate" type="text/html" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis580/08-spritebatch-transforms/04-parallax-scrolling/tele.html" rel="alternate" type="text/html" title="Parallax Scrolling :: K-State CIS 580 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/fontawesome-all.min.css?1692031296" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis580/css/fontawesome-all.min.css?1692031296" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/nucleus.css?1692031296" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/auto-complete.css?1692031296" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis580/css/auto-complete.css?1692031296" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/perfect-scrollbar.min.css?1692031296" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/fonts.css?1692031296" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis580/css/fonts.css?1692031296" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/theme.css?1692031296" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/theme-auto.css?1692031296" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/variant.css?1692031296" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/print.css?1692031296" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/ie.css?1692031296" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/url.js?1692031296"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/variant.js?1692031296"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis580/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis580/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis580/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/custom.css?1692031296" rel="stylesheet">

  </head>
  <body class="mobile-support embed disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis580/08-spritebatch-transforms/04-parallax-scrolling/embed.html">
    <div id="body" class="default-animation">
      
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
    
    
    
<p>A further refinement of screen scrolling is <em>parallax scrolling</em>, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:</p>
<img src="https://upload.wikimedia.org/wikipedia/commons/3/34/Parallax_scrolling_example_scene.gif">
<p>This mimics our perceptions of the world - think to the last time you took a long car trip.  How quickly did objects in the distance seem to move relative to your car?  How about nearer objects (i.e. fenceposts or power poles)?  And how large did each seem?</p>
<p>Essentially, objects in the distance seem both <em>smaller</em> and to move slower relative to our position than nearer objects.  To accomplish parallax scrolling we break our game sprites into different <em>layers</em>, and render each layer using a different <code>SpriteBatch</code> batch, i.e.:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">2</span>].X, offset[<span style="color:#ae81ff">2</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the second layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">1</span>].X, offset[<span style="color:#ae81ff">1</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">0</span>].X, offset[<span style="color:#ae81ff">0</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Unless we are using a <code>SpriteSortMode</code> that sorts sprites by depth values (i.e. <code>SpriteSort.BackToFront</code> or <code>SpriteSort.FrontToBack</code>), it is important that we draw the rearmost layer first, and then the layers in front.  The above example assumes that layer 0 is the front-most layer.</p>
<h3 id="determining-the-offset-vectors">Determining the Offset Vectors</h3>
<p>The offset vector for the layer in which the player is drawn is determined similarly to the offset for regular screen scrolling.  The remaining offset vectors are scaled from this vector.  Layers <em>behind</em> the player are scrolled at a slower speed, and hence scaled to be <em>smaller</em>.  So if in our example the player is in layer 0, we would update our offsets accordingly - maybe the second layer scrolls at 2/3 speed, and the rearmost at 1/3 speed:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// assuming offset is the calculated offset</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    offsets[<span style="color:#ae81ff">0</span>] = offset;
</span></span><span style="display:flex;"><span>    offsets[<span style="color:#ae81ff">1</span>] = <span style="color:#ae81ff">0.666f</span> * offset; <span style="color:#75715e">// 1/3 the main layer&#39;s speed</span>
</span></span><span style="display:flex;"><span>    offsets[<span style="color:#ae81ff">2</span>] = <span style="color:#ae81ff">0.333f</span> * offset; <span style="color:#75715e">// 2/3 the main layer&#39;s speed</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">2</span>].X, offset[<span style="color:#ae81ff">2</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the second layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">1</span>].X, offset[<span style="color:#ae81ff">1</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">0</span>].X, offset[<span style="color:#ae81ff">0</span>].Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Similarly, if you add layers  <em>in front of</em> the player are scrolled faster, and hence should be <em>larger</em>.</p>
<h3 id="scaling-layers">Scaling Layers</h3>
<p>If your art is not drawn pre-scaled for the layer we are using it on, we can combine the translation operation with a scaling operation by concatenating two matrices.  This also has the practical benefit of scaling the scrolling speed in the same operation (and thus, you only need a single offset vector).  Thus, the above example would be refactored as:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// assuming offset is the calculated offset</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the third layer&#39;s offset and resizing</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>) * Matrix.CreateScale(<span style="color:#ae81ff">0.333f</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw third layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation and scale matrix representing the second layer&#39;s offset and resizing</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset[<span style="color:#ae81ff">1</span>].X, offset[<span style="color:#ae81ff">1</span>].Y, <span style="color:#ae81ff">0</span>) * Matrix.CreateScale(<span style="color:#ae81ff">0.666f</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw second layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Create the translation matrix representing the first layer&#39;s offset</span>
</span></span><span style="display:flex;"><span>    Matrix transform = Matrix.CreateTranslation(offset.X, offset.Y, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the transformed game world</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Draw first layer&#39;s sprites</span>
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><p>Note that <em>this</em> approach assumes all art is drawn to the same scale, thus, a background that is scaled in half <em>needs to be twice as big as the foreground</em>!  For this reason, we don&rsquo;t normally see this version used outside of tile maps.  However, with tiles it can maximize the use of tile resources at little extra cost.  We&rsquo;ll explore the use of tile maps in an upcoming chapter.</p>

            <footer class="footline">

            </footer>
          </article>
        </div>
      </main>
    </div>
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/clipboard.min.js?1692031297" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/perfect-scrollbar.min.js?1692031297" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/theme.js?1692031297" defer></script>
  </body>
</html>
