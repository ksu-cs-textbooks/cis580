




	
	
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
		

	
	
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		

	
	
		
		
<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.117.0">
    <meta name="generator" content="Relearn 5.18.0">
    <meta name="description" content="K-State CIS 580 Textbook">
    <meta name="author" content="Nathan H. Bean">
    <title>Scaling to the Screen :: K-State CIS 580 Textbook</title>
    <link href="https://ksu-cs-textbooks.github.io/cis580/08-spritebatch-transforms/06-screen-scaling/index.html" rel="canonical" type="text/html" title="Scaling to the Screen :: K-State CIS 580 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis580/08-spritebatch-transforms/06-screen-scaling/index.xml" rel="alternate" type="application/rss+xml" title="Scaling to the Screen :: K-State CIS 580 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis580/08-spritebatch-transforms/06-screen-scaling/index.print.html" rel="alternate" type="text/html" title="Scaling to the Screen :: K-State CIS 580 Textbook">
    <link href="https://ksu-cs-textbooks.github.io/cis580/08-spritebatch-transforms/06-screen-scaling/tele.html" rel="alternate" type="text/html" title="Scaling to the Screen :: K-State CIS 580 Textbook">
    <!-- https://github.com/filamentgroup/loadCSS/blob/master/README.md#how-to-use -->
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/fontawesome-all.min.css?1692031296" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis580/css/fontawesome-all.min.css?1692031296" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/nucleus.css?1692031296" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/auto-complete.css?1692031296" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis580/css/auto-complete.css?1692031296" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/perfect-scrollbar.min.css?1692031296" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/fonts.css?1692031296" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="https://ksu-cs-textbooks.github.io/cis580/css/fonts.css?1692031296" rel="stylesheet"></noscript>
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/theme.css?1692031296" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/theme-auto.css?1692031296" rel="stylesheet" id="variant-style">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/variant.css?1692031296" rel="stylesheet">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/print.css?1692031296" rel="stylesheet" media="print">
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/ie.css?1692031296" rel="stylesheet">
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/url.js?1692031296"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/variant.js?1692031296"></script>
    <script>
      // hack to let hugo tell us how to get to the root when using relativeURLs, it needs to be called *url= for it to do its magic:
      // https://github.com/gohugoio/hugo/blob/145b3fcce35fbac25c7033c91c1b7ae6d1179da8/transform/urlreplacers/absurlreplacer.go#L72
      window.index_js_url="https://ksu-cs-textbooks.github.io/cis580/index.search.js";
      var root_url="https://ksu-cs-textbooks.github.io/cis580/";
      var baseUri=root_url.replace(/\/$/, '');
      // translations
      window.T_Copy_to_clipboard = 'Copy to clipboard';
      window.T_Copied_to_clipboard = 'Copied to clipboard!';
      window.T_Copy_link_to_clipboard = 'Copy link to clipboard';
      window.T_Link_copied_to_clipboard = 'Copied link to clipboard!';
      window.T_No_results_found = 'No results found for \u0022{0}\u0022';
      window.T_N_results_found = '{1} results found for \u0022{0}\u0022';
      // some further base stuff
      var baseUriFull='https:\/\/ksu-cs-textbooks.github.io\/cis580/';
      window.variants && variants.init( [ 'auto', 'light-theme', 'dark-theme' ] );
    </script>
    
    <link href="https://ksu-cs-textbooks.github.io/cis580/css/custom.css?1692031296" rel="stylesheet">

  </head>
  <body class="mobile-support embed disableInlineCopyToClipboard" data-url="https://ksu-cs-textbooks.github.io/cis580/08-spritebatch-transforms/06-screen-scaling/embed.html">
    <div id="body" class="default-animation">
      
      
      
      <main id="body-inner" class="highlightable default" tabindex="-1">
        <div class="flex-block-wrapper">
          <article class="default">
    
    
    
<p>One of the challenges of creating a computer game in the modern day is deciding the resolution you will display the game at.  We discussed this previously in our <a href="https://ksu-cs-textbooks.github.io/cis580/01-intro-to-monogame/03-the-game-window/">coverage of the game window</a>
.  But instead of forcing a single resolution, we can instead use a scaling matrix with our <code>SpriteBatch.Begin()</code> call to adapt to the monitor resolution.</p>
<p>Let&rsquo;s begin by assuming we want to display our game full-screen using the monitor&rsquo;s default resolution.  We can get this from the <code>GraphicsAdapter</code> class (which represents the graphics hardware), and then use that as our preferred back buffer width and height.  This code in the constructor will accomplish this goal:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// Use full-screen at screen resolution</span>
</span></span><span style="display:flex;"><span>DisplayMode screen = GraphicsAdapter.DefaultAdapter.CurrentDisplayMode;
</span></span><span style="display:flex;"><span>_graphics.IsFullScreen = <span style="color:#66d9ef">true</span>;
</span></span><span style="display:flex;"><span>_graphics.PreferredBackBufferWidth = screen.Width;
</span></span><span style="display:flex;"><span>_graphics.PreferredBackBufferHeight = screen.Height;</span></span></code></pre></div><p>Note that if you do this later (i.e. not in your <code>Game</code> class constructor), you&rsquo;ll need to also apply your changes with:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>_graphics.ApplyChanges();</span></span></code></pre></div><p>This is because as the game is constructed, the graphics device has not yet been initialized.  But once it <em>is</em> initialized, it will have to be reset.</p>
<h3 id="deciding-a-design-resolution">Deciding a Design Resolution</h3>
<p>Next you need to decide at what resolution you will <em>design</em> the game for.  This resolution is the size of your viewport <em>as you are calculating it relative to the game world</em>.  So if your entire world should be displayed on-screen, this is the size of the world.  This also determines the ideal dimensions of your sprites and other art in the game - these should all be drawn based on the design resolution.</p>
<p>Ideally, you want your design resolution to be close to the resolution you expect your game to be displayed most commonly, as the game will be scaled to account for any difference between the monitor and game resolution.  You might consider one of the common television resolutions:</p>
<ul>
<li>XVGA (1024x768) is a 4:3 ratio (the same as old TVs), and was once the most common monitor size.</li>
<li>WXVGA (1280x800) is a 16:10 aspect ratio, and displaced XVGA in the mid-2000&rsquo;s.  It is a common resolution for notebook and smartphone screens</li>
<li>720P (1280x720) is a 16:9 aspect ratio, and matches the 720p HDTV standard</li>
<li>1080P (1920x1080) is a 16:9 aspect ratio, and matches the 1020p HDTV standard, used for broadcast television and Blu-ray</li>
<li>4K (3840x2160) is a 16:9 aspect ratio, and is commonly used by 4K consumer electronics</li>
</ul>
<p>You probably want to pick a resolution equal or smaller than your lower-end target devices, as this means your assets will also be designed at a smaller resolution (and therefore require less memory to store).  When rendering your game, you will scale the game up to the actual device resolution.</p>
<p>Now, there are two primary strategies we might want to use for this scaling - scaling our game so that it <em>fits</em> or <em>fills</em> the available screen real estate.  If we are fitting to the screen, and our game uses a different aspect ratio than the monitor, we will have <em>letterboxing</em> (black bars on either the top and bottom or left and right sides of the screen).  Alternatively, if we are filling the screen and the aspect ratios don&rsquo;t match, then part of the game scene will not appear on-screen.</p>
<h3 id="fitting-the-screen">Fitting the Screen</h3>
<p>To fit the screen, we need to scale the game until the bigger dimension matches the corresponding screen dimension.  Then we need to translate our game so it is centered in the other dimension.  Which dimension is bigger depends on the aspect ratios of both your game and screen.  Once we know the larger dimension (our <em>primary</em> dimension), we determine a scaling factor by dividing the corresponding screen dimension by the corresponding game dimension:</p>

<span class="math align-center">$$ scale = \frac{screen_{primary}}{game_{primary}} $$</span>
<p>We will scale both game dimensions using this scaling factor, so that our game maintains its aspect ratio.  If we wish our screen to be centered in the other dimension, we&rsquo;ll need to calculate an offset based on the other dimension (accounting for the scaling of the game screen):</p>

<span class="math align-center">$$ offset_{other} = \frac{(screen_{other} - game_{other} * scale)}{2} $$</span>
<p>We divide the leftover space in half, which determines how far down or over on the screen we need to start rendering our game.</p>
<p>To accomplish this in MonoGame, we might use:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span> <span style="color:#66d9ef">if</span> (screen.AspectRatio &lt; game.AspectRatio)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// letterbox vertically</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Scale game to screen width</span>
</span></span><span style="display:flex;"><span>    _gameScale = (<span style="color:#66d9ef">float</span>)screen.Width / game.Width;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// translate vertically</span>
</span></span><span style="display:flex;"><span>    _gameOffset.Y = (screen.Height - game.Height * _gameScale) / <span style="color:#ae81ff">2f</span>;
</span></span><span style="display:flex;"><span>    _gameOffset.X = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// letterbox horizontally</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Scale game to screen height </span>
</span></span><span style="display:flex;"><span>    _gameScale = (<span style="color:#66d9ef">float</span>)screen.Height / game.Height;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// translate horizontally</span>
</span></span><span style="display:flex;"><span>    _gameOffset.X = (screen.Width - game.Width * _gameScale) / <span style="color:#ae81ff">2f</span>;
</span></span><span style="display:flex;"><span>    _gameOffset.Y = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="filling-the-screen">Filling the Screen</h3>
<p>If instead we wish to fill all available screen space, and our aspect ratios of the game and screen do not match, some of the game will fall off-screen and not be visible.  The process is very similar - first we determine our primary dimension (which is now the <em>smaller</em> dimension - opposite of the scale to fill approach).  Once we know it, we calculate the scale the same way:</p>

<span class="math align-center">$$ scale = \frac{screen_{primary}}{game_{primary}} $$</span>
<p>And we calculate the offset in the other dimension the same way as well:</p>

<span class="math align-center">$$ offset_{other} = \frac{(screen_{other} - game_{other} * scale)}{2} $$</span>
<p>Note that in this case, because the scaled game is larger in the other dimension, this offset is negative.</p>
<p>Example code for MonoGame:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// 1. Determine which dimension must overflow screen </span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(screen.AspectRatio &lt; game.AspectRatio)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// overflow horizontally</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Scale game to screen height </span>
</span></span><span style="display:flex;"><span>    _gameScale = (<span style="color:#66d9ef">float</span>)screen.Height / game.Height;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// translate horizontally </span>
</span></span><span style="display:flex;"><span>    _gameOffset.X = (screen.Width - game.Width * _gameScale) / <span style="color:#ae81ff">2f</span>;
</span></span><span style="display:flex;"><span>    _gameOffset.Y = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// overflow vertically</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Scale game to screen width </span>
</span></span><span style="display:flex;"><span>    _gameScale = (<span style="color:#66d9ef">float</span>)screen.Width / game.Width;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// translate vertically</span>
</span></span><span style="display:flex;"><span>    _gameOffset.Y = (screen.Height - game.Height * _gameScale) / <span style="color:#ae81ff">2f</span>;
</span></span><span style="display:flex;"><span>    _gameOffset.X = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div><h3 id="transforming-the-spritebatch">Transforming the SpriteBatch</h3>
<p>Once we&rsquo;ve calculated our scale and offset, we can use these when invoking <code>SpriteBatch.Begin()</code> to automatically scale and position the game within the available screen real estate.  We first must create a scaling matrix, which will scale up the game scene to our screen, and then we must translate based on our calculated offset to position the game screen within the screen:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span> <span style="color:#75715e">// Determine the necessary transform to scale and position game on-screen</span>
</span></span><span style="display:flex;"><span>Matrix transform =                 
</span></span><span style="display:flex;"><span>    Matrix.CreateScale(_gameScale) * <span style="color:#75715e">// Scale the game to screen size </span>
</span></span><span style="display:flex;"><span>    Matrix.CreateTranslation(_gameOffset.X, _gameOffset.Y, <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// Translate game to letterbox position</span></span></span></code></pre></div><p>Then we can apply this transformation to any <code>SpriteBatch.Begin()</code> call used to render game sprites:</p>
<div class="wrap-code highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">// Draw the game using SpriteBatch</span>
</span></span><span style="display:flex;"><span>_spriteBatch.Begin(transformMatrix: transform);
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//TODO: Draw Calls</span>
</span></span><span style="display:flex;"><span>_spriteBatch.End();</span></span></code></pre></div><h3 id="variations">Variations</h3>
<p>Note that you may choose to <em>not</em> transform and scale some <code>SpriteBatch</code> operations - such as when drawing your GUI.  You can use a separate batch for those (but remember, the bounds of the screen viewport may be different depending on your screen resolution, so you may want to position elements relative to the available space).  Or, you could use the scale-to-fill strategy for your game and the scale-to-fit strategy for your GUI.</p>
<p>Another alternative is that instead of determining the resolution based on the graphics adapter default, you can allow the user to select resolutions from a menu.</p>
<h3 id="github-example">GitHub Example</h3>
<p>I&rsquo;ve posted an example project that allows you to explore these concepts on GitHub: <a href="https://github.com/zombiepaladin/scale-to-screen" target="_blank">https://github.com/zombiepaladin/scale-to-screen</a>
</p>

  
  
<div class="box notices cstyle info">
  <div class="box-label"><i class="fa-fw fas fa-info-circle"></i> Info</div>
  <div class="box-content">

<p>While the discussion here focused on games which are sized to the screen, it can <em>also</em> apply to games in which the world is <em>larger</em> than the screen, and the displayed portions of the game scroll with the player.  In those cases, you still need to define your game&rsquo;s design resolution, which determines how much of the game will appear on-screen at any given time.</p>
<p>You just need to combine the ideas from this approach with those handling scrolling, which we&rsquo;ll talk about next.</p>
</div>
</div>

            <footer class="footline">

            </footer>
          </article>
        </div>
      </main>
    </div>
    
    
    
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/clipboard.min.js?1692031297" defer></script>
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/perfect-scrollbar.min.js?1692031297" defer></script>
    <script>
      function useMathJax( config ){
        if( !Object.assign ){
          
          return;
        }
        window.MathJax = Object.assign( window.MathJax || {}, {
          loader: {
            load: ['[tex]/mhchem']
          },
          startup: {
            elements: [
              '.math'
            ]
          },
          tex: {
            inlineMath: [
              ['$', '$'], 
              ['\\(', '\\)']
            ]
          },
          options: {
            enableMenu: false 
          }
        }, config );
      }
      useMathJax( JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="https://ksu-cs-textbooks.github.io/cis580/js/mathjax/tex-mml-chtml.js?1692031297"></script>
    <script src="https://ksu-cs-textbooks.github.io/cis580/js/theme.js?1692031297" defer></script>
  </body>
</html>
