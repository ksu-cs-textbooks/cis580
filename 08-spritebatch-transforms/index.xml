<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SpriteBatch Transforms :: K-State CIS 580 Textbook</title>
    <link>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/index.html</link>
    <description>Moving in place…</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 Jun 2024 15:18:14 -0500</lastBuildDate>
    <atom:link href="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/01-introduction/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/01-introduction/index.html</guid>
      <description>When we introduced the SpriteBatch, we mentioned that the SpriteBatch.Begin() had some additional arguments we could take advantage of. One of these is for a transformation matrix. This is a matrix that represents the transformation applied to convert the 3D world representation into two dimensions (remember, in MonoGame we’re using 3D hardware to render a 2D game). For many games, the default setting for this transformation matrix is fine - but if we override this, we can create many powerful effects, including:</description>
    </item>
    <item>
      <title>Transforms</title>
      <link>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/02-transforms/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/02-transforms/index.html</guid>
      <description>Before we delve into using the SpriteBatch, let’s quickly revisit the concept of Transformations using Matrices. Our MonoGame games use 3D hardware to render 2D scenes, and the individual sprites are represented as textured quads - a polygon consisting of two triangles arranged in a rectangle. The SpriteBatch computes the coordinates of the corners of this quad from the SpriteBatch.Draw() parameters. These vectors are then transformed for the final drawing process by multiplying them by a matrix specified in the SpriteBatch.</description>
    </item>
    <item>
      <title>Screen Scrolling</title>
      <link>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/03-screen-scrolling/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/03-screen-scrolling/index.html</guid>
      <description>Perhaps the most common use of transforms with the sprite batch is to support screen scrolling, i.e. shifting the viewport (the visible part of the game world) around to allow for larger game worlds.&#xA;Consider what it would take to shift the game world using just what we’ve learned about sprites. We’d need to keep track of an offset for where the viewport begins relative to the world:&#xA;Then, when we draw our game objects (like sprites), we’d need to add this offset vector to the position of each as we draw them:</description>
    </item>
    <item>
      <title>Parallax Scrolling</title>
      <link>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/04-parallax-scrolling/index.html</guid>
      <description>A further refinement of screen scrolling is parallax scrolling, where we seek to emulate depth in our world by scrolling different layers of the game at different speeds, as shown in this example:&#xA;This mimics our perceptions of the world - think to the last time you took a long car trip. How quickly did objects in the distance seem to move relative to your car? How about nearer objects (i.</description>
    </item>
    <item>
      <title>Scaling to the Screen</title>
      <link>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/06-screen-scaling/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/06-screen-scaling/index.html</guid>
      <description>One of the challenges of creating a computer game in the modern day is deciding the resolution you will display the game at. We discussed this previously in our coverage of the game window. But instead of forcing a single resolution, we can instead use a scaling matrix with our SpriteBatch.Begin() call to adapt to the monitor resolution.&#xA;Let’s begin by assuming we want to display our game full-screen using the monitor’s default resolution.</description>
    </item>
    <item>
      <title>Special Effects</title>
      <link>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/05-special-effects/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/05-special-effects/index.html</guid>
      <description>In addition to the more practical uses like scrolling, combining matrix transformations with the SpriteBatch can be used to create a variety of special effects, i.e. zooming into and out of the scene, rotating game worlds, screen shaking, and probably many others.&#xA;Zooming To zoom into the scene, we simply scale up all the elements. However, we need this scaling to occur from the center of the viewport (the part of the game we see).</description>
    </item>
    <item>
      <title>Summary</title>
      <link>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/07-summary/index.html</link>
      <pubDate>Fri, 20 Mar 2020 10:53:05 -0500</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/07-summary/index.html</guid>
      <description>In this chapter we explored using the transformMatrix parameter of SpriteBatch.Begin() to apply a transformation matrix to an entire batch of sprites we are rendering. This provides us with an easy mechanism for implementing a scrolling world in our games. We also looked at how we could clamp that scrolling to keep the edges of the game world on-screen.&#xA;Building upon the scrolling idea, we also examined parallax scrolling, where we create the illusion of depth by scrolling multiple layers at different speeds.</description>
    </item>
  </channel>
</rss>