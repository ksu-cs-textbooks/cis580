<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="Before we delve into using the SpriteBatch, let’s quickly revisit the concept of Transformations using Matrices. Our MonoGame games use 3D hardware to render 2D scenes, and the individual sprites are represented as textured quads - a polygon consisting of two triangles arranged in a rectangle. The SpriteBatch computes the coordinates of the corners of this quad from the SpriteBatch.Draw() parameters. These vectors are then transformed for the final drawing process by multiplying them by a matrix specified in the SpriteBatch.">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="Transforms :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="Before we delve into using the SpriteBatch, let’s quickly revisit the concept of Transformations using Matrices. Our MonoGame games use 3D hardware to render 2D scenes, and the individual sprites are represented as textured quads - a polygon consisting of two triangles arranged in a rectangle. The SpriteBatch computes the coordinates of the corners of this quad from the SpriteBatch.Draw() parameters. These vectors are then transformed for the final drawing process by multiplying them by a matrix specified in the SpriteBatch.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/02-transforms/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Transforms :: K-State CIS 580 Textbook">
    <meta property="og:description" content="Before we delve into using the SpriteBatch, let’s quickly revisit the concept of Transformations using Matrices. Our MonoGame games use 3D hardware to render 2D scenes, and the individual sprites are represented as textured quads - a polygon consisting of two triangles arranged in a rectangle. The SpriteBatch computes the coordinates of the corners of this quad from the SpriteBatch.Draw() parameters. These vectors are then transformed for the final drawing process by multiplying them by a matrix specified in the SpriteBatch.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="SpriteBatch Transforms">
    <meta property="article:published_time" content="2020-03-20T10:53:05-05:00">
    <meta property="article:modified_time" content="2023-08-14T11:41:07-05:00">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="Transforms :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="Before we delve into using the SpriteBatch, let’s quickly revisit the concept of Transformations using Matrices. Our MonoGame games use 3D hardware to render 2D scenes, and the individual sprites are represented as textured quads - a polygon consisting of two triangles arranged in a rectangle. The SpriteBatch computes the coordinates of the corners of this quad from the SpriteBatch.Draw() parameters. These vectors are then transformed for the final drawing process by multiplying them by a matrix specified in the SpriteBatch.">
    <meta itemprop="datePublished" content="2020-03-20T10:53:05-05:00">
    <meta itemprop="dateModified" content="2023-08-14T11:41:07-05:00">
    <meta itemprop="wordCount" content="886">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>Transforms :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/08-spritebatch-transforms/02-transforms/index.html" rel="canonical" type="text/html" title="Transforms :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/02-transforms/index.xml" rel="alternate" type="application/rss+xml" title="Transforms :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/02-transforms/index.print.html" rel="alternate" type="text/html" title="Transforms :: K-State CIS 580 Textbook">
    <link href="/cis580/08-spritebatch-transforms/02-transforms/embed.html" rel="alternate" type="text/html" title="Transforms :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1756153111" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1756153111" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1756153111" defer></script>
    <script src="/cis580/js/search.min.js?1756153111" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1756153111";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1756153111" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1756153111" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1756153111" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1756153111" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1756153111" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1756153111" rel="stylesheet">
    <link href="/cis580/css/format-html.min.css?1756153111" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/08-spritebatch-transforms\/02-transforms\/index.html';
      window.relearn.relBasePath='..\/..';
      window.relearn.relBaseUri='..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1756153111" rel="stylesheet">
  </head>
  <body class="mobile-support html" data-url="/cis580/08-spritebatch-transforms/02-transforms/index.html">
    
    <div id="tele" class="tele mirror">
    
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 08-spritebatch-transforms" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="transforms">Transforms</h1>

<p>Before we delve into using the SpriteBatch, let&rsquo;s quickly revisit the concept of Transformations using Matrices.  Our MonoGame games use 3D hardware to render 2D scenes, and the individual sprites are represented as textured quads - a polygon consisting of two triangles arranged in a rectangle.  The SpriteBatch computes the coordinates of the corners of this quad from the <code>SpriteBatch.Draw()</code> parameters.  These vectors are then <em>transformed</em> for the final drawing process by multiplying them by a matrix specified in the <code>SpriteBatch.Begin()</code> method.</p>
<p>By default, the matrix used by the <code>SpriteBatch</code> is the <em>identity</em> matrix:</p>
<span class="math align-center">$$ 
I = \begin{vmatrix} 1 & 0 & 0 & 0 \\\ 0 & 1 & 0 & 0 \\\ 0 & 0 & 1 & 0 \\\ 0 & 0 & 0 & 1 \end{vmatrix}
 $$</span>
<p>Any vector multiplied by this matrix will be the same vector (This is why it is called the identity matrix, by the way):</p>
<span class="math align-center">$$ 
V_i = V_0 * I = \begin{vmatrix} 4 \\\ 3 \\\ 8 \\\ 1\end{vmatrix} * \begin{vmatrix} 1 & 0 & 0 & 0 \\\ 0 & 1 & 0 & 0 \\\ 0 & 0 & 1 & 0 \\\ 0 & 0 & 0 & 1 \end{vmatrix} = \begin{vmatrix}4 \\\ 3 \\\ 8 \\\ 1 \end{vmatrix}
 $$</span>
<p>But we can substitute a <em>different</em> matrix for the identity matrix.  The most common includes <em>scaling</em>, <em>translation</em>, and <em>rotation</em> matrices.  While it is possible to define the transformation matrices by hand by calling the <code>Matrix</code> constructor, MonoGame provides several methods for creating specific transformation matrices.</p>
<h3 id="scale">Scale</h3>
<p>A Scale matrix is similar to the Identity matrix, but instead of 1s on the diagonal, it provides scaling values:</p>
<span class="math align-center">$$ 
S = \begin{vmatrix} x & 0 & 0 & 0 \\\ 0 & y & 0 & 0 \\\ 0 & 0 & z & 0 \\\ 0 & 0 & 0 & 1 \end{vmatrix}
 $$</span>
<p>Any vector multiplied by this matrix will have its components scaled correspondingly:</p>
<span class="math align-center">$$ 
V_s = V_0 * S = \begin{vmatrix} 4\\\ 3\\\ 8\\\ 1\end{vmatrix} * \begin{vmatrix} x & 0 & 0 & 0\\\ 0 & y & 0 & 0 \\\ 0 & 0 & z & 0 \\\ 0 & 0 & 0 & 1 \end{vmatrix} = \begin{vmatrix}4x\\\ 3y\\\ 8z\\\ 1\end{vmatrix}
 $$</span>
<p>In MonoGame, a scale matrix can be created with one of the following methods:</p>
<ul>
<li><code>Matrix.CreateScale(float x, float y, float z)</code> - A scaling matrix using x, y, and z to scale in the corresponding axes</li>
<li><code>Matrix.CreateScale(Vector3 scale)</code> - A scaling matrix using the x, y, and z components of the Vector3 to scale in the corresponding axes</li>
<li><code>Matrix.CreateScale(float scale)</code> - A scaling matrix that scales equally along the x, y, and z axis by the scale provided</li>
</ul>
<h3 id="translation">Translation</h3>
<p>A Translation matrix also begins with an identity matrix, and adds translation values in the x, y, and z in the fourth row (which is why transforms for 3D math use 4x4 matrices):</p>
<span class="math align-center">$$ 
T = \begin{vmatrix} 1 & 0 & 0 & 0\\\ 0 & 1 & 0 & 0 \\\ 0 & 0 & 1 & 0 \\\ t_x & t_y & t_z & 1 \end{vmatrix}
 $$</span>
<p>Any vector multiplied by this matrix will have its components translated accordingly:</p>
<span class="math align-center">$$ 
V_t = V_0 * T = \begin{vmatrix}4\\\ 3\\\ 8\\\ 1\end{vmatrix} * \begin{vmatrix} 1 & 0 & 0 & 0\\\ 0 & 1 & 0 & 0 \\\ 0 & 0 & 1 & 0 \\\ t_x & t_y & t_z & 1 \end{vmatrix} = \begin{vmatrix}4+t_x\\\ 3+t_y\\\ 8+t_z\\\ 1\end{vmatrix}
 $$</span>
<h3 id="rotation">Rotation</h3>
<p>A rotation matrix is a bit more involved, and there are separate matrices for each primary axis.  In a 2D game, we typically only rotate around the z-axis, whose rotation matrix is:</p>
<span class="math align-center">$$ 
R_z = \begin{vmatrix} \cos{\theta} & \sin{\theta} & 0 & 0\\\ -\sin{\theta} & \cos{\theta} & 0 & 0 \\\ 0 & 0 & 1 & 0 \\\ 0 & 0 & 0 & 1 \end{vmatrix}
 $$</span>
<p>Here <span class="math align-center">$ \theta $</span> is the rotation measured in radians in the clockwise direction.</p>
<p>In MonoGame, a z-Rotation matrix can be created with one of the following method:</p>
<ul>
<li><code>Matrix.CreateRotationZ(float angle)</code> - A rotation matrix about the z-axis using the supplied angle</li>
</ul>
<p>Additionally, rotations about the x and y axes can be created with:</p>
<ul>
<li><code>Matrix.CreateRotationX(float angle)</code> - A rotation matrix about the x-axis using the supplied angle</li>
<li><code>Matrix.CreateRotationY(float angle)</code> - A rotation matrix about the y-axis using the supplied angle</li>
</ul>
<h3 id="composite-transformations">Composite Transformations</h3>
<p>Moreover, we can <em>combine</em> multiple operations by multiplying their matrices together.  I.e. given the translation matrix <span class="math align-center">$ T $</span> and the rotation matrix <span class="math align-center">$ R $</span>, we could apply the translation followed by the rotation by computing a composite matrix <span class="math align-center">$ C $</span> that combines the operations:</p>
<span class="math align-center">$$ 
C = T * R
 $$</span>
<p>In MonoGame we can multiply matrices with <code>Matrix.Multiply()</code> or by using the <code>*</code> operator.  I.e. to perform the translation described above we could use either:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> compositeTransform = Matrix.Multiply(Matrix.CreateTranslation(x, y, z), Matrix.CreateRotation(angle));</span></span></code></pre></div>
<p>or</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> translation = Matrix.CreateTranslation(x, y, z);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> rotation = Matrix.CreateRotation(angle);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> compositeTransform = translation * rotation;</span></span></code></pre></div>

<details open class=" box cstyle notices warning">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-exclamation-triangle"></i> 
    Warning
  </summary>
  <div class="box-content">
<p>The order the matrices are concatenated in determines the order in which the operations are performed!  DirectX (and hence, MonoGame) uses left-to-right order, i.e. the leftmost matrix effect happens <em>first</em>, and the rightmost <em>last</em>.</p>
  </div>
</details>
<p>Now let&rsquo;s put this knowledge of transforms to practical use.</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cis580/js/mathjax/tex-mml-chtml.js?1756153111"></script>
    <script src="/cis580/js/clipboard/clipboard.min.js?1756153111" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1756153111" defer></script>
    <script src="/cis580/js/theme.min.js?1756153111" defer></script>
      
      
      
    </div> 
  <script src="/cis580/js/tele-scroll.min.js?1756153111" defer></script>
  </body>
</html>
