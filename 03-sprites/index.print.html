<!DOCTYPE html>
<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.128.0">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="Who are you calling a fairy?">
    <meta name="author" content="Nathan H. Bean">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta name="twitter:title" content="Sprites :: K-State CIS 580 Textbook">
    <meta name="twitter:description" content="Who are you calling a fairy?">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cis580/03-sprites/index.html">
    <meta property="og:site_name" content="K-State CIS 580 Textbook">
    <meta property="og:title" content="Sprites :: K-State CIS 580 Textbook">
    <meta property="og:description" content="Who are you calling a fairy?">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <meta itemprop="name" content="Sprites :: K-State CIS 580 Textbook">
    <meta itemprop="description" content="Who are you calling a fairy?">
    <meta itemprop="datePublished" content="2018-08-24T10:53:05-05:00">
    <meta itemprop="dateModified" content="2025-08-19T13:21:42-05:00">
    <meta itemprop="wordCount" content="6">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cis580/images/hero.png">
    <title>Sprites :: K-State CIS 580 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cis580/03-sprites/index.html" rel="canonical" type="text/html" title="Sprites :: K-State CIS 580 Textbook">
    <link href="/cis580/03-sprites/index.xml" rel="alternate" type="application/rss+xml" title="Sprites :: K-State CIS 580 Textbook">
    <link href="/cis580/03-sprites/tele.html" rel="alternate" type="text/html" title="Sprites :: K-State CIS 580 Textbook">
    <link href="/cis580/03-sprites/embed.html" rel="alternate" type="text/html" title="Sprites :: K-State CIS 580 Textbook">
    <link href="/cis580/css/auto-complete/auto-complete.min.css?1755628803" rel="stylesheet">
    <script src="/cis580/js/auto-complete/auto-complete.min.js?1755628803" defer></script>
    <script src="/cis580/js/search-lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/search.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cis580/searchindex.en.js?1755628803";
    </script>
    <script src="/cis580/js/lunr/lunr.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.stemmer.support.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.multi.min.js?1755628803" defer></script>
    <script src="/cis580/js/lunr/lunr.en.min.js?1755628803" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cis580/fonts/fontawesome/css/fontawesome-all.min.css?1755628803" rel="stylesheet"></noscript>
    <link href="/cis580/css/perfect-scrollbar/perfect-scrollbar.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/theme.min.css?1755628803" rel="stylesheet">
    <link href="/cis580/css/format-print.min.css?1755628803" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/03-sprites\/index.html';
      window.relearn.relBasePath='..';
      window.relearn.relBaseUri='..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cis580';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cis580/css/custom.css?1755628803" rel="stylesheet">
  </head>
  <body class="mobile-support print" data-url="/cis580/03-sprites/index.html">
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      <nav id="R-topbar">
        <div class="topbar-wrapper">
          <div class="topbar-sidebar-divider"></div>
          <div class="topbar-area topbar-area-start" data-area="start">
            <div class="topbar-button topbar-button-sidebar" data-content-empty="disable" data-width-s="show" data-width-m="hide" data-width-l="hide"><button class="topbar-control" onclick="toggleNav()" type="button" title="Menu (CTRL&#43;ALT&#43;n)"><i class="fa-fw fas fa-bars"></i></button>
            </div>
            <div class="topbar-button topbar-button-toc" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="Table of Contents (CTRL&#43;ALT&#43;t)"><i class="fa-fw fas fa-list-alt"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper"> 
                </div>
              </div>
            </div>
          </div>
          <ol class="topbar-breadcrumbs breadcrumbs highlightable" itemscope itemtype="http://schema.org/BreadcrumbList"><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class="a11y-only"><a itemprop="item" href="/cis580/index.html"><span itemprop="name">CIS 580: Foundations of Game Programming</span></a><meta itemprop="position" content="1">&nbsp;>&nbsp;</li><li itemscope itemtype="https://schema.org/ListItem" itemprop="itemListElement" class=""><span itemprop="name">Sprites</span><meta itemprop="position" content="2"></li>
          </ol>
          <div class="topbar-area topbar-area-end" data-area="end">
            <div class="topbar-button topbar-button-edit" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="https://github.com/ksu-cs-textbooks/cis580/edit/master/content/03-sprites/_index.md" rel="external" target="_blank" title="Edit (CTRL+ALT+w)"><i class="fa-fw fas fa-pen"></i></a>
            </div>
            <div class="topbar-button topbar-button-print" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/03-sprites/index.print.html" title="Print whole chapter (CTRL+ALT+p)"><i class="fa-fw fas fa-print"></i></a>
            </div>
            <div class="topbar-button topbar-button-prev" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/02-player-input/08-summary/index.html" title="Summary (🡐)"><i class="fa-fw fas fa-chevron-left"></i></a>
            </div>
            <div class="topbar-button topbar-button-next" data-content-empty="disable" data-width-s="show" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/03-sprites/01-introduction/index.html" title="Introduction (🡒)"><i class="fa-fw fas fa-chevron-right"></i></a>
            </div>
            <div class="topbar-button topbar-button-more" data-content-empty="hide" data-width-s="show" data-width-m="show" data-width-l="show"><button class="topbar-control" onclick="toggleTopbarFlyout(this)" type="button" title="More"><i class="fa-fw fas fa-ellipsis-v"></i></button>
              <div class="topbar-content">
                <div class="topbar-content-wrapper">
                  <div class="topbar-area topbar-area-more" data-area="more">
            <div class="topbar-button topbar-button-embed" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/03-sprites/embed.html" title="Embeddable Version"><i class="fa-fw fas fa-expand-arrows-alt"></i></a>
            </div>
            <div class="topbar-button topbar-button-tele" data-content-empty="disable" data-width-s="area-more" data-width-m="show" data-width-l="show"><a class="topbar-control" href="/cis580/03-sprites/tele.html" title="Teleprompter View"><i class="fa-fw fas fa-tv"></i></a>
            </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable 03-sprites" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="sprites">Sprites</h1>

<p>Who are you calling a fairy?</p>
<img src="https://media.giphy.com/media/6AreExUaRw1qw/giphy.gif">
  <footer class="footline">
  </footer>
</article>
          <section>
            <h1 class="a11y-only">Subsections of Sprites</h1>
<article class="default">
  <header class="headline">
  </header>

<h1 id="introduction">Introduction</h1>

<p>The term &ldquo;sprite&rdquo; refers to a graphical element within a two-dimensional game that moves around the screen - often representing a character, powerup, or other actor.  The term likely was coined in relation to its older definition - a small fairy creature.</p>
<p>Traditionally, sprites are a part of two-dimensional games, and are a <em>raster</em> graphic (one composed of a regular grid of pixels, aka a bitmap).  As the sprites are simply an array of bits representing pixels, and the scene being presented on screen is <em>also</em> just an array of bits representing pixels, we can place a sprite on-screen by simply copying its bits into the right location.</p>
<h2 id="hardware-sprites">Hardware Sprites</h2>
<p>The earliest implementations of sprites did this by substituting the sprite bits for background image bits <em>as the bits were streamed to the screen</em> as part of an analog frame signal.  This was done by specialized hardware that supported a limited number of sprites (hence the name <em>hardware sprites</em>).</p>
<h2 id="bit-blitting">Bit Blitting</h2>
<p>Later games used <em>bit blitting</em> (an abbreviation for bit-boundary block transfer), a technique for copying a smaller bit array into a larger one.  Early graphics hardware implemented bit blitting as a hardware instruction, meaning it could be performed very fast, provided the sprite was drawn to scale.</p>
<h2 id="textured-quads">Textured Quads</h2>
<p>Modern games (and MonoGame) often use the 3D hardware to render sprites, which means they are represented as <em>textured quads</em>.  A textured quad is essentially a rectangle composed of two triangles that always faces the screen.</p>
<p>While it is more complex than traditional sprites, there are several benefits to this approach:</p>
<ol>
<li>It is far easier to scale sprites composed as textured quads than bit-blitted sprites (and scaling is impossible with most hardware sprites)</li>
<li>Textured Quad sprites can be rotated to an arbitrary angle using the graphics hardware.  Bit-blitted sprites could only be flipped (mirrored) in the X or Y direction, true rotations required additional sprite images drawn from the desired angle</li>
<li>Textured Quad sprites can take advantage of the Z-buffer to do depth sorting.  Traditional bit-blitted sprites had to be drawn using the <em>painters algorithm</em> or similar techniques to ensure proper layering.</li>
<li>Textured sprites are rendered using <em>shader</em> programs on the graphics card, so many unique effects can be applied to them.</li>
</ol>
<p>In this chapter, we&rsquo;ll examine how the MonoGame implementation of textured quads works.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="drawing-sprites">Drawing Sprites</h1>

<p>MonoGame provides the <a href="https://docs.monogame.net/api/Microsoft.Xna.Framework.Graphics.SpriteBatch.html" rel="external" target="_blank"><code>SpriteBatch</code></a> class to help mitigate the complexity of implementing textured quad sprites.  It provides an abstraction around the rendering process that lets us render sprites with a minimum of fuss, with as much control as we might need.</p>
<p>As the name suggests, the <code>SpriteBatch</code> <em>batches</em> sprite draw requests so that they can be drawn in an optimized way.  We&rsquo;ll explore the different modes we can put the <code>SpriteBatch</code> in soon.  But for now, this explains why every batch begins with a call to <code>SpriteBatch.Begin()</code>, then an arbitrary number of <code>SpriteBatch.Draw()</code> calls, followed by a <code>SpriteBatch.End()</code> call.</p>
<p>We&rsquo;ve already used this pattern in our Hello Game example from chapter 1:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>    _spriteBatch.Begin();            
</span></span><span style="display:flex;"><span>    _spriteBatch.Draw(_ballTexture, _ballPosition, Color.White);
</span></span><span style="display:flex;"><span>    _spriteBatch.End();</span></span></code></pre></div>
<p>In this example, we draw a single sprite, using the <code>_ballTexture</code>, and drawing the graphic it represents with the upper-right corner at <code>_ballPosition</code>, and blend white (<code>Color.White</code>) with the sprite texture&rsquo;s own colors.</p>
<p>The <code>SpriteBatch.Draw()</code> method actually has a seven available overrides for your use:</p>
<ul>
<li><code>public void Draw(Texture2D texture, Rectangle destinationRectangle, Color color)</code></li>
<li><code>public void Draw(Texture2D texture, Rectangle destinationRectangle, Rectangle? sourceRectangle, Color color)</code></li>
<li><code>public void Draw(Texture2D texture, Rectangle destinationRectangle, Rectangle? sourceRectangle, Color color, float rotation, Vector2 origin, SpriteEffects effects, float layerDepth)</code></li>
<li><code>Draw(Texture2D texture, Vector2 position, Color color)</code></li>
<li><code>Draw(Texture2D texture, Vector2 position, Rectangle? sourceRectangle, Color color)</code></li>
<li><code>Draw(Texture2D texture, Vector2 position, Rectangle? sourceRectangle, Color color, float rotation, Vector2 origin, Vector2 scale, SpriteEffects effects, float layerDepth)</code></li>
<li><code>Draw(Texture2D texture, Vector2 position, Rectangle? sourceRectangle, Color color, float rotation, Vector2 origin, float scale, SpriteEffects effects, float layerDepth)</code></li>
</ul>
<p>Rather than explain each one individually, we&rsquo;ll explore what the various parameters are used for, and you can select the one that matches your needs.</p>
<h4 id="texture2d-texture">Texture2D texture</h4>
<p>The <code>texture</code> parameter is a <code>Texture2D</code> containing the sprite you want to draw.  Every override includes this parameter.  If the texture has not been loaded (is null), then invoking <code>Draw()</code> will throw an <code>ArgumentNullException</code>.</p>
<h4 id="rectangle-destinationrectangle">Rectangle destinationRectangle</h4>
<p>The <code>destinationRectangle</code> is a rectangle whose coordinates are where the sprite should be drawn, in screen coordinates.  If the rectangle&rsquo;s dimensions are not the same as those of the source image (or the sub-image specified by <code>sourceRectangle</code>), it will be scaled to match.  If the aspect ratios are different, this will result in a stretched or squished sprite.  Note that the <code>Rect</code> uses integers for coordinates, so calculated floats used to place the sprite will potentially be truncated.</p>
<h4 id="color-color">Color color</h4>
<p>The <code>color</code> parameter is a <code>Color</code> that will be blended with the colors in the texture to determine the final color of the sprite.  Using <code>Color.White</code> effectively keeps the texture color the same, while using <code>Color.Red</code> will make the sprite&rsquo;s pixels all redder, <code>Color.Yellow</code> will make them more yellow, etc.  This parameter can be utilized to make the sprite flash different colors for damage, invulnerability, etc.</p>
<h4 id="vector2-position">Vector2 position</h4>
<p>As an alternative to the <code>destinationRectangle</code>, a sprite&rsquo;s position on-screen can be specified with <code>position</code>, which is a <code>Vector2</code>.  This position specifies the upper-left hand corner of where the sprite will be drawn on-screen (unless the <code>origin</code> parameter is set).  Note that when we use the <code>position</code> parameter, the width and height matches that of the texture (or sub-image specified by the <code>sourceRectangle</code>), unless a <code>scale</code> is also provided.</p>
<h4 id="rectangle-sourcerectangle">Rectangle? sourceRectangle</h4>
<p>The <code>sourceRectangle</code> is a rectangle that defines a <em>subarea</em> of the source texture (<code>texture</code>) to use as the sprite.  This is useful for <em>texture atlases</em>, where more than one sprite appear in the same texture, and also for <em>sprite animation</em> where multiple frames of animation appear in the same texture.  We&rsquo;ll discuss both of these approaches soon.</p>
<p>Note that the question mark in <code>Rectangle?</code> indicates it is a <em>nullable</em> type (i.e. it can be null as well as the <code>Rectangle</code> struct).  When it is <code>null</code>, the entire texture is used as the <code>sourceRectangle</code>.</p>
<h4 id="float-rotation">float rotation</h4>
<p>The <code>rotation</code> is a rotation value measured in radians that should be applied to the sprite.  This is one of the big benefits of textured quad sprites, as the graphics hardware makes rotations a very efficient operation (without this hardware, it becomes a much more difficult and computationally expensive operation).  This rotation is about the <code>origin</code> of the sprite, which is why all the overrides that specify the <code>rotation</code> also specify the <code>origin</code>.</p>
<h4 id="vector2-origin">Vector2 origin</h4>
<p>The <code>origin</code> is the spot within the sprite where rotations and scaling are centered.  This <em>also</em> affects sprite placement - the <code>position</code> vector indicates where the <code>origin</code> of the sprite will fall on-screen.  It is a vector measured relative to the upper-left-hand-corner of the sprite, in <em>texture</em> coordinates (i.e. pixels of the source texture).</p>
<p>Thus, for our 64x64 pixel ball texture, if we wanted the origin to be at the center, we would specify a value of <code>new Vector2(32,32)</code>.  This would also mean that when our ball was at position <span class="math align-center">$ (0,0) $</span>, it would be centered on the origin and 3/4 of the ball would be off-screen.</p>
<h4 id="float-scale">float scale</h4>
<p>The <code>scale</code> is a scalar value to scale the sprite by.  For example, a value of <span class="math align-center">$ 2.0f $</span> will make the sprite twice as big, while <span class="math align-center">$ 0.5f $</span> would make it half as big.  This scaling is in relation to the <code>origin</code>, so if the origin is at the center of the sprite grows in all directions equally.  If instead it is at <span class="math align-center">$ (0,0) $</span>, the sprite will grow to the right and down only.</p>
<h4 id="vector2-scale">Vector2 scale</h4>
<p>The <code>scale</code> can also be specified as a <code>Vector2</code>, which allows for a different horizontal and vertical scaling factor.</p>
<h4 id="spriteeffects-effects">SpriteEffects effects</h4>
<p>The <code>effects</code> parameter is one of the <code>SpriteEffects</code> enum&rsquo;s values.  These are:</p>
<ul>
<li><code>SpriteEffects.None</code> - the sprite is drawn normally</li>
<li><code>SpriteEffects.FlipHorizontally</code> - the sprite is drawn with the texture flipped in the horizontal direction</li>
<li><code>SpriteEffects.FlipVertically</code> - the sprite is drawn with the texture flipped in the vertical direction</li>
</ul>
<p>Note you can specify both horizontal and vertical flipping with a bitwise or: <code>SpriteEffects.FlipHorizontally | SpriteEffects.FlipVertically</code></p>
<h4 id="single-layerdepth">single layerDepth</h4>
<p>The <code>layerDepth</code> is an integer that indicates which sprites should be drawn &ldquo;above&rdquo; or &ldquo;below&rdquo; others (i.e. which ones should obscure the others).  Think of it as assembling a collage.  Sprites with a higher <code>layerDepth</code> value are closer to the top, and if they share screen space with sprites with a <code>lowerDepth</code>, those sprites are obscured.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="texture-atlases">Texture Atlases</h1>

<p>A <em>texture atlas</em> is a texture that is used to represent <em>multiple</em> sprites.  For example, this texture from Kinney&rsquo;s 1Bit Pack <a href="https://opengameart.org/content/1-bit-pack" rel="external" target="_blank">available on OpenGameArt</a> contains all the sprites to create a roguelike in a single texture:</p>
<p><a href="#R-image-f487067aeb75999b13701e3f8e86b47f" class="lightbox-link"><img alt="Kinney&rsquo;s 1Bit Pack Texture Atlas" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/1bitpack/colored_packed.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f487067aeb75999b13701e3f8e86b47f"><img alt="Kinney&rsquo;s 1Bit Pack Texture Atlas" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/1bitpack/colored_packed.png"></a></p>
<p>In this case, each sprite is 15x15 pixels, with a 1 pixel outline.  So to draw the cactus in the second row and sixth column of sprites, we would use a source rectangle:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> sourceRect = <span style="color:#66d9ef">new</span> Rectangle(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">96</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">16</span>);</span></span></code></pre></div>
<p>Thus, to draw the sprite on-screen at position <span class="math align-center">$ (50,50) $</span> we could use:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">override</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    GraphicsDevice.Clear(Color.CornflowerBlue);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// TODO: Add your drawing code here</span>
</span></span><span style="display:flex;"><span>    spriteBatch.Begin();
</span></span><span style="display:flex;"><span>    spriteBatch.Draw(atlas, <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">50</span>), <span style="color:#66d9ef">new</span> Rectangle(<span style="color:#ae81ff">96</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">15</span>), Color.White);
</span></span><span style="display:flex;"><span>    spriteBatch.End();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">base</span>.Draw(gameTime);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>And we&rsquo;d see:</p>
<p><a href="#R-image-a29c0a10010a61fc45545e9247d0beff" class="lightbox-link"><img alt="The rendered sprite from the sprite atlas" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/3.3.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a29c0a10010a61fc45545e9247d0beff"><img alt="The rendered sprite from the sprite atlas" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/3.3.1.png"></a></p>
<p>This texture atlas is laid out in 16x16 tiles, which makes calculating the <code>X</code> and <code>Y</code> of our source rectangle straightforward:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> x = xIndex * <span style="color:#ae81ff">16</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> y = yIndex * <span style="color:#ae81ff">16</span>;</span></span></code></pre></div>
<p>The formula involved for a particular texture atlas will depend on the size and spacing between sprites.  Also, some texture atlases are not evenly spaced.  In those cases, it may be useful to define a <code>Rectangle</code> constant for each one, i.e.</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> Rectangle helicopterSource = <span style="color:#66d9ef">new</span> Rectangle(<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">200</span>, <span style="color:#ae81ff">80</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">const</span> Rectangle missileSource = <span style="color:#66d9ef">new</span> Rectangle(<span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">210</span>, <span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">3</span>);</span></span></code></pre></div>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>The texture used in the above example has a brown background.  If you would like to replace this with transparent black, you can set a <em>color key color</em> in the mgcb content editor.  Any pixel this color in the source image will be turned into transparent black when the content is compiled.  In this case, our color&rsquo;s RGB values are (71, 45, 60):</p>
<p><a href="#R-image-c16a83e185061461dd7f460693a1cefc" class="lightbox-link"><img alt="Setting the Color Key Color" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/3.3.2.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-c16a83e185061461dd7f460693a1cefc"><img alt="Setting the Color Key Color" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/3.3.2.png"></a></p>
<p>The result is that sprites rendered from the texture now have a transparent background:</p>
<p><a href="#R-image-05091a1b1928b2f69de5c03dd756fe29" class="lightbox-link"><img alt="The rendered sprite with a transparent background" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/3.3.3.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-05091a1b1928b2f69de5c03dd756fe29"><img alt="The rendered sprite with a transparent background" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/3.3.3.png"></a></p>
  </div>
</details>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="animated-sprites">Animated Sprites</h1>

<p>To animate a sprite, we simply swap the image it is using.  Animated sprites typically lay out all their frames in a single texture, just like a texture atlas. Consider this <a href="https://opengameart.org/content/bat-sprite" rel="external" target="_blank">animated bat sprite by bagzie</a> from OpenGameArt:</p>
<p><a href="#R-image-3cd7a53f397c9684432c76e07a5d4572" class="lightbox-link"><img alt="Animated bat spritesheet" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/32x32-bat-sprite.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-3cd7a53f397c9684432c76e07a5d4572"><img alt="Animated bat spritesheet" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/32x32-bat-sprite.png"></a></p>
<p>The images of the bat are laid out into a 4x4 grid of 32x32 pixel tiles.  We can create the illusion of motion by swapping which of these images we display.  However, we don&rsquo;t want to swap it every frame - doing so will be too quick for the viewer to follow, and destroy the illusion.  So we also need a timer and an idea of the direction the sprite is facing.</p>
<p>To represent the direction, we might define an enum. And since the enum can represent a numerical value, let&rsquo;s assign the corresponding row index to each direction:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// The directions a sprite can face </span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> Direction {
</span></span><span style="display:flex;"><span>    Down = <span style="color:#ae81ff">0</span>,
</span></span><span style="display:flex;"><span>    Right = <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    Up = <span style="color:#ae81ff">2</span>, 
</span></span><span style="display:flex;"><span>    Left = <span style="color:#ae81ff">3</span> 
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>With this extra state to track, it makes sense to create a class to represent our sprite:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// A class representing a bat</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">BatSprite</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The animated bat texture </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> Texture2D texture;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// A timer variable for sprite animation</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span> directionTimer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// A timer variable for sprite animation</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">double</span> animationTimer;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// The current animation frame </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">short</span> animationFrame;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">///&lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The bat&#39;s position in the world</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">///&lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Vector2 Position { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">///&lt;summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// The bat&#39;s direction</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> Direction Direction { <span style="color:#66d9ef">get</span>; <span style="color:#66d9ef">set</span>; }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We&rsquo;ll need a <code>LoadContent()</code> method to load our texture:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#75715e">/// &lt;summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// Loads the bat sprite texture</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;/summary&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/// &lt;param name=&#34;content&#34;&gt;The ContentManager&lt;/param&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> LoadContent(ContentManager content) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    texture = content.Load&lt;Texture2D&gt;(<span style="color:#e6db74">&#34;32x32-bat-sprite.png&#34;</span>);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Let&rsquo;s make our bat fly in a regular pattern, switching directions every two seconds.  To do this, we would want to give our bat an <code>Update()</code> method that updates a timer to determine when it is time to switch:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Update(GameTime gameTime) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// advance the direction timer</span>
</span></span><span style="display:flex;"><span>    directionTimer += gameTime.ElapsedGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// every two seconds, change direction</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(directionTimer &gt; <span style="color:#ae81ff">2.0</span>) 
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">switch</span>(Direction)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> Direction.Up: 
</span></span><span style="display:flex;"><span>                Direction = Direction.Down;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> Direction.Down:
</span></span><span style="display:flex;"><span>                Direction = Direction.Left;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> Direction.Left:
</span></span><span style="display:flex;"><span>                Direction = Direction.Right;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">case</span> Direction.Right:
</span></span><span style="display:flex;"><span>                Direction = Direction.Up;
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// roll back timer </span>
</span></span><span style="display:flex;"><span>        directionTimer -= <span style="color:#ae81ff">2.0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// move bat in desired direction</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">switch</span> (Direction)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> Direction.Up:
</span></span><span style="display:flex;"><span>            Position += <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">0</span>, -<span style="color:#ae81ff">1</span>) * <span style="color:#ae81ff">100</span> * (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> Direction.Down:
</span></span><span style="display:flex;"><span>            Position += <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>) * <span style="color:#ae81ff">100</span> * (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> Direction.Left:
</span></span><span style="display:flex;"><span>            Position += <span style="color:#66d9ef">new</span> Vector2(-<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>) * <span style="color:#ae81ff">100</span> * (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">case</span> Direction.Right:
</span></span><span style="display:flex;"><span>            Position += <span style="color:#66d9ef">new</span> Vector2(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>) * <span style="color:#ae81ff">100</span> * (<span style="color:#66d9ef">float</span>)gameTime.ElapsedGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>We&rsquo;ll use a similar technique to advance the animation frame - once every 16th of a second, in the <code>Draw()</code> method:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> Draw(GameTime gameTime, SpriteBatch spriteBatch) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// advance the animation timer </span>
</span></span><span style="display:flex;"><span>    animationTimer += gameTime.ElapsedGameTime.TotalSeconds;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Every 1/16th of a second, advance the animation frame </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(animationTimer &gt; <span style="color:#ae81ff">1</span>/<span style="color:#ae81ff">16</span>)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        animationFrame++;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(animationFrame &gt; <span style="color:#ae81ff">3</span>) animationFrame = <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        animationTimer -= <span style="color:#ae81ff">1</span>/<span style="color:#ae81ff">16</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Determine the source rectangle </span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">var</span> sourceRect = <span style="color:#66d9ef">new</span> Rectangle(animationFrame * <span style="color:#ae81ff">32</span>, (<span style="color:#66d9ef">int</span>)Direction * <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">32</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Draw the bat using the current animation frame </span>
</span></span><span style="display:flex;"><span>    spriteBatch.Draw(texture, Position, sourceRect, Color.White);
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>Notice because our <code>Direction</code> enum uses integer values, we can cast it to be an <code>int</code> and use it to calculate the <code>sourceRect</code>&rsquo;s x-coordinate.</p>
<p>We can then construct a bat (or multiple bats) in our game, and invoke their <code>LoadContent()</code>, <code>Update()</code>, and <code>Draw()</code> methods in the appropriate places.</p>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Info
  </summary>
  <div class="box-content">
<p>You may have noticed that our <code>BatSprite</code> can be thought of as a <em>state machine</em>, or the <a href="https://gameprogrammingpatterns.com/state.html" rel="external" target="_blank">state pattern</a>.  You could argue that we have four possible states for each of the directions that bat is flying.  Moreover, you could argue that each of those states has four sub-states for the animation frame that is being displayed.  These are both accurate observations - the state pattern is an <em>extremely useful</em> one in game design.</p>
  </div>
</details>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="sprite-text">Sprite Text</h1>

<p>Text in videogames is challenging.  In the early days of computing, video cards had a limited number of modes - the most common was for displaying text that was streamed to the video card as ASCII character data.  This is also how the command prompt and terminals work - they operate on streams of character data.</p>
<p>But games used <em>different</em> modes that used the limited memory of the card to supply pixel data in a variety of formats.  Notably, text support was non-existent in these modes.</p>
<p>Fast-forward to the modern day.  Now text is typically handled by the operating system and its windowing libraries.  Which are notably unusable within a DirectX rendering context.  So we still use the same techniques used in those earliest video games to render text.  Bitmap fonts.</p>
<p>A bitmap font is one in which each character is represented by a raster graphic - a bitmap.  Much like sprites, these are copied into the bitmap that is the scene.  Thus, we have to bit blit each character one at a time.  This is in contrast to the fonts used by modern operating systems, which are <em>vector</em> based.  A vector font contains the <em>instructions</em> for drawing the font characters, so it can be drawn at any scale.</p>
<p>MonoGame provides some support for drawing text through the <code>SpriteBatch</code>.  But to use this functionality, we first need to create a <code>SpriteFont</code></p>
<h2 id="spritefonts">SpriteFonts</h2>
<p>A <code>SpriteFont</code> object is similar to the sprite <code>BatSprite</code> class we worked on in the last section.  It wraps around a texture containing rendered font characters, and provides details on how to render each character.  However, we don&rsquo;t construct <code>SpriteFont</code> objects ourselves, rather we load them through the <code>ContentManager</code> and the content pipeline.</p>
<p>The content pipeline <em>creates</em> a sprite font from an existing font installed on your computer.  Essentially, it renders each needed character from the font into a texture atlas, and combines that with information about where each character is in that atlas.  To create your sprite font, choose the <em>create new item</em> from the MGCB Editor, and then select &ldquo;SpriteFont Description (.spritefont)&rdquo;:</p>
<p><a href="#R-image-15e3d15cdd31eb2d8aebb006ff3fce3f" class="lightbox-link"><img alt="Creating the sprite font in the MGCB Editor" class="border lazy lightbox figure-image" loading="lazy" src="/cis580/images/3.5.1.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-15e3d15cdd31eb2d8aebb006ff3fce3f"><img alt="Creating the sprite font in the MGCB Editor" class="border lazy lightbox lightbox-image" loading="lazy" src="/cis580/images/3.5.1.png"></a></p>
<p>This will create a SpriteFont Description, which will be compiled into a <code>SpriteFont</code>.  It also adds this description into your <em>Content</em> folder.  Open it, and you will see it is nothing more than an XML file, which specifies some details of the font:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="color:#75715e">&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">&lt;!--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">This file contains an xml description of a font, and will be read by the XNA
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Framework Content Pipeline. Follow the comments to customize the appearance
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">of the font in your game, and to change the characters which are available to draw
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">with.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">--&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;XnaContent</span> <span style="color:#a6e22e">xmlns:Graphics=</span><span style="color:#e6db74">&#34;Microsoft.Xna.Framework.Content.Pipeline.Graphics&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&lt;Asset</span> <span style="color:#a6e22e">Type=</span><span style="color:#e6db74">&#34;Graphics:FontDescription&#34;</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    Modify this string to change the font that will be imported.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;FontName&gt;</span>Arial<span style="color:#f92672">&lt;/FontName&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    Size is a float value, measured in points. Modify this value to change
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    the size of the font.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Size&gt;</span>12<span style="color:#f92672">&lt;/Size&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    Spacing is a float value, measured in pixels. Modify this value to change
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    the amount of spacing in between characters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Spacing&gt;</span>0<span style="color:#f92672">&lt;/Spacing&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    UseKerning controls the layout of the font. If this value is true, kerning information
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    will be used when placing characters.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;UseKerning&gt;</span>true<span style="color:#f92672">&lt;/UseKerning&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    Style controls the style of the font. Valid entries are &#34;Regular&#34;, &#34;Bold&#34;, &#34;Italic&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    and &#34;Bold, Italic&#34;, and are case sensitive.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;Style&gt;</span>Regular<span style="color:#f92672">&lt;/Style&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    If you uncomment this line, the default character will be substituted if you draw
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    or measure text that contains characters which were not included in the font.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!-- &lt;DefaultCharacter&gt;*&lt;/DefaultCharacter&gt; --&gt;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">&lt;!--
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    CharacterRegions control what letters are available in the font. Every
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    character from Start to End will be built and made available for drawing. The
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    default range is from 32, (ASCII space), to 126, (&#39;~&#39;), covering the basic Latin
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    character set. The characters are ordered according to the Unicode standard.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    See the documentation for more information.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">    --&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;CharacterRegions&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;CharacterRegion&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;Start&gt;</span>&amp;#32;<span style="color:#f92672">&lt;/Start&gt;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&lt;End&gt;</span>&amp;#126;<span style="color:#f92672">&lt;/End&gt;</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">&lt;/CharacterRegion&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">&lt;/CharacterRegions&gt;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&lt;/Asset&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">&lt;/XnaContent&gt;</span></span></span></code></pre></div>
<p>You can edit the values of the various elements to control the font, as well as attributes like size and style that will be used to create the raster representation.  Any font installed on your development machine can be used (though for uncommon fonts, it is a good idea to include the font&rsquo;s file, usually a .ttf, in your repository so you can install it on other development machines).</p>
<p>The <code>SpriteFont</code> can then be loaded with the <code>ContentManager</code>:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-csharp" data-lang="csharp"><span style="display:flex;"><span>SpriteFont spriteFont = Content.Load&lt;SpriteFont&gt;(<span style="color:#e6db74">&#34;name-of-spritefont&#34;</span>);</span></span></code></pre></div>
<p>Where the supplied string is the same name as the <em>.spritefont</em> file, without the extension.</p>
<p>Once loaded, text can be drawn to the screen with <code>SpriteBatch.DrawString(SpriteFont spriteFont, Vector2 position, Color color)</code>. There are several overrides to choose from:</p>
<ul>
<li><code>DrawString(SpriteFont spriteFont, string text, Vector2 position, Color color)</code></li>
<li><code>DrawString(SpriteFont spriteFont, string text, Vector2 position, Color color, float rotation, Vector2 origin, Vector2 scale, SpriteEffects effects, float layerDepth)</code></li>
<li><code>DrawString(SpriteFont spriteFont, string text, Vector2 position, Color color, float rotation, Vector2 origin, float scale, SpriteEffects effects, float layerDepth)</code></li>
<li><code>DrawString(SpriteFont spriteFont, StringBuilder text, Vector2 position, Color color)</code></li>
<li><code>DrawString(SpriteFont spriteFont, StringBuilder text, Vector2 position, Color color, float rotation, Vector2 origin, Vector2 scale, SpriteEffects effects, float layerDepth)</code></li>
<li><code>DrawString(SpriteFont spriteFont, StringBuilder text, Vector2 position, Color color, float rotation, Vector2 origin, float scale, SpriteEffects effects, float layerDepth)</code></li>
</ul>
<p>As with <code>SpriteBatch.Draw()</code>, we&rsquo;ll explore what the various parameters are used for, and you can select the one that matches your needs.</p>
<h4 id="spritefont-spritefont">SpriteFont spriteFont</h4>
<p>The <code>spriteFont</code> parameter is a <code>SpriteFont</code> object describing the font you want to write with.  If the <code>SpriteFont</code> has not been loaded (is null), then invoking <code>DrawText()</code> will throw an <code>ArgumentNullException</code>.</p>
<h4 id="string-text">string text</h4>
<p>The <code>text</code> parameter is the string you want to draw onto the screen.</p>
<h4 id="stringbuilder-text">StringBuilder text</h4>
<p>Optionally, a <code>StringBuilder</code> object can be supplied as the <code>text</code> parameter.</p>
<h4 id="vector2-position">Vector2 position</h4>
<p>This position specifies the upper-left hand corner of where the text will be drawn on-screen (unless the <code>origin</code> parameter is set).</p>
<h4 id="color-color">Color color</h4>
<p>The <code>color</code> parameter is a <code>Color</code> the text will be rendered in (this is actually blended as is with sprites, but the base color is white, so whatever color you choose is the color that will be displayed)</p>
<h4 id="float-rotation">float rotation</h4>
<p>The <code>rotation</code> is a rotation value measured in radians that should be applied to the text. This rotation is about the <code>origin</code> of the sprite, which is why all the overrides that specify the <code>rotation</code> also specify the <code>origin</code>.</p>
<h4 id="vector2-origin">Vector2 origin</h4>
<p>The <code>origin</code> is the spot within the text where rotations and scaling are centered.  This <em>also</em> affects text placement - the <code>position</code> vector indicates where the <code>origin</code> of the text will fall on-screen.  It is a vector measured relative to the upper-left-hand-corner of the text, in <em>texture</em> coordinates (i.e. pixels of the source texture).</p>
<h4 id="float-scale">float scale</h4>
<p>The <code>scale</code> is a scalar value to scale the text by.  For example, a value of <span class="math align-center">$ 2.0f $</span> will make the text twice as big, while <span class="math align-center">$ 0.5f $</span> would make it half as big.  This scaling is in relation to the <code>origin</code>, so if the origin is at the center of the text grows in all directions equally.  If instead it is at <span class="math align-center">$ (0,0) $</span>, the text will grow to the right and down only.</p>
<h4 id="vector2-scale">Vector2 scale</h4>
<p>The <code>scale</code> can also be specified as a <code>Vector2</code>, which allows the horizontal and vertical scaling factors to be different.</p>
<h4 id="spriteeffects-effects">SpriteEffects effects</h4>
<p>The <code>effects</code> parameter is one of the <code>SpriteEffects</code> enum&rsquo;s values.  These are:</p>
<ul>
<li><code>SpriteEffects.None</code> - the text is drawn normally</li>
<li><code>SpriteEffects.FlipHorizontally</code> - the text is drawn with the texture flipped in the horizontal direction</li>
<li><code>SpriteEffects.FlipVertically</code> - the text is drawn with the texture flipped in the vertical direction</li>
</ul>
<p>Note you can specify both horizontal and vertical flipping with a bitwise or: <code>SpriteEffects.FlipHorizontally | SpriteEffects.FlipVertically</code></p>
<h4 id="single-layerdepth">single layerDepth</h4>
<p>The <code>layerDepth</code> is an integer that indicates which sprites should be drawn &ldquo;above&rdquo; or &ldquo;below&rdquo; others (i.e. which ones should obscure the others).  Think of it as assembling a collage.  Sprites with a higher <code>layerDepth</code> value are closer to the top, and if they share screen space with sprites with a <code>lowerDepth</code>, those sprites are obscured.</p>
<h2 id="measuring-with-spritefont">Measuring with SpriteFont</h2>
<p>Note that with <code>SpriteFont</code>, there is no way to specify the width the text should be drawn - it is entirely dependent on the font, the string to render, and any scaling factors applied.  Nor is there any automatic word wrapping.</p>
<p>However, the <code>SpriteFont</code> class does expose a method <code>SpriteFont.Measure(string text)</code> and override <code>SpriteFont.Measure(StringBuilder text)</code> which given a <code>string</code> or <code>StringBuilder</code> return a <code>Vector2</code> indicating the size at which that text would be rendered.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="sorting-sprites">Sorting Sprites</h1>

<p>When drawing sprites, we often refer to the <a href="https://en.wikipedia.org/wiki/Painter%27s_algorithm" rel="external" target="_blank">Painter&rsquo;s Algorithm</a>.  This algorithm simply involves drawing the most distant part of the scene <em>first</em> (i.e. background elements) before drawing the closer elements.  This way the closer elements are drawn <em>on top of</em> the elements behind them, as when we draw we are literally copying over the existing pixel color values.</p>
<p>This is even more important when working with <em>translucent</em> (partially transparent) sprites, as we mix the translucent color with the color(s) of the elements underneath the translucent sprite.  If those colors have not yet been set, this blending will not happen.</p>
<p>The <code>SpriteBatch</code> assumes that we batch sprites in the order we want them drawn, i.e. the most distant sprites should have their <code>Draw()</code> calls first.  For many games, this is simple to accomplish, but there are some where it becomes significantly challenging (i.e. tilemap games where some tiles are &ldquo;above&rdquo; the background layer).  For these games, we can utilize the <code>SpriteBatch</code>&rsquo;s built-in sorting.</p>
<p>This is activated by calling <code>SpriteBatch.Begin(SpriteSortMode.BackToFront)</code> instead of <code>SpriteBatch.Begin()</code>.  This replaces the default sorting mode, <code>SpriteSortMode.Deferred</code> with the back-to-front sorting, based on the <code>depthLayer</code> specified in the sprite&rsquo;s <code>Draw()</code> call.  When using this mode, the <code>SpriteBatch</code> sorts the sprites immediately before it renders them.</p>
<p>A couple of things to remember about this sorting:</p>
<ol>
<li>It is more efficient if the sprites are for the most part batched in the order they need to be drawn (as there is less rearranging to do)</li>
<li>The sorting order is not assured to be the same from frame-to-frame for sprites with the same <code>depthLayer</code> value.</li>
</ol>
<p>There is also a <code>SpriteSortMode.FrontToBack</code> mode that sorts sprites in the opposite order.  It can be helpful when your game specifies the <code>depthLayer</code> values opposite the expected order (larger numbers to the back).</p>
<p>In addition to these depth-sorting options, there is a <code>SpriteSortMode.Immediate</code> which, instead of batching the sprites draws them <em>immediately</em> when the <code>Draw()</code> call is made.  This can be less efficient as it requires the sprite drawing effect (a shader program) to be loaded into the graphics card for each sprite (rather than once for all sprites).</p>
<p>Finally, there is a <code>SpriteSortMode.Texture</code> option that orders sprites by their source texture.  As swapping textures is an expensive operation for the graphics card, arranging all sprites that use each texture to be drawn together can result in better efficiency.  However, this approach can make layered sprites be drawn out-of-order.  Thus, when possible it is better to use texture atlases to minimize texture swaps.</p>
<p>The <code>SpriteBatch.Begin()</code> has additional settings that can be overridden - we&rsquo;ll examine some of these in the lessons to come.</p>

  <footer class="footline">
  </footer>
</article>
<article class="default">
  <header class="headline">
  </header>

<h1 id="summary">Summary</h1>

<p>In this section we discussed the history of sprite implementations in video games, and saw the specific methods employed by MonoGame - textured quads rendered using the 3D hardware, and abstracted through the interface supplied by the <code>SpriteBatch</code> class.  We saw how textures can be rendered as sprites through <code>SpriteBatch.Draw()</code> calls, and how those calls can be customized to position, scale, rotate, recolor, and order the sprites.</p>
<p>We also saw how to optimize our sprite usage with texture atlases, where multiple sprite images are placed in a single texture, and drawn by specifying a source rectangle.  We also saw how this approach can be used to create sprite animation by combining a texture atlas populated with frames of animation with a timer controlling which frame of the animation is displayed.</p>
<p>We also saw how the <code>SpriteBatch</code> and content pipeline provide a means for transforming a modern font into a bitmap font that can be utilized within our games to draw arbitrary strings.  We also saw that these can also be customized similar to regular sprites.  Finally, we examined the various sorting modes available with the <code>SpriteSortMode</code> enum.</p>

  <footer class="footline">
  </footer>
</article>
          </section>
        </div>
      </main>
<div class="git-footer">
  <p class="theme-version-footer">8.0.0</p>
<p>Last modified by:
              <i class='fa-fw fas fa-user'></i> Nathan Bean
              <i class='fas fa-calendar'></i> <a href="https://github.com/ksu-cs-textbooks/cis580/commit/62ae652403b815125d822842fd28866700dbf1a1">Aug 19, 2025</a>
</p>

</div>
    </div>
    <script>
      window.MathJax = Object.assign( window.MathJax || {}, {
        tex: {
          inlineMath:  [['\\(', '\\)'], ['$',  '$']],  
          displayMath: [['\\[', '\\]'], ['$$', '$$']], 
        },
        options: {
          enableMenu: false 
        }
      }, JSON.parse("{}") );
    </script>
    <script id="MathJax-script" async src="/cis580/js/mathjax/tex-mml-chtml.js?1755628803"></script>
    <script src="/cis580/js/clipboard/clipboard.min.js?1755628803" defer></script>
    <script src="/cis580/js/perfect-scrollbar/perfect-scrollbar.min.js?1755628803" defer></script>
    <script src="/cis580/js/theme.min.js?1755628803" defer></script>
  </body>
</html>
